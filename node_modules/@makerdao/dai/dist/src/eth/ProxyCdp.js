"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _contracts = _interopRequireDefault(require("../../contracts/contracts"));

var _Currency = require("./Currency");

var ProxyCdp =
/*#__PURE__*/
function () {
  function ProxyCdp(cdpService, dsProxyAddress, cdpId) {
    var _this = this;

    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$lockAndDraw = _ref.lockAndDraw,
        lockAndDraw = _ref$lockAndDraw === void 0 ? false : _ref$lockAndDraw,
        _ref$amountEth = _ref.amountEth,
        amountEth = _ref$amountEth === void 0 ? null : _ref$amountEth,
        _ref$amountDai = _ref.amountDai,
        amountDai = _ref$amountDai === void 0 ? null : _ref$amountDai;

    (0, _classCallCheck2["default"])(this, ProxyCdp);
    this._cdpService = cdpService;
    this._smartContractService = this._cdpService.get('smartContract');
    this._transactionManager = this._smartContractService.get('transactionManager'); // prettier-ignore

    if (dsProxyAddress) this.dsProxyAddress = dsProxyAddress.toLowerCase();

    if (lockAndDraw) {
      this._create({
        lockAndDraw: lockAndDraw,
        amountEth: amountEth,
        amountDai: amountDai
      });
    } else {
      if (!cdpId) this._create();else this.id = cdpId;
    }

    this._emitterInstance = this._cdpService.get('event').buildEmitter();
    this.on = this._emitterInstance.on;

    this._emitterInstance.registerPollEvents({
      COLLATERAL: {
        USD: function USD() {
          return _this.getCollateralValue(_Currency.USD);
        },
        ETH: function ETH() {
          return _this.getCollateralValue();
        }
      },
      DEBT: {
        dai: function dai() {
          return _this.getDebtValue();
        }
      }
    });
  }

  (0, _createClass2["default"])(ProxyCdp, [{
    key: "_create",
    value: function _create() {
      var _this2 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$lockAndDraw = _ref2.lockAndDraw,
          lockAndDraw = _ref2$lockAndDraw === void 0 ? false : _ref2$lockAndDraw,
          _ref2$amountEth = _ref2.amountEth,
          amountEth = _ref2$amountEth === void 0 ? null : _ref2$amountEth,
          _ref2$amountDai = _ref2.amountDai,
          amountDai = _ref2$amountDai === void 0 ? null : _ref2$amountDai;

      var tub = this._smartContractService.getContract(_contracts["default"].SAI_TUB);

      var saiProxy = this._smartContractService.getContract(_contracts["default"].SAI_PROXY); // prettier-ignore


      var method, args;

      if (!this.dsProxyAddress) {
        var proxyRegistryAddress = this._smartContractService.getContractAddressByName(_contracts["default"].PROXY_REGISTRY); // prettier-ignore


        if (lockAndDraw) {
          var valueEth = (0, _Currency.getCurrency)(amountEth, _Currency.ETH).toFixed('wei');
          var valueDai = (0, _Currency.getCurrency)(amountDai, _Currency.DAI).toFixed('wei');
          method = 'createOpenLockAndDraw';
          args = [proxyRegistryAddress, tub.address, valueDai, {
            metadata: {
              action: {
                name: method,
                amountEth: (0, _Currency.getCurrency)(amountEth, _Currency.ETH),
                amountDai: (0, _Currency.getCurrency)(amountDai, _Currency.DAI)
              }
            },
            value: valueEth,
            promise: promise
          }];
        } else {
          method = 'createAndOpen';
          args = [proxyRegistryAddress, tub.address, {
            metadata: {
              action: {
                name: method
              }
            },
            promise: promise
          }];
        }
      } else {
        if (lockAndDraw) {
          var _valueEth = (0, _Currency.getCurrency)(amountEth, _Currency.ETH).toFixed('wei');

          var _valueDai = (0, _Currency.getCurrency)(amountDai, _Currency.DAI).toFixed('wei');

          method = 'lockAndDraw(address,uint256)';
          args = [tub.address, _valueDai, {
            metadata: {
              action: {
                name: 'openLockAndDraw',
                amountEth: (0, _Currency.getCurrency)(amountEth, _Currency.ETH),
                amountDai: (0, _Currency.getCurrency)(amountDai, _Currency.DAI),
                proxy: this.dsProxyAddress
              }
            },
            value: _valueEth,
            dsProxy: this.dsProxyAddress,
            promise: promise
          }];
        } else {
          method = 'open';
          args = [tub.address, {
            metadata: {
              action: {
                name: method,
                proxy: this.dsProxyAddress
              }
            },
            dsProxy: this.dsProxyAddress,
            promise: promise
          }];
        }
      }

      var getId = function getId(txo) {
        var log;

        switch (txo.metadata.method) {
          case 'createAndOpen':
            log = txo.receipt.logs[5];
            break;

          case 'createOpenLockAndDraw':
            log = txo.receipt.logs[5];
            break;

          case 'lockAndDraw':
            log = txo.receipt.logs[2];
            break;

          case 'open':
            log = txo.receipt.logs[2];
        }

        if (!_this2.dsProxyAddress) {
          _this2.dsProxyAddress = txo.receipt.logs[0].address;
        }

        return parseInt(log.data, 16);
      };

      var promise = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var txo;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return saiProxy[method].apply(saiProxy, (0, _toConsumableArray2["default"])(args));

              case 2:
                txo = _context.sent;
                _this2.id = getId(txo);
                return _context.abrupt("return", _this2);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
      this._transactionObject = promise;
    }
  }, {
    key: "transactionObject",
    value: function transactionObject() {
      return this._transactionObject;
    }
  }]);
  return ProxyCdp;
}(); // Each of these passthrough methods gets called on the EthereumCdpService
// If the second array item is true then the method name with 'Proxy' appended is
// called and the DSProxy address and CDP id are passed as the first and second arg
// Otherwise the method name is called and the just CDP id is passed


exports["default"] = ProxyCdp;
var passthroughMethods = [['bite', false], ['drawDai', true], ['enoughMkrToWipe', false], ['freeEth', true], // 'freePeth',
['getCollateralValue', false], ['getCollateralizationRatio', false], ['getDebtValue', false], ['getGovernanceFee', false], ['getInfo', false], ['getLiquidationPrice', false], ['isSafe', false], ['give', true], ['lockEth', true], // 'lockPeth',
// 'lockWeth',
['shut', true], ['wipeDai', true], ['lockEthAndDrawDai', true]];
Object.assign(ProxyCdp.prototype, passthroughMethods.reduce(function (acc, _ref4) {
  var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
      name = _ref5[0],
      useProxy = _ref5[1];

  acc[name] = useProxy ? function () {
    var _this$_cdpService;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_this$_cdpService = this._cdpService)[name + 'Proxy'].apply(_this$_cdpService, [this.dsProxyAddress, this.id].concat(args));
  } : function () {
    var _this$_cdpService2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return (_this$_cdpService2 = this._cdpService)[name].apply(_this$_cdpService2, [this.id].concat(args));
  };
  return acc;
}, {}));