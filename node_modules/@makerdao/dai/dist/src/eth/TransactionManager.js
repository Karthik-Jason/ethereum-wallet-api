"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _servicesCore = require("@makerdao/services-core");

var _TransactionObject = _interopRequireDefault(require("./TransactionObject"));

var _utils = require("../utils");

var _each = _interopRequireDefault(require("lodash/each"));

var _has = _interopRequireDefault(require("lodash/has"));

var _util = require("util");

var _debug = _interopRequireDefault(require("debug"));

var log = (0, _debug["default"])('dai:TransactionManager');

var TransactionManager =
/*#__PURE__*/
function (_PublicService) {
  (0, _inherits2["default"])(TransactionManager, _PublicService);

  function TransactionManager() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transactionManager';
    (0, _classCallCheck2["default"])(this, TransactionManager);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TransactionManager).call(this, name, ['web3', 'log', 'nonce', 'proxy', 'gas']));
    _this._newTxListeners = [];
    _this._tracker = new Tracker();
    return _this;
  } // this method must not be async


  (0, _createClass2["default"])(TransactionManager, [{
    key: "sendContractCall",
    value: function sendContractCall(contract, method, args, name) {
      var _this2 = this;

      log("sendContractCall: ".concat(name, ".").concat(method, " ").concat((0, _util.inspect)(args)));
      if (!args) args = [];
      var options,
          promise,
          businessObject,
          metadata = {
        contract: name,
        method: method.replace(/\(.*\)$/g, ''),
        args: args
      },
          lastArg = args[args.length - 1];

      if ((0, _typeof2["default"])(lastArg) === 'object' && lastArg.constructor === Object) {
        options = lastArg;
        args = args.slice(0, args.length - 1); // append additional metadata to the default values.

        if (options.metadata) {
          metadata = (0, _objectSpread2["default"])({}, metadata, options.metadata);
          delete options.metadata;
        }

        if ((0, _has["default"])(options, 'promise')) {
          if (options.promise) promise = options.promise;
          delete options.promise;
        }

        if (options.businessObject) {
          businessObject = options.businessObject;
          delete options.businessObject;
        }
      } else {
        options = {};
      } // for promise tracking to work, we must return to the caller the result of
      // _createTransactionObject, because that promise is the one stored for
      // lookup to attach lifecycle hooks.


      return this._createTransactionObject((0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var txOptions;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2._buildTransactionOptions(options, contract, method, args);

              case 2:
                txOptions = _context.sent;
                return _context.abrupt("return", _this2._execute(contract, method, args, txOptions));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))(), {
        businessObject: businessObject,
        metadata: metadata,
        promise: promise
      });
    } // this method must not be async

  }, {
    key: "sendTransaction",
    value: function sendTransaction(options, metadata) {
      var _this3 = this;

      return this._createTransactionObject((0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var txOptions;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this3._buildTransactionOptions(options);

              case 2:
                txOptions = _context2.sent;
                return _context2.abrupt("return", _this3.get('web3').sendTransaction(txOptions));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))(), metadata);
    }
  }, {
    key: "onNewTransaction",
    value: function onNewTransaction(cb) {
      this._newTxListeners.push(cb);
    }
  }, {
    key: "onTransactionUpdate",
    value: function onTransactionUpdate(cb) {
      var _this4 = this;

      this._tracker._globalListeners.push(cb);

      return {
        unsub: function unsub() {
          var idx = _this4._tracker._globalListeners.indexOf(cb);

          if (idx !== -1) _this4._tracker._globalListeners.splice(idx, 1);
        }
      };
    }
  }, {
    key: "getTransaction",
    value: function getTransaction(promise, label) {
      return this._tracker.get((0, _utils.uniqueId)(promise), label);
    }
  }, {
    key: "confirm",
    value: function () {
      var _confirm = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(promise, count) {
        var txs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return promise;

              case 2:
                txs = this._tracker.getAll((0, _utils.uniqueId)(promise));
                return _context3.abrupt("return", Promise.all(txs.map(function (tx) {
                  return tx.confirm(count);
                })));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function confirm(_x, _x2) {
        return _confirm.apply(this, arguments);
      }

      return confirm;
    }()
  }, {
    key: "isMined",
    value: function isMined(promise) {
      return this._tracker.get((0, _utils.uniqueId)(promise)).isMined();
    }
  }, {
    key: "listen",
    value: function listen(promise, handlers) {
      if (typeof handlers === 'function') {
        this._tracker.listen((0, _utils.uniqueId)(promise), {
          pending: function pending(tx) {
            return handlers(tx, 'pending');
          },
          mined: function mined(tx) {
            return handlers(tx, 'mined');
          },
          confirmed: function confirmed(tx) {
            return handlers(tx, 'confirmed');
          },
          error: function error(tx, err) {
            return handlers(tx, 'error', err);
          }
        });
      } else {
        this._tracker.listen((0, _utils.uniqueId)(promise), handlers);
      }
    } // if options.dsProxy is set, execute this contract method through the
    // proxy contract at that address.

  }, {
    key: "_execute",
    value: function _execute(contract, method, args, options) {
      if (!options.dsProxy) return contract[method].apply(contract, (0, _toConsumableArray2["default"])(args).concat([options]));
      var address;

      if (typeof options.dsProxy === 'string') {
        address = options.dsProxy;
      }

      delete options.dsProxy;
      return this.get('proxy').execute(contract, method, args, options, address);
    }
  }, {
    key: "_createTransactionObject",
    value: function _createTransactionObject(tx) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          businessObject = _ref3.businessObject,
          metadata = _ref3.metadata,
          promise = _ref3.promise;

      var txo = new _TransactionObject["default"](tx, this, {
        businessObject: businessObject,
        metadata: metadata
      });

      this._newTxListeners.forEach(function (cb) {
        return cb(txo);
      });

      var minePromise = txo.mine(); // we store the transaction object under the unique id of its own mine
      // promise, so that it can be looked up when calling a contract function
      // directly from a service method, e.g. WethToken.deposit.

      this._tracker.store((0, _utils.uniqueId)(minePromise), txo); // if the `promise` object is defined in the options argument, we also store
      // the transaction object under that promise's id, so that it can be looked
      // up when calling a contract function indirectly via two or more nested
      // service method calls, e.g.
      // EthereumCdpService.lockEth -> WethToken.deposit.


      if (promise) this._tracker.store((0, _utils.uniqueId)(promise), txo, {
        globalTxStateUpdates: false
      });
      return minePromise;
    }
  }, {
    key: "_buildTransactionOptions",
    value: function () {
      var _buildTransactionOptions2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(options, contract, method, args) {
        var txSpeed;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(contract && !options.gasLimit)) {
                  _context4.next = 4;
                  break;
                }

                _context4.next = 3;
                return this._getGasLimit(options, contract, method, args);

              case 3:
                options.gasLimit = _context4.sent;

              case 4:
                if (this.get('gas').disablePrice) {
                  _context4.next = 9;
                  break;
                }

                txSpeed = options.transactionSpeed;
                _context4.next = 8;
                return this.get('gas').getGasPrice(txSpeed);

              case 8:
                options.gasPrice = _context4.sent;

              case 9:
                _context4.t0 = _objectSpread2["default"];
                _context4.t1 = {};
                _context4.t2 = options;
                _context4.t3 = this.get('web3').transactionSettings();
                _context4.next = 15;
                return this.get('nonce').getNonce();

              case 15:
                _context4.t4 = _context4.sent;
                _context4.t5 = {
                  nonce: _context4.t4
                };
                return _context4.abrupt("return", (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3, _context4.t5));

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _buildTransactionOptions(_x3, _x4, _x5, _x6) {
        return _buildTransactionOptions2.apply(this, arguments);
      }

      return _buildTransactionOptions;
    }()
  }, {
    key: "_getGasLimit",
    value: function () {
      var _getGasLimit2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(options, contract, method, args) {
        var _contract$interface$f;

        var transaction, data, proxyAddress, proxy;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                transaction = {};
                data = (_contract$interface$f = contract["interface"].functions)[method].apply(_contract$interface$f, (0, _toConsumableArray2["default"])(args)).data;

                if (!options.dsProxy) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 5;
                return this.get('proxy').currentProxy();

              case 5:
                proxyAddress = _context5.sent;
                proxy = this.get('proxy').getUnwrappedProxyContract(proxyAddress);
                data = proxy["interface"].functions['execute'](contract.address, data).data;

              case 8:
                if (options.value) {
                  transaction.value = options.value;
                }

                transaction = (0, _objectSpread2["default"])({
                  from: this.get('web3').currentAddress(),
                  to: options.dsProxy ? proxyAddress : contract.address,
                  data: data
                }, transaction);
                return _context5.abrupt("return", this.get('gas').estimateGasLimit(transaction));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getGasLimit(_x7, _x8, _x9, _x10) {
        return _getGasLimit2.apply(this, arguments);
      }

      return _getGasLimit;
    }()
  }]);
  return TransactionManager;
}(_servicesCore.PublicService);

exports["default"] = TransactionManager;

var Tracker =
/*#__PURE__*/
function () {
  function Tracker() {
    (0, _classCallCheck2["default"])(this, Tracker);
    this._listeners = {};
    this._globalListeners = [];
    this._transactions = {};
  }

  (0, _createClass2["default"])(Tracker, [{
    key: "store",
    value: function store(key, tx) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        globalTxStateUpdates: true
      };

      this._init(key);

      this._transactions[key].push(tx);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var state = _step.value;
          tx.on(state, function () {
            if (options.globalTxStateUpdates) {
              _this5._globalListeners.forEach(function (cb) {
                return tx.error ? cb(tx, state, tx.error) : cb(tx, state);
              });
            }

            _this5._listeners[key][state].forEach(function (cb) {
              return tx.error ? cb(tx, tx.error) : cb(tx);
            });
          });
        };

        for (var _iterator = this.constructor.states[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (options.globalTxStateUpdates) this._globalListeners.forEach(function (cb) {
        return cb(tx, 'initialized');
      });

      this._listeners[key].initialized.forEach(function (cb) {
        return tx.error ? cb(tx, tx.error) : cb(tx);
      });

      this.clearExpiredTransactions();
    }
  }, {
    key: "listen",
    value: function listen(key, handlers) {
      var _this6 = this;

      this._init(key);

      var _loop2 = function _loop2(_state) {
        var cb = handlers[_state];
        if (_state === 'confirmed') _state = 'finalized';

        _this6._listeners[key][_state].push(cb); // if event has already happened, call handler immediately


        _this6._transactions[key].forEach(function (tx) {
          return tx && tx.inOrPastState(_state) && (tx.error ? cb(tx, tx.error) : cb(tx));
        });

        state = _state;
      };

      for (var state in handlers) {
        _loop2(state);
      }
    }
  }, {
    key: "getAll",
    value: function getAll(key) {
      return this._transactions[key];
    }
  }, {
    key: "get",
    value: function get(key) {
      var txs = this._transactions[key];

      if (!txs || txs.length === 0) {
        throw new Error("No transactions for key ".concat(key));
      }

      if (txs.length > 1) {
        console.warn("Key ".concat(key, " matches ").concat(txs.length, " transactions; returning the first."));
      }

      return txs[0];
    }
  }, {
    key: "clearExpiredTransactions",
    value: function clearExpiredTransactions() {
      var _this7 = this;

      (0, _each["default"])(this._transactions, function (txList, key) {
        txList.forEach(function (tx) {
          var txAge = (new Date().getTime() - new Date(tx._timeStampMined).getTime()) / 60000;

          if ((tx.isError() || tx.isFinalized()) && txAge > 5) {
            var indexToRemove = _this7._transactions[key].indexOf(tx);

            _this7._transactions[key].splice(indexToRemove, 1);

            if (_this7._transactions[key].length === 0) {
              delete _this7._transactions[key];
              delete _this7._listeners[key];
            }
          }
        });
      });
    }
  }, {
    key: "_init",
    value: function _init(key) {
      if (!this._transactions[key]) this._transactions[key] = [];

      if (!this._listeners[key]) {
        this._listeners[key] = this.constructor.states.reduce(function (acc, state) {
          acc[state] = [];
          return acc;
        }, {});
      }
    }
  }]);
  return Tracker;
}();

(0, _defineProperty2["default"])(Tracker, "states", ['initialized', 'pending', 'mined', 'finalized', 'error']);