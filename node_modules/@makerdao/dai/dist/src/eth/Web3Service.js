"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _servicesCore = require("@makerdao/services-core");

var _utils = require("../utils");

var _Web3ServiceList = _interopRequireDefault(require("../utils/Web3ServiceList"));

var _promiseProps = _interopRequireDefault(require("promise-props"));

var _web = _interopRequireDefault(require("web3"));

var _ProviderType = _interopRequireDefault(require("./web3/ProviderType"));

var _ShimEthersSigner = _interopRequireDefault(require("./web3/ShimEthersSigner"));

var _last = _interopRequireDefault(require("lodash/last"));

var TIMER_CONNECTION = 'web3CheckConnectionStatus';
var TIMER_AUTHENTICATION = 'web3CheckAuthenticationStatus';
var TIMER_DEFAULT_DELAY = 5000;

var Web3Service =
/*#__PURE__*/
function (_PrivateService) {
  (0, _inherits2["default"])(Web3Service, _PrivateService);

  function Web3Service() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'web3';
    (0, _classCallCheck2["default"])(this, Web3Service);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Web3Service).call(this, name, ['accounts', 'log', 'timer', 'cache', 'event']));
    _this._blockListeners = {};
    _this._info = {};
    _this._statusTimerDelay = TIMER_DEFAULT_DELAY;

    _Web3ServiceList["default"].push((0, _assertThisInitialized2["default"])(_this));

    return _this;
  }

  (0, _createClass2["default"])(Web3Service, [{
    key: "info",
    value: function info() {
      return this._info;
    }
  }, {
    key: "networkId",
    value: function networkId() {
      var result = this.info().network;

      if (!result) {
        throw new Error('Cannot resolve network ID. Are you connected?');
      }

      return parseInt(result);
    }
  }, {
    key: "currentAddress",
    value: function currentAddress() {
      return this.get('accounts').currentAddress();
    }
  }, {
    key: "ethersProvider",
    value: function ethersProvider() {
      try {
        throw new Error('hi');
      } catch (err) {
        console.warn('using ethers provider is deprecated...\n' + err.stack.split('\n').slice(1, 7).join('\n'));
      }

      return this._ethersProvider;
    }
  }, {
    key: "getEthersSigner",
    value: function getEthersSigner() {
      if (!this._ethersSigner) this._ethersSigner = (0, _ShimEthersSigner["default"])(this);
      return this._ethersSigner;
    }
  }, {
    key: "web3Provider",
    value: function web3Provider() {
      return this._web3.currentProvider;
    }
  }, {
    key: "transactionSettings",
    value: function transactionSettings() {
      return this._transactionSettings;
    }
  }, {
    key: "usingWebsockets",
    value: function usingWebsockets() {
      return this._serviceManager._settings.provider.type === _ProviderType["default"].WEBSOCKET;
    }
  }, {
    key: "confirmedBlockCount",
    value: function confirmedBlockCount() {
      return this._confirmedBlockCount;
    }
  }, {
    key: "web3Contract",
    value: function web3Contract(abi, address) {
      return new this._web3.eth.Contract(abi, address);
    }
  }, {
    key: "initialize",
    value: function initialize(settings) {
      var _this2 = this;

      this.get('log').info('Web3 is initializing...');
      this._defaultEmitter = this.get('event');
      this._web3 = new _web["default"]();

      this._web3.setProvider(this.get('accounts').getProvider());

      Object.assign(this, ['estimateGas', 'getAccounts', 'getBalance', 'getBlock', 'getPastLogs', 'getStorageAt', 'getTransaction', 'getTransactionReceipt', 'subscribe'].reduce(function (acc, method) {
        acc[method] = function () {
          var _this2$_web3$eth;

          return (_this2$_web3$eth = _this2._web3.eth)[method].apply(_this2$_web3$eth, arguments);
        };

        return acc;
      }, {}));
      this.eth = new Proxy(this, {
        get: function get(target, key) {
          if (typeof key === 'string') console.warn("use .".concat(key, " instead of .eth.").concat(key));
          return target[key];
        }
      });

      this._setStatusTimerDelay(settings.statusTimerDelay);

      this._installCleanUpHooks();

      this._defaultEmitter.emit('web3/INITIALIZED', {
        provider: (0, _objectSpread2["default"])({}, settings.provider)
      });

      this._transactionSettings = settings.transactionSettings;
      this._confirmedBlockCount = settings.confirmedBlockCount || 5;
      this._pollingInterval = settings.pollingInterval || 4000;
    }
  }, {
    key: "connect",
    value: function () {
      var _connect = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.get('log').info('Web3 is connecting...');
                _context.next = 3;
                return (0, _promiseProps["default"])({
                  api: this._web3.version,
                  node: (0, _utils.promisify)(this._web3.eth.getNodeInfo)(),
                  network: (0, _utils.promisify)(this._web3.eth.net.getId)(),
                  ethereum: (0, _utils.promisify)(this._web3.eth.getProtocolVersion)()
                });

              case 3:
                this._info = _context.sent;

                if (!this._info.node.includes('MetaMask')) {
                  this._info.whisper = this._web3.shh;
                } // FIXME set up block listening with web3 instead


                this._setUpEthers(this.networkId());

                _context.next = 8;
                return this._web3.eth.getBlockNumber();

              case 8:
                this._currentBlock = _context.sent;

                this._listenForNewBlocks();

                this._installDisconnectCheck();

                _context.next = 13;
                return this._initEventPolling();

              case 13:
                this._defaultEmitter.emit('web3/CONNECTED', (0, _objectSpread2["default"])({}, this._info));

                this.get('log').info('Web3 version: ', this._info.api);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.get('log').info('Web3 is authenticating...');

                this._defaultEmitter.emit('web3/AUTHENTICATED', {
                  account: this.currentAddress()
                });

                this._installDeauthenticationCheck();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function authenticate() {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
    /*
      sendTransaction in web3 1.0 behaves differently from its counterpart in
      0.2x.x. it doesn't resolve until the transaction has a receipt, and throws an
      error if the receipt indicates that the transaction was reverted.
      the setup below emulates the old behavior, because TransactionObject still
      expects it. if there is an error due to the transaction being reverted, it
      will be ignored, because the promise will have already resolved.
       this can (and should) be refactored when we drop support for HTTP providers.
       https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsendtransaction
      https://web3js.readthedocs.io/en/1.0/web3-eth.html#sendtransaction
    */

  }, {
    key: "sendTransaction",
    value: function sendTransaction() {
      var _this3 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        var _this3$_web3$eth;

        (_this3$_web3$eth = _this3._web3.eth).sendTransaction.apply(_this3$_web3$eth, args).on('transactionHash', resolve).on('error', reject);
      });
    }
  }, {
    key: "blockNumber",
    value: function blockNumber() {
      return this._currentBlock;
    }
  }, {
    key: "_listenForNewBlocks",
    value: function _listenForNewBlocks() {
      var _this4 = this;

      if (this.usingWebsockets()) {
        this._newBlocksSubscription = this.subscribe('newBlockHeaders').on('data', function (data) {
          return _this4._updateBlockNumber(data.number);
        });
      } else {
        var updateBlocks =
        /*#__PURE__*/
        function () {
          var _ref = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee3() {
            var blockNumber, i;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return _this4._web3.eth.getBlockNumber();

                  case 2:
                    blockNumber = _context3.sent;
                    if (!_this4._currentBlock) _this4._currentBlock = blockNumber - 1;

                    for (i = _this4._currentBlock + 1; i <= blockNumber; i++) {
                      _this4._updateBlockNumber(i);
                    }

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          return function updateBlocks() {
            return _ref.apply(this, arguments);
          };
        }();

        this._updateBlocksInterval = setInterval(updateBlocks, this._pollingInterval);
      }
    }
  }, {
    key: "onNewBlock",
    value: function onNewBlock(callback) {
      if (!this._blockListeners['*']) {
        this._blockListeners['*'] = [];
      }

      this._blockListeners['*'].push(callback);
    }
  }, {
    key: "waitForBlockNumber",
    value: function () {
      var _waitForBlockNumber = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(blockNumber) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(blockNumber < this._currentBlock)) {
                  _context4.next = 3;
                  break;
                }

                console.error('Attempted to wait for past block ' + blockNumber);
                return _context4.abrupt("return");

              case 3:
                if (!(blockNumber === this._currentBlock)) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return", Promise.resolve(blockNumber));

              case 5:
                if (!this._blockListeners[blockNumber]) {
                  this._blockListeners[blockNumber] = [];
                }

                return _context4.abrupt("return", new Promise(function (resolve) {
                  _this5._blockListeners[blockNumber].push(resolve);
                }));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function waitForBlockNumber(_x) {
        return _waitForBlockNumber.apply(this, arguments);
      }

      return waitForBlockNumber;
    }()
  }, {
    key: "_updateBlockNumber",
    value: function _updateBlockNumber(blockNumber) {
      this.get('log').info('New block:', blockNumber);
      this._currentBlock = blockNumber;

      if (this._blockListeners[blockNumber]) {
        this._blockListeners[blockNumber].forEach(function (c) {
          return c(blockNumber);
        });

        this._blockListeners[blockNumber] = undefined;
      }

      if (this._blockListeners['*']) {
        this._blockListeners['*'].forEach(function (c) {
          return c(blockNumber);
        });
      }
    }
  }, {
    key: "_initEventPolling",
    value: function _initEventPolling() {
      this.onNewBlock(this.get('event').ping);
    }
  }, {
    key: "_removeBlockUpdates",
    value: function _removeBlockUpdates() {
      if (this.usingWebsockets()) {
        this._newBlocksSubscription.unsubscribe(function (err, success) {
          if (!success) throw new Error(err);
        });
      } else {
        clearInterval(this._updateBlocksInterval);
      }
    }
  }, {
    key: "_installCleanUpHooks",
    value: function _installCleanUpHooks() {
      var _this6 = this;

      this.manager().onDisconnected(function () {
        _this6._removeBlockUpdates();

        _this6.get('timer').disposeTimer(TIMER_CONNECTION);
      });
      this.manager().onDeauthenticated(function () {
        _this6.get('timer').disposeTimer(TIMER_AUTHENTICATION);
      });
    }
  }, {
    key: "_setUpEthers",
    value: function _setUpEthers(chainId) {
      var ethers = require('ethers');

      this._ethersProvider = this._buildEthersProvider(ethers, chainId);
    }
  }, {
    key: "_buildEthersProvider",
    value: function _buildEthersProvider(ethers, chainId) {
      var provider = new ethers.providers.Web3Provider(this._web3.currentProvider, {
        name: (0, _utils.getNetworkName)(chainId),
        chainId: chainId
      });
      return provider;
    }
  }, {
    key: "_setStatusTimerDelay",
    value: function _setStatusTimerDelay(delay) {
      this._statusTimerDelay = delay ? parseInt(delay) : TIMER_DEFAULT_DELAY;
    }
  }, {
    key: "_installDisconnectCheck",
    value: function _installDisconnectCheck() {
      var _this7 = this;

      this.get('timer').createTimer(TIMER_CONNECTION, this._statusTimerDelay, true, function () {
        return _this7._isStillConnected().then(function (connected) {
          if (!connected) {
            _this7._defaultEmitter.emit('web3/DISCONNECTED');

            _this7.disconnect();
          }
        });
      });
    }
  }, {
    key: "_isStillConnected",
    value: function _isStillConnected() {
      var _this8 = this;

      // only determine network change as disconnect if service is connected
      if (!this.manager().isConnected()) {
        return false;
      }

      return (0, _utils.promisify)(this._web3.eth.net.getId)().then(function (network) {
        return network === _this8._info['network'];
      })["catch"](function () {
        return false;
      });
    }
  }, {
    key: "_installDeauthenticationCheck",
    value: function _installDeauthenticationCheck() {
      var _this9 = this;

      this.get('timer').createTimer(TIMER_AUTHENTICATION, this._statusTimerDelay, //what should this number be?
      true, function () {
        return _this9._isStillAuthenticated().then(function (authenticated) {
          if (!authenticated) {
            _this9._defaultEmitter.emit('web3/DEAUTHENTICATED');

            _this9.deauthenticate();
          }
        });
      });
    }
  }, {
    key: "_isStillAuthenticated",
    value: function () {
      var _isStillAuthenticated2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        var account;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.get('accounts').hasNonProviderAccount()) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", this._isStillConnected());

              case 2:
                _context5.next = 4;
                return (0, _utils.promisify)(this._web3.eth.getAccounts)();

              case 4:
                account = _context5.sent[0];
                return _context5.abrupt("return", account === this.currentAddress());

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _isStillAuthenticated() {
        return _isStillAuthenticated2.apply(this, arguments);
      }

      return _isStillAuthenticated;
    }()
  }, {
    key: "network",
    get: function get() {
      return this._info.network;
    }
  }, {
    key: "networkName",
    get: function get() {
      return (0, _utils.getNetworkName)(this.networkId());
    }
  }, {
    key: "rpcUrl",
    get: function get() {
      return (0, _last["default"])(this._web3.currentProvider._providers).rpcUrl;
    }
  }]);
  return Web3Service;
}(_servicesCore.PrivateService);

exports["default"] = Web3Service;