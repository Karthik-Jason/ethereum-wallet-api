"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapContract = wrapContract;

function wrapContract(contract, name, abi, txManager) {
  var nonConstantFns = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = abi[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _step.value,
          type = _step$value.type,
          constant = _step$value.constant,
          _name = _step$value.name,
          inputs = _step$value.inputs;

      if (type === 'function' && constant === false) {
        // Map all of the contract method names + sigs in cases where the method
        // sig is used as the key due to method overloading, e.g.
        // contract["method(address,uint256)"](foo, bar)
        if (inputs.length > 0) {
          var methodSig = "".concat(_name, "(").concat(inputs.map(function (i) {
            return i.type;
          }).join(','), ")");
          nonConstantFns[methodSig] = true;
        } // Currently assume that the default method chosen by Ethers when there
        // are multiple overloaded methods of the same name is non-constant


        nonConstantFns[_name] = true;
      }
    } // Why is the first argument an almost-empty object? The functions in
    // ethers.Contract are set up as read-only, non-configurable properties, which
    // means if we try to change their values with Proxy, we get an error.
    //
    // But that only happens if the contract is specified as the first argument to
    // Proxy. So we don't do that. Go on, wag your finger.
    //
    // See https://stackoverflow.com/a/48495509/56817 for more explanation.

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var proxy = new Proxy({
    // this is handy for testing, but probably shouldn't be used for anything
    // else
    wrappedContract: contract
  }, {
    get: function get(target, key) {
      if (key in target) return target[key];
      if (!txManager || !nonConstantFns[key]) return contract[key];
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return txManager.sendContractCall(contract, key, args, name);
      };
    },
    set: function set(target, key, value) {
      contract[key] = value;
      return true;
    }
  });
  return proxy;
}