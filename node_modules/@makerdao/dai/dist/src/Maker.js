"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _DefaultServiceProvider = _interopRequireWildcard(require("./config/DefaultServiceProvider"));

var _ConfigFactory = _interopRequireDefault(require("./config/ConfigFactory"));

var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

/**
 * do not call `new Maker()` directly; use `Maker.create` instead
 */
var Maker =
/*#__PURE__*/
function () {
  function Maker(preset) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, Maker);
    var _options$plugins = options.plugins,
        plugins = _options$plugins === void 0 ? [] : _options$plugins,
        otherOptions = (0, _objectWithoutProperties2["default"])(options, ["plugins"]);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
            plugin = _step$value[0],
            pluginOptions = _step$value[1];

        if (plugin.addConfig) {
          mergeOptions(otherOptions, plugin.addConfig(otherOptions, pluginOptions));
        }
      } // This ensures user supplied config options always take priority

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (plugins && userOptions) mergeOptions(otherOptions, userOptions);

    var config = _ConfigFactory["default"].create(preset, otherOptions, _DefaultServiceProvider.resolver);

    this._container = new _DefaultServiceProvider["default"](config).buildContainer();
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var pluginTuple = _step2.value;

        var _pluginTuple = (0, _slicedToArray2["default"])(pluginTuple, 2),
            plugin = _pluginTuple[0],
            pluginOptions = _pluginTuple[1];

        if (typeof plugin === 'function') {
          plugin(this, config, pluginOptions);
        } else if (plugin.afterCreate) {
          plugin.afterCreate(this, config, pluginOptions);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (otherOptions.autoAuthenticate !== false) this.authenticate();
    delegateToServices(this, {
      accounts: ['addAccount', 'currentAccount', 'currentAddress', 'listAccounts', 'useAccount', 'useAccountWithAddress'],
      cdp: ['getCdp', 'openCdp', 'getCdpIds'],
      event: ['on'],
      proxy: ['currentProxy'],
      token: ['getToken']
    });
  }

  (0, _createClass2["default"])(Maker, [{
    key: "authenticate",
    value: function authenticate() {
      if (!this._authenticatedPromise) {
        this._authenticatedPromise = this._container.authenticate();
      }

      return this._authenticatedPromise;
    } // skipAuthCheck should only be set if you're sure you don't need the service
    // to be initialized yet, e.g. when setting up a plugin

  }, {
    key: "service",
    value: function service(_service) {
      var skipAuthCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var skipAuthCheckForServices = ['event'];

      if (!skipAuthCheck && !this._container.isAuthenticated && !skipAuthCheckForServices.includes(_service)) {
        throw new Error("Can't use service ".concat(_service, " before authenticate() has finished."));
      }

      return this._container.service(_service);
    }
  }]);
  return Maker;
}();

exports["default"] = Maker;

function delegateToServices(maker, services) {
  var _loop = function _loop(serviceName) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      var _loop2 = function _loop2() {
        var methodName = _step3.value;

        maker[methodName] = function () {
          var _maker$service;

          return (_maker$service = maker.service(serviceName))[methodName].apply(_maker$service, arguments);
        };
      };

      for (var _iterator3 = services[serviceName][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        _loop2();
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };

  for (var serviceName in services) {
    _loop(serviceName);
  }
}

function mergeOptions(object, source) {
  return (0, _mergeWith["default"])(object, source, function (objValue, srcValue, key) {
    if (Array.isArray(objValue) && key === 'abi') return (0, _uniq["default"])(objValue);
    if (Array.isArray(objValue) && key !== 'abi') return (0, _uniq["default"])(objValue.concat(srcValue)); // when this function returns undefined, mergeWith falls back to the
    // default merging behavior.
    // https://devdocs.io/lodash~4/index#mergeWith
  });
}

Maker.create =
/*#__PURE__*/
(0, _asyncToGenerator2["default"])(
/*#__PURE__*/
_regenerator["default"].mark(function _callee() {
  var _len,
      args,
      _key,
      preset,
      _args$,
      options,
      plugins,
      otherOptions,
      userOptions,
      pluginTuples,
      _iteratorNormalCompletion4,
      _didIteratorError4,
      _iteratorError4,
      _iterator4,
      _step4,
      _step4$value,
      plugin,
      pluginOptions,
      resultOptions,
      maker,
      _args = arguments;

  return _regenerator["default"].wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = _args[_key];
          }

          preset = args[0], _args$ = args[1], options = _args$ === void 0 ? {} : _args$;
          plugins = options.plugins, otherOptions = (0, _objectWithoutProperties2["default"])(options, ["plugins"]); // Preserve the user supplied options to apply after plugins are executed.

          userOptions = (0, _cloneDeep["default"])(otherOptions);

          if (!plugins) {
            _context.next = 36;
            break;
          }

          // If its not already, format the plugin to be a tuple
          // of type [plugin, options object].
          pluginTuples = plugins.map(function (plugin) {
            return !Array.isArray(plugin) ? [plugin, {}] : plugin;
          });
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context.prev = 9;
          _iterator4 = pluginTuples[Symbol.iterator]();

        case 11:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context.next = 21;
            break;
          }

          _step4$value = (0, _slicedToArray2["default"])(_step4.value, 2), plugin = _step4$value[0], pluginOptions = _step4$value[1];

          if (!plugin.beforeCreate) {
            _context.next = 18;
            break;
          }

          _context.next = 16;
          return plugin.beforeCreate(pluginOptions);

        case 16:
          resultOptions = _context.sent;
          Object.assign(options, resultOptions);

        case 18:
          _iteratorNormalCompletion4 = true;
          _context.next = 11;
          break;

        case 21:
          _context.next = 27;
          break;

        case 23:
          _context.prev = 23;
          _context.t0 = _context["catch"](9);
          _didIteratorError4 = true;
          _iteratorError4 = _context.t0;

        case 27:
          _context.prev = 27;
          _context.prev = 28;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 30:
          _context.prev = 30;

          if (!_didIteratorError4) {
            _context.next = 33;
            break;
          }

          throw _iteratorError4;

        case 33:
          return _context.finish(30);

        case 34:
          return _context.finish(27);

        case 35:
          // reassign the plugins array in the options
          options.plugins = pluginTuples;

        case 36:
          maker = new Maker(preset, options, userOptions);

          if (!(options.autoAuthenticate !== false)) {
            _context.next = 40;
            break;
          }

          _context.next = 40;
          return maker.authenticate();

        case 40:
          return _context.abrupt("return", maker);

        case 41:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[9, 23, 27, 35], [28,, 30, 34]]);
}));