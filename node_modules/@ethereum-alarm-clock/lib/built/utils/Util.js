"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = require("bignumber.js");
const Web3 = require("web3");
const Constants_1 = require("../Constants");
const ethUtil = require("ethereumjs-util");
const AddressesJSONMainnet = require("../../config/contracts/1.json");
const AddressesJSONRopsten = require("../../config/contracts/3.json");
const AddressesJSONRinkeby = require("../../config/contracts/4.json");
const AddressesJSONRSKTestnet = require("../../config/contracts/31.json");
const AddressesJSONKovan = require("../../config/contracts/42.json");
const AddressesJSONTobalaba = require("../../config/contracts/401697.json");
const AddressesJSONTest = require("../../config/contracts/1002.json");
var Networks;
(function (Networks) {
    Networks[Networks["Private"] = 0] = "Private";
    Networks[Networks["Mainnet"] = 1] = "Mainnet";
    Networks[Networks["Morden"] = 2] = "Morden";
    Networks[Networks["Ropsten"] = 3] = "Ropsten";
    Networks[Networks["Rinkeby"] = 4] = "Rinkeby";
    // RSKMainNet = 30, not enabled yet
    Networks[Networks["RSKTestNet"] = 31] = "RSKTestNet";
    Networks[Networks["Kovan"] = 42] = "Kovan";
    Networks[Networks["Docker"] = 1001] = "Docker";
    Networks[Networks["Development"] = 1002] = "Development";
    Networks[Networks["Tobalaba"] = 401697] = "Tobalaba";
})(Networks = exports.Networks || (exports.Networks = {}));
const NETWORK_ID_TO_NAME_MAP = {
    [Networks.Mainnet]: 'mainnet',
    [Networks.Ropsten]: 'ropsten',
    [Networks.Rinkeby]: 'rinkeby',
    [Networks.RSKTestNet]: 'rsk_testnet',
    [Networks.Kovan]: 'kovan',
    [Networks.Docker]: 'docker',
    [Networks.Development]: 'development',
    [Networks.Tobalaba]: 'tobalaba'
};
const REQUEST_FACTORY_STARTBLOCKS = {
    [Networks.Mainnet]: 6204104,
    [Networks.Ropsten]: 2594245,
    [Networks.Kovan]: 5555500,
    [Networks.RSKTestNet]: '0x21b0f'
};
const NETWORK_TO_ADDRESSES_MAPPING = {
    1: AddressesJSONMainnet,
    3: AddressesJSONRopsten,
    4: AddressesJSONRinkeby,
    31: AddressesJSONRSKTestnet,
    42: AddressesJSONKovan,
    401697: AddressesJSONTobalaba,
    1002: AddressesJSONTest
};
const EXECUTION_OVERHEAD = 180000;
class Util {
    static getWeb3FromProviderUrl(providerUrl) {
        let provider;
        if (this.isHTTPConnection(providerUrl)) {
            provider = new Web3.providers.HttpProvider(providerUrl);
        }
        else if (this.isWSConnection(providerUrl)) {
            provider = new Web3.providers.WebsocketProvider(providerUrl);
        }
        else {
            throw Error('Unsupported provider.');
        }
        return new Web3(provider);
    }
    static isHTTPConnection(url) {
        return url.includes('http://') || url.includes('https://');
    }
    static isWatchingEnabled(web3) {
        return new Promise(resolve => {
            web3.currentProvider.send({
                jsonrpc: '2.0',
                id: new Date().getTime(),
                method: 'eth_subscribe',
                params: ['0x16'] // we need to provide at least 1 argument, this is test data
            }, (err) => {
                resolve(err === null);
            });
        });
    }
    static isWSConnection(url) {
        return url.includes('ws://') || url.includes('wss://');
    }
    static testProvider(providerUrl) {
        const web3 = Util.getWeb3FromProviderUrl(providerUrl);
        return Util.isWatchingEnabled(web3);
    }
    /**
     * @TODO refactor, use this synchronous method instead of async call to contract in eac
     *
     * @param callGas
     * @param callValue
     * @param gasPrice
     * @param fee
     * @param bounty
     */
    static calcEndowment(callGas, callValue, gasPrice, fee, bounty) {
        const callGasBN = new bignumber_js_1.default(callGas);
        const callValueBN = new bignumber_js_1.default(callValue);
        const gasPriceBN = new bignumber_js_1.default(gasPrice);
        const feeBN = new bignumber_js_1.default(fee);
        const bountyBN = new bignumber_js_1.default(bounty);
        return bountyBN
            .plus(feeBN)
            .plus(callGasBN.times(gasPrice))
            .plus(gasPriceBN.times(EXECUTION_OVERHEAD))
            .plus(callValueBN);
    }
    static estimateMaximumExecutionGasPrice(bounty, gasPrice, callGas) {
        if (!gasPrice || !callGas || !bounty) {
            throw new Error('Missing arguments');
        }
        if (gasPrice.isNegative() || callGas.isNegative() || bounty.isNegative()) {
            throw new Error('gasPrice, callGas and bounty has to be positive number');
        }
        const arbitraryCoefficient = 0.85;
        const paymentModifier = 0.9;
        const claimingGasAmount = 100000;
        const claimingGasCost = gasPrice.times(claimingGasAmount);
        const executionGasAmount = callGas.plus(EXECUTION_OVERHEAD);
        return bounty
            .times(paymentModifier)
            .minus(claimingGasCost)
            .dividedBy(executionGasAmount)
            .times(arbitraryCoefficient)
            .decimalPlaces(0);
    }
    static estimateBountyForExecutionGasPrice(gasPrice, callGas, additionalGasPrice) {
        if (!gasPrice || !callGas || !additionalGasPrice) {
            throw new Error('Missing arguments');
        }
        if (gasPrice.isNegative() || callGas.isNegative() || additionalGasPrice.isNegative()) {
            throw new Error('gasPrice, callGas and additionalGasPrice has to be positive number');
        }
        const arbitraryCoefficient = 0.85;
        const paymentModifier = 0.9;
        const claimingGasAmount = 100000;
        const claimingGasCost = gasPrice.times(claimingGasAmount);
        const executionGasAmount = callGas.plus(EXECUTION_OVERHEAD);
        return additionalGasPrice
            .times(executionGasAmount)
            .plus(claimingGasCost)
            .dividedBy(paymentModifier)
            .dividedBy(arbitraryCoefficient)
            .decimalPlaces(0);
    }
    constructor(web3) {
        this.web3 = web3;
    }
    isNetworkSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            const netId = yield this.web3.eth.net.getId();
            if (Object.values(Networks).includes(netId)) {
                return true;
            }
            return false;
        });
    }
    isNotNullAddress(address) {
        return address !== Constants_1.default.NULL_ADDRESS;
    }
    checkValidAddress(address) {
        return ethUtil.isValidAddress(address);
    }
    getTransactionRequestAddressFromReceipt(receipt) {
        const foundLog = receipt.logs.find(log => log.topics[0] === Constants_1.default.NEWREQUESTLOG);
        return `0x${foundLog.data.slice(-40)}`;
    }
    sendRawTransaction(transaction) {
        return this.web3.eth.sendSignedTransaction(transaction);
    }
    getABI(name) {
        return require(`${__dirname}/../abi/${name}.json`);
    }
    /**
     * Returns the string argument of the detected network.
     *
     * @param {Web3} web3
     */
    getChainName() {
        return __awaiter(this, void 0, void 0, function* () {
            const netId = yield this.web3.eth.net.getId();
            if (netId > 1517361627) {
                return 'tester';
            }
            return NETWORK_ID_TO_NAME_MAP[netId];
        });
    }
    getRequestFactoryStartBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const netId = yield this.web3.eth.net.getId();
            return REQUEST_FACTORY_STARTBLOCKS[netId] || 0;
        });
    }
    balanceOf(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = (yield this.web3.eth.getBalance(account)).toString();
            return new bignumber_js_1.default(balance);
        });
    }
    getBlock(blockNumber = 'latest') {
        return __awaiter(this, void 0, void 0, function* () {
            if (['genesis', 'latest', 'pending'].indexOf(blockNumber.toString()) === -1 &&
                typeof blockNumber === 'string') {
                blockNumber = parseInt(blockNumber, 10);
            }
            const block = yield this.web3.eth.getBlock(blockNumber);
            if (block) {
                return block;
            }
            throw Error(`Returned block ${blockNumber} is null`);
        });
    }
    getTimestampForBlock(blockNum) {
        return __awaiter(this, void 0, void 0, function* () {
            const curBlockNum = yield this.web3.eth.getBlockNumber();
            if (blockNum > curBlockNum) {
                throw new Error(`Must pass in a blocknumber at or lower than the current blocknumber. Now: ${curBlockNum} | Tried: ${blockNum}`);
            }
            const block = yield this.web3.eth.getBlock(blockNum);
            return block.timestamp;
        });
    }
    getTransactionCount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3.eth.getTransactionCount(address);
        });
    }
    getReceipt(transactionHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3.eth.getTransactionReceipt(transactionHash);
        });
    }
    getTransaction(transactionHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3.eth.getTransaction(transactionHash);
        });
    }
    toHex(value) {
        return this.web3.utils.toHex(value);
    }
    getContractsAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const netId = yield this.web3.eth.net.getId();
            const addresses = NETWORK_TO_ADDRESSES_MAPPING[netId];
            if (!addresses) {
                throw Error(`Network with id: "${netId}" is not supported.`);
            }
            return addresses;
        });
    }
    stopFilter(filter) {
        return new Promise((resolve, reject) => {
            let unsubscriptionSuccessful = false;
            if (filter.subscription) {
                unsubscriptionSuccessful = filter.subscription.unsubscribe();
                resolve(unsubscriptionSuccessful || false);
            }
            else {
                filter.unsubscribe((error, success) => {
                    if (success) {
                        resolve(success);
                    }
                    else {
                        reject(error);
                    }
                });
            }
        });
    }
    /*
     * Takes an average of the last 100 blocks and estimates the
     * blocktime.
     */
    getAverageBlockTime() {
        return __awaiter(this, void 0, void 0, function* () {
            const numLookbackBlocks = 100;
            const times = [];
            const blockPromises = [];
            const currentBlockNumber = yield this.web3.eth.getBlockNumber();
            const firstBlock = yield this.web3.eth.getBlock(currentBlockNumber - numLookbackBlocks);
            for (let i = firstBlock.number; i < currentBlockNumber; i++) {
                blockPromises.push(this.web3.eth.getBlock(i));
            }
            const resolvedBlocks = yield Promise.all(blockPromises);
            let prevTimestamp = firstBlock.timestamp;
            resolvedBlocks.forEach((block) => {
                const time = block.timestamp - prevTimestamp;
                prevTimestamp = block.timestamp;
                times.push(time);
            });
            if (times.length === 0) {
                return 1;
            }
            return Math.round(times.reduce((a, b) => a + b) / times.length);
        });
    }
    calculateGasAmount(txRequest) {
        return txRequest.callGas
            .plus(180000)
            .div(64)
            .times(65)
            .decimalPlaces(0);
    }
    waitForConfirmations(sentTransaction, desiredConfirmations = 12) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                sentTransaction.on('confirmation', (confirmationNumber, receipt) => {
                    if (confirmationNumber >= desiredConfirmations) {
                        resolve(receipt);
                    }
                });
                sentTransaction.on('error', reject);
            });
        });
    }
}
exports.default = Util;
//# sourceMappingURL=Util.js.map