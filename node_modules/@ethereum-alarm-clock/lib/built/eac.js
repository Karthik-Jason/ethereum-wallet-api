"use strict";
// tslint:disable-next-line:no-reference
/// <reference path="./global.d.ts" />
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = require("bignumber.js");
const SchedulerInterface_1 = require("./abi/SchedulerInterface");
const Constants_1 = require("./Constants");
const RequestFactory_1 = require("./requestFactory/RequestFactory");
const TransactionRequest_1 = require("./transactionRequest/TransactionRequest");
const _1 = require(".");
var TemporalUnit;
(function (TemporalUnit) {
    TemporalUnit[TemporalUnit["BLOCK"] = 1] = "BLOCK";
    TemporalUnit[TemporalUnit["TIME"] = 2] = "TIME";
})(TemporalUnit = exports.TemporalUnit || (exports.TemporalUnit = {}));
const MINIMUM_WINDOW_SIZE_TIMESTAMP = new bignumber_js_1.default(5 * 60); // 5 minutes
exports.MINIMUM_WINDOW_SIZE_BLOCK = new bignumber_js_1.default(16); // 16 blocks
exports.CLAIM_WINDOW_SIZE_BLOCK = 255;
exports.DEFAULT_BOUNTY = new bignumber_js_1.default('10000000000000000'); // 0.01 ETH
exports.DEFAULT_GAS_PRICE = new bignumber_js_1.default('30000000000'); // 30 Gwei
exports.DEFAULT_WINDOW_SIZE_BLOCK = exports.MINIMUM_WINDOW_SIZE_BLOCK.times(2);
var SchedulingParamsError;
(function (SchedulingParamsError) {
    SchedulingParamsError[SchedulingParamsError["InsufficientEndowment"] = 0] = "InsufficientEndowment";
    SchedulingParamsError[SchedulingParamsError["ReservedWindowBiggerThanExecutionWindow"] = 1] = "ReservedWindowBiggerThanExecutionWindow";
    SchedulingParamsError[SchedulingParamsError["InvalidTemporalUnit"] = 2] = "InvalidTemporalUnit";
    SchedulingParamsError[SchedulingParamsError["ExecutionWindowTooSoon"] = 3] = "ExecutionWindowTooSoon";
    SchedulingParamsError[SchedulingParamsError["CallGasTooHigh"] = 4] = "CallGasTooHigh";
    SchedulingParamsError[SchedulingParamsError["EmptyToAddress"] = 5] = "EmptyToAddress";
})(SchedulingParamsError || (SchedulingParamsError = {}));
class EAC {
    constructor(web3, privateKey) {
        this.web3 = web3;
        this.privateKey = privateKey;
        this.util = new _1.Util(web3);
    }
    computeEndowment(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertRequiredOptionsArePresent(options);
            options = yield this.fillMissingOptions(options);
            const scheduler = yield this.getScheduler(options.timestampScheduling);
            return scheduler.methods
                .computeEndowment(options.bounty.toString(), options.fee.toString(), options.callGas.toString(), options.callValue.toString(), options.gasPrice.toString())
                .call();
        });
    }
    schedule(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertRequiredOptionsArePresent(options);
            options = yield this.fillMissingOptions(options);
            const scheduler = yield this.getScheduler(options.timestampScheduling);
            const endowment = yield this.computeEndowment(options);
            yield this.validateScheduleOptions(options, endowment);
            const scheduleTransaction = scheduler.methods.schedule(options.toAddress, this.web3.utils.hexToBytes(options.callData), [
                options.callGas.toString(),
                options.callValue.toString(),
                options.windowSize.toString(),
                options.windowStart.toString(),
                options.gasPrice.toString(),
                options.fee.toString(),
                options.bounty.toString(),
                options.requiredDeposit.toString()
            ]);
            const encodedABI = scheduleTransaction.encodeABI();
            const tx = {
                from: options.from,
                to: scheduler._address,
                data: encodedABI,
                value: endowment,
                gas: options.scheduleGas.toNumber()
            };
            let sentTx;
            if (this.privateKey) {
                const signedTx = yield this.web3.eth.accounts.signTransaction(tx, this.privateKey);
                sentTx = this.web3.eth.sendSignedTransaction(signedTx.rawTransaction);
            }
            else {
                sentTx = this.web3.eth.sendTransaction(tx);
            }
            return new Promise(resolve => {
                sentTx
                    .on('receipt', receipt => {
                    resolve(receipt);
                })
                    .on('error', error => {
                    throw error;
                });
            });
        });
    }
    getTxRequestFromReceipt(receipt) {
        const foundLog = receipt.logs.find(log => log.topics[0] === Constants_1.default.NEWREQUESTLOG);
        return '0x'.concat(foundLog.data.slice(-40));
    }
    validateScheduleOptions(options, endowment) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestFactory = yield this.requestFactory();
            const temporalUnit = options.timestampScheduling ? TemporalUnit.TIME : TemporalUnit.BLOCK;
            const freezePeriod = options.timestampScheduling ? 3 * 60 : 10; // 3 minutes or 10 blocks
            const reservedWindowSize = options.timestampScheduling ? 5 * 60 : 16; // 5 minutes or 16 blocks
            const claimWindowSize = options.timestampScheduling ? 60 * 60 : exports.CLAIM_WINDOW_SIZE_BLOCK; // 60 minutes or 255 blocks
            const addressArgs = [
                options.from,
                '0x0000000000000000000000000000000000000000',
                options.toAddress
            ];
            const uintArgs = [
                options.fee.toString(),
                options.bounty.toString(),
                claimWindowSize,
                freezePeriod,
                reservedWindowSize,
                temporalUnit,
                options.windowSize.toString(),
                options.windowStart.toString(),
                options.callGas.toString(),
                options.callValue.toString(),
                options.gasPrice.toString(),
                options.requiredDeposit.toString()
            ];
            const paramsValidity = yield requestFactory.instance.methods
                .validateRequestParams(addressArgs, uintArgs, endowment)
                .call();
            const errors = this.parseSchedulingParametersValidity(paramsValidity);
            if (errors.length > 0) {
                let errorMessage = 'Schedule params validation errors: ';
                errors.forEach((error, index) => {
                    errorMessage += `\n\r${index + 1}. ${SchedulingParamsError[error.toString()]}`;
                });
                throw Error(errorMessage);
            }
        });
    }
    requestFactory() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.util.getContractsAddresses();
            return new RequestFactory_1.default(addresses.requestFactory, this.web3);
        });
    }
    transactionRequest(address) {
        return new TransactionRequest_1.default(address, this.web3);
    }
    transactionRequestFromReceipt(receipt) {
        const address = this.util.getTransactionRequestAddressFromReceipt(receipt);
        return this.transactionRequest(address);
    }
    parseSchedulingParametersValidity(paramsValidity) {
        const errorsIndexMapping = [
            SchedulingParamsError.InsufficientEndowment,
            SchedulingParamsError.ReservedWindowBiggerThanExecutionWindow,
            SchedulingParamsError.InvalidTemporalUnit,
            SchedulingParamsError.ExecutionWindowTooSoon,
            SchedulingParamsError.CallGasTooHigh,
            SchedulingParamsError.EmptyToAddress
        ];
        const errors = [];
        paramsValidity.forEach((boolIsTrue, index) => {
            if (!boolIsTrue) {
                errors.push(errorsIndexMapping[index]);
            }
        });
        return errors;
    }
    getScheduler(timestamp = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.util.getContractsAddresses();
            const address = timestamp ? addresses.timestampScheduler : addresses.blockScheduler;
            return new this.web3.eth.Contract(SchedulerInterface_1.default, address);
        });
    }
    assertRequiredOptionsArePresent(options) {
        if (!options.toAddress) {
            throw new Error('toAddress in SchedulingOptions needs to be present.');
        }
        if (!options.windowStart) {
            throw new Error('windowStart in SchedulingOptions needs to be present.');
        }
    }
    fillMissingOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof options.timestampScheduling === 'undefined') {
                options.timestampScheduling = true;
            }
            if (typeof options.bounty === 'undefined') {
                options.bounty = exports.DEFAULT_BOUNTY;
            }
            if (typeof options.from === 'undefined') {
                const accounts = yield this.web3.eth.getAccounts();
                options.from = accounts[0];
            }
            if (typeof options.callData === 'undefined') {
                options.callData = '0x0';
            }
            if (typeof options.callGas === 'undefined') {
                options.callGas = new bignumber_js_1.default('21000');
            }
            if (typeof options.callValue === 'undefined') {
                options.callValue = new bignumber_js_1.default('0');
            }
            if (typeof options.windowSize === 'undefined') {
                options.windowSize = (options.timestampScheduling
                    ? MINIMUM_WINDOW_SIZE_TIMESTAMP
                    : exports.MINIMUM_WINDOW_SIZE_BLOCK).times(2);
            }
            if (typeof options.gasPrice === 'undefined') {
                options.gasPrice = exports.DEFAULT_GAS_PRICE;
            }
            if (typeof options.fee === 'undefined') {
                options.fee = new bignumber_js_1.default('0');
            }
            if (typeof options.requiredDeposit === 'undefined') {
                options.requiredDeposit = new bignumber_js_1.default('0');
            }
            if (typeof options.scheduleGas === 'undefined') {
                options.scheduleGas = new bignumber_js_1.default(600000);
            }
            return options;
        });
    }
}
exports.default = EAC;
//# sourceMappingURL=eac.js.map