"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const RequestFactoryABI_1 = require("../abi/RequestFactoryABI");
const eac_1 = require("../eac");
const Constants_1 = require("../Constants");
class RequestFactory {
    constructor(address, web3) {
        this.util = new __1.Util(web3);
        if (!this.util.isNotNullAddress(address)) {
            throw new Error('Attempted to instantiate a RequestFactory class from a null address.');
        }
        this.web3 = web3;
        this.instance = new this.web3.eth.Contract(RequestFactoryABI_1.default, address);
    }
    get address() {
        return this.instance.options.address;
    }
    isKnownRequest(requestAddress) {
        return this.instance.methods.isKnownRequest(requestAddress).call();
    }
    watchRequestCreatedLogs(filter = {}, fromBlock = 1, callback) {
        const options = { filter, fromBlock };
        return this.instance.events.RequestCreated(options, callback);
    }
    stopWatch(event) {
        return __awaiter(this, void 0, void 0, function* () {
            event.removeAllListeners();
        });
    }
    watchRequestsByBucket(bucket, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const startBlock = (yield this.util.getRequestFactoryStartBlock());
            return this.watchRequestCreatedLogs({
                bucket
            }, startBlock, 
            // tslint:disable
            (_error, log) => {
                //tslint:enable
                if (log) {
                    callback({
                        address: log.returnValues.request,
                        params: log.returnValues.params
                    });
                }
            });
        });
    }
    // Assume the temporalUnit is blocks if not timestamp.
    calcBucket(windowStart, temporalUnit) {
        let bucketSize = Constants_1.default.BUCKET_SIZE.block;
        let sign = -1; // block sign
        if (temporalUnit === eac_1.TemporalUnit.TIME) {
            bucketSize = Constants_1.default.BUCKET_SIZE.timestamp;
            sign = 1; // timestamp sign
        }
        return sign * (windowStart - (windowStart % bucketSize));
    }
    getRequestCreatedEvents(filter = {}, fromBlock = 'genesis', toBlock = 'latest', topics = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const events = yield this.instance.getPastEvents('RequestCreated', {
                filter,
                fromBlock,
                toBlock,
                topics
            });
            console.log(events);
            return events;
        });
    }
    getRequestsByOwner(owner, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            startBlock = startBlock || (yield this.util.getRequestFactoryStartBlock());
            endBlock = endBlock || 'latest';
            const events = yield this.getRequestCreatedEvents({ owner }, startBlock, endBlock);
            return events.map(event => event.address);
        });
    }
}
exports.default = RequestFactory;
//# sourceMappingURL=RequestFactory.js.map