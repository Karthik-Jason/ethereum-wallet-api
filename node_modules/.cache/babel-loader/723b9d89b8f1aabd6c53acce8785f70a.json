{"remainingRequest":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/partners/changelly/changelly.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/partners/changelly/changelly.js","mtime":1573477612092},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport BigNumber from 'bignumber.js';\nimport { networkSymbols } from \"../partnersConfig\";\nimport { Toast } from '@/helpers';\nimport { notificationStatuses, ChangellyCurrencies, statuses, TIME_SWAP_VALID, PROVIDER_NAME } from \"./config\";\nimport changellyCalls from \"./changelly-calls\";\nimport changellyApi from \"./changelly-api\";\nimport debug from 'debug';\nvar errorLogger = debug('v5:partners-changelly');\n\nvar Changelly =\n/*#__PURE__*/\nfunction () {\n  function Changelly() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Changelly);\n\n    this.name = Changelly.getName();\n    this.network = props.network || networkSymbols.ETH;\n    this.getRateForUnit = typeof props.getRateForUnit === 'boolean' ? props.getRateForUnit : false;\n    this.hasRates = 0;\n    this.currencyDetails = props.currencies || ChangellyCurrencies;\n    this.useFixed = true;\n    this.tokenDetails = {};\n    this.getSupportedCurrencies(this.network);\n  }\n\n  _createClass(Changelly, [{\n    key: \"getApiConnector\",\n    value: function getApiConnector(type) {\n      if (type === 'api') {\n        return changellyApi;\n      }\n\n      return changellyCalls;\n    }\n  }, {\n    key: \"getSupportedCurrencies\",\n    value: function () {\n      var _getSupportedCurrencies = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var _ref, currencyDetails, tokenDetails;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return changellyApi.getSupportedCurrencies(this.network);\n\n              case 3:\n                _ref = _context.sent;\n                currencyDetails = _ref.currencyDetails;\n                tokenDetails = _ref.tokenDetails;\n                this.currencyDetails = currencyDetails;\n                this.tokenDetails = tokenDetails;\n                this.hasRates = Object.keys(this.tokenDetails).length > 0 ? this.hasRates + 1 : 0;\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n                errorLogger(_context.t0);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 11]]);\n      }));\n\n      function getSupportedCurrencies() {\n        return _getSupportedCurrencies.apply(this, arguments);\n      }\n\n      return getSupportedCurrencies;\n    }()\n  }, {\n    key: \"setNetwork\",\n    value: function setNetwork(network) {\n      this.network = network;\n    }\n  }, {\n    key: \"validSwap\",\n    value: function validSwap(fromCurrency, toCurrency) {\n      if (this.isValidNetwork) {\n        return this.currencies[fromCurrency] && this.currencies[toCurrency];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"fixedEnabled\",\n    value: function fixedEnabled(currency) {\n      return typeof this.currencies[currency].fixRateEnabled === 'boolean' && this.currencies[currency].fixRateEnabled;\n    }\n  }, {\n    key: \"getRate\",\n    value: function () {\n      var _getRate = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(fromCurrency, toCurrency, fromValue) {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.useFixed && this.currencies[toCurrency])) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                if (!(this.fixedEnabled(toCurrency) && this.fixedEnabled(fromCurrency))) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.getFixedRate(fromCurrency, toCurrency, fromValue));\n\n              case 3:\n                return _context2.abrupt(\"return\", this.getMarketRate(fromCurrency, toCurrency, fromValue));\n\n              case 4:\n                return _context2.abrupt(\"return\", this.getMarketRate(fromCurrency, toCurrency, fromValue));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getRate(_x, _x2, _x3) {\n        return _getRate.apply(this, arguments);\n      }\n\n      return getRate;\n    }()\n  }, {\n    key: \"getRateUpdate\",\n    value: function () {\n      var _getRateUpdate = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(fromCurrency, toCurrency, fromValue, toValue, isFiat) {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.getRate(fromCurrency, toCurrency, fromValue, toValue, isFiat));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getRateUpdate(_x4, _x5, _x6, _x7, _x8) {\n        return _getRateUpdate.apply(this, arguments);\n      }\n\n      return getRateUpdate;\n    }()\n  }, {\n    key: \"getFixedRate\",\n    value: function getFixedRate(fromCurrency, toCurrency, fromValue) {\n      var _this = this;\n\n      return new Promise(\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee4(resolve) {\n          var timeout, changellyDetails;\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  timeout = setTimeout(function () {\n                    resolve({\n                      fromCurrency: fromCurrency,\n                      toCurrency: toCurrency,\n                      provider: _this.name,\n                      rate: 0\n                    });\n                  }, 20000);\n                  _context4.next = 3;\n                  return changellyCalls.getFixRate(fromCurrency, toCurrency, fromValue, _this.network);\n\n                case 3:\n                  changellyDetails = _context4.sent;\n                  clearTimeout(timeout);\n\n                  if (Array.isArray(changellyDetails)) {\n                    _context4.next = 7;\n                    break;\n                  }\n\n                  return _context4.abrupt(\"return\", {\n                    fromCurrency: fromCurrency,\n                    toCurrency: toCurrency,\n                    provider: _this.name,\n                    rate: 0\n                  });\n\n                case 7:\n                  resolve({\n                    fromCurrency: fromCurrency,\n                    toCurrency: toCurrency,\n                    provider: _this.name,\n                    minValue: changellyDetails[0].min,\n                    maxValue: changellyDetails[0].max,\n                    rate: changellyDetails[0].result,\n                    rateId: changellyDetails[0].id\n                  });\n\n                case 8:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        return function (_x9) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"calculateRate\",\n    value: function calculateRate(inVal, outVal) {\n      return new BigNumber(outVal).div(inVal);\n    }\n  }, {\n    key: \"getMarketRate\",\n    value: function () {\n      var _getMarketRate = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5(fromCurrency, toCurrency, fromValue) {\n        var changellyDetails, minAmount, estValueResponse;\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return Promise.all([changellyCalls.getMin(fromCurrency, toCurrency, fromValue, this.network), changellyCalls.getRate(fromCurrency, toCurrency, fromValue, this.network)]);\n\n              case 3:\n                changellyDetails = _context5.sent;\n                minAmount = new BigNumber(changellyDetails[0]).times(0.001).plus(new BigNumber(changellyDetails[0])).toFixed();\n                estValueResponse = changellyDetails[1][0];\n                return _context5.abrupt(\"return\", {\n                  fromCurrency: fromCurrency,\n                  toCurrency: toCurrency,\n                  provider: this.name,\n                  minValue: minAmount,\n                  rate: estValueResponse.rate\n                });\n\n              case 9:\n                _context5.prev = 9;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  fromCurrency: fromCurrency,\n                  toCurrency: toCurrency,\n                  provider: this.name,\n                  rate: 0\n                });\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 9]]);\n      }));\n\n      function getMarketRate(_x10, _x11, _x12) {\n        return _getMarketRate.apply(this, arguments);\n      }\n\n      return getMarketRate;\n    }()\n  }, {\n    key: \"getInitialCurrencyEntries\",\n    value: function getInitialCurrencyEntries(collectMapFrom, collectMapTo) {\n      for (var prop in this.currencies) {\n        if (this.currencies[prop]) collectMapTo.set(prop, {\n          symbol: prop,\n          name: this.currencies[prop].name\n        });\n        collectMapFrom.set(prop, {\n          symbol: prop,\n          name: this.currencies[prop].name\n        });\n      }\n    }\n  }, {\n    key: \"getUpdatedFromCurrencyEntries\",\n    value: function getUpdatedFromCurrencyEntries(value, collectMap) {\n      if (this.currencies[value.symbol]) {\n        for (var prop in this.currencies) {\n          if (this.currencies[prop]) collectMap.set(prop, {\n            symbol: prop,\n            name: this.currencies[prop].name\n          });\n        }\n      }\n    }\n  }, {\n    key: \"getUpdatedToCurrencyEntries\",\n    value: function getUpdatedToCurrencyEntries(value, collectMap) {\n      if (this.currencies[value.symbol]) {\n        for (var prop in this.currencies) {\n          if (this.currencies[prop]) collectMap.set(prop, {\n            symbol: prop,\n            name: this.currencies[prop].name\n          });\n        }\n      }\n    }\n  }, {\n    key: \"startSwap\",\n    value: function () {\n      var _startSwap = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee6(swapDetails) {\n        var details;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(+swapDetails.minValue <= +swapDetails.fromValue)) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.createTransaction(swapDetails);\n\n              case 3:\n                details = _context6.sent;\n\n                if (details) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw Error('abort');\n\n              case 6:\n                if (!details.message) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                throw Error(details.message);\n\n              case 8:\n                swapDetails.providerReceives = details.amountExpectedFrom;\n                swapDetails.providerSends = details.amountExpectedTo;\n                swapDetails.parsed = Changelly.parseOrder(details);\n                swapDetails.providerSends = swapDetails.parsed.recValue;\n                swapDetails.orderId = swapDetails.parsed.orderId;\n                swapDetails.providerAddress = details.payinAddress;\n                swapDetails.dataForInitialization = details;\n                swapDetails.isDex = Changelly.isDex();\n                swapDetails.validFor = swapDetails.parsed.validFor;\n                return _context6.abrupt(\"return\", swapDetails);\n\n              case 18:\n                return _context6.abrupt(\"return\", Error('From amount below changelly minimum for currency pair'));\n\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function startSwap(_x13) {\n        return _startSwap.apply(this, arguments);\n      }\n\n      return startSwap;\n    }()\n  }, {\n    key: \"createTransaction\",\n    value: function () {\n      var _createTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee7(_ref3) {\n        var fromCurrency, toCurrency, toAddress, fromAddress, fromValue, refundAddress, transactionDetails;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                fromCurrency = _ref3.fromCurrency, toCurrency = _ref3.toCurrency, toAddress = _ref3.toAddress, fromAddress = _ref3.fromAddress, fromValue = _ref3.fromValue, refundAddress = _ref3.refundAddress;\n                transactionDetails = {\n                  fromCurrency: fromCurrency,\n                  toCurrency: toCurrency,\n                  toAddress: toAddress,\n                  fromAddress: fromAddress,\n                  fromValue: fromValue,\n                  refundAddress: refundAddress\n                };\n\n                if (!(this.useFixed && this.currencies[toCurrency])) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                if (!(this.fixedEnabled(toCurrency) && this.fixedEnabled(fromCurrency))) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this.createFixedTransaction(transactionDetails));\n\n              case 5:\n                return _context7.abrupt(\"return\", this.createMarketTransaction(transactionDetails));\n\n              case 6:\n                return _context7.abrupt(\"return\", this.createMarketTransaction(transactionDetails));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function createTransaction(_x14) {\n        return _createTransaction.apply(this, arguments);\n      }\n\n      return createTransaction;\n    }()\n  }, {\n    key: \"createFixedTransaction\",\n    value: function () {\n      var _createFixedTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee8(_ref4) {\n        var fromCurrency, toCurrency, toAddress, fromAddress, fromValue, refundAddress, finalDetails, swapParams;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                fromCurrency = _ref4.fromCurrency, toCurrency = _ref4.toCurrency, toAddress = _ref4.toAddress, fromAddress = _ref4.fromAddress, fromValue = _ref4.fromValue, refundAddress = _ref4.refundAddress;\n                _context8.next = 3;\n                return this.getFixedRate(fromCurrency, toCurrency, fromValue);\n\n              case 3:\n                finalDetails = _context8.sent;\n                swapParams = {\n                  from: fromCurrency.toLowerCase(),\n                  to: toCurrency.toLowerCase(),\n                  address: toAddress,\n                  extraId: null,\n                  amount: fromValue,\n                  refundAddress: refundAddress === '' ? fromAddress : refundAddress,\n                  refundExtraId: null,\n                  rateId: finalDetails.rateId\n                };\n                _context8.next = 7;\n                return changellyCalls.createFixTransaction(swapParams, this.network);\n\n              case 7:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function createFixedTransaction(_x15) {\n        return _createFixedTransaction.apply(this, arguments);\n      }\n\n      return createFixedTransaction;\n    }()\n  }, {\n    key: \"createMarketTransaction\",\n    value: function () {\n      var _createMarketTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee9(_ref5) {\n        var fromCurrency, toCurrency, toAddress, fromAddress, fromValue, refundAddress, swapParams;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                fromCurrency = _ref5.fromCurrency, toCurrency = _ref5.toCurrency, toAddress = _ref5.toAddress, fromAddress = _ref5.fromAddress, fromValue = _ref5.fromValue, refundAddress = _ref5.refundAddress;\n                swapParams = {\n                  from: fromCurrency.toLowerCase(),\n                  to: toCurrency.toLowerCase(),\n                  address: toAddress,\n                  extraId: null,\n                  amount: fromValue,\n                  refundAddress: refundAddress === '' ? fromAddress : refundAddress,\n                  refundExtraId: null\n                };\n                _context9.next = 4;\n                return changellyCalls.createTransaction(swapParams, this.network);\n\n              case 4:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function createMarketTransaction(_x16) {\n        return _createMarketTransaction.apply(this, arguments);\n      }\n\n      return createMarketTransaction;\n    }()\n  }, {\n    key: \"validateAddress\",\n    value: function () {\n      var _validateAddress = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee10(toCurrency, address) {\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return changellyCalls.validateAddress({\n                  currency: toCurrency,\n                  address: address\n                }, this.network);\n\n              case 2:\n                return _context10.abrupt(\"return\", _context10.sent);\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function validateAddress(_x17, _x18) {\n        return _validateAddress.apply(this, arguments);\n      }\n\n      return validateAddress;\n    }()\n  }, {\n    key: \"ratesRetrieved\",\n    get: function get() {\n      return Object.keys(this.tokenDetails).length > 0 && this.hasRates > 0;\n    }\n  }, {\n    key: \"isValidNetwork\",\n    get: function get() {\n      return this.network === networkSymbols.ETH;\n    }\n  }, {\n    key: \"currencies\",\n    get: function get() {\n      if (this.isValidNetwork) {\n        return this.currencyDetails;\n      }\n\n      return {};\n    }\n  }], [{\n    key: \"getName\",\n    value: function getName() {\n      return PROVIDER_NAME;\n    }\n  }, {\n    key: \"isDex\",\n    value: function isDex() {\n      return false;\n    }\n  }, {\n    key: \"parseOrder\",\n    value: function parseOrder(order) {\n      return {\n        orderId: order.id,\n        statusId: order.id,\n        sendToAddress: order.payinAddress,\n        recValue: order.amountExpectedTo,\n        sendValue: order.amountExpectedFrom,\n        status: order.status,\n        timestamp: order.createdAt,\n        validFor: TIME_SWAP_VALID // Rates provided are only an estimate\n\n      };\n    }\n  }, {\n    key: \"getOrderStatus\",\n    value: function () {\n      var _getOrderStatus = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee11(noticeDetails, network) {\n        var status;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                _context11.next = 3;\n                return changellyCalls.getStatus(noticeDetails.statusId, network);\n\n              case 3:\n                status = _context11.sent;\n                return _context11.abrupt(\"return\", Changelly.parseChangellyStatus(status));\n\n              case 7:\n                _context11.prev = 7;\n                _context11.t0 = _context11[\"catch\"](0);\n                Toast.responseHandler(_context11.t0, false);\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, null, [[0, 7]]);\n      }));\n\n      function getOrderStatus(_x19, _x20) {\n        return _getOrderStatus.apply(this, arguments);\n      }\n\n      return getOrderStatus;\n    }()\n  }, {\n    key: \"parseChangellyStatus\",\n    value: function parseChangellyStatus(status) {\n      switch (status) {\n        case statuses.new:\n          return notificationStatuses.NEW;\n\n        case statuses.waiting:\n          return notificationStatuses.SENT;\n\n        case statuses.confirming:\n        case statuses.exchanging:\n        case statuses.sending:\n        case statuses.hold:\n          return notificationStatuses.PENDING;\n\n        case statuses.finished:\n          return notificationStatuses.COMPLETE;\n\n        case statuses.failed:\n          return notificationStatuses.FAILED;\n\n        case statuses.overdue:\n        case statuses.refunded:\n          return notificationStatuses.CANCELLED;\n      }\n    }\n  }]);\n\n  return Changelly;\n}();\n\nexport { Changelly as default };",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/partners/changelly/changelly.js"],"names":["BigNumber","networkSymbols","Toast","notificationStatuses","ChangellyCurrencies","statuses","TIME_SWAP_VALID","PROVIDER_NAME","changellyCalls","changellyApi","debug","errorLogger","Changelly","props","name","getName","network","ETH","getRateForUnit","hasRates","currencyDetails","currencies","useFixed","tokenDetails","getSupportedCurrencies","type","Object","keys","length","fromCurrency","toCurrency","isValidNetwork","currency","fixRateEnabled","fromValue","fixedEnabled","getFixedRate","getMarketRate","toValue","isFiat","getRate","Promise","resolve","timeout","setTimeout","provider","rate","getFixRate","changellyDetails","clearTimeout","Array","isArray","minValue","min","maxValue","max","result","rateId","id","inVal","outVal","div","all","getMin","minAmount","times","plus","toFixed","estValueResponse","collectMapFrom","collectMapTo","prop","set","symbol","value","collectMap","swapDetails","createTransaction","details","Error","message","providerReceives","amountExpectedFrom","providerSends","amountExpectedTo","parsed","parseOrder","recValue","orderId","providerAddress","payinAddress","dataForInitialization","isDex","validFor","toAddress","fromAddress","refundAddress","transactionDetails","createFixedTransaction","createMarketTransaction","finalDetails","swapParams","from","toLowerCase","to","address","extraId","amount","refundExtraId","createFixTransaction","validateAddress","order","statusId","sendToAddress","sendValue","status","timestamp","createdAt","noticeDetails","getStatus","parseChangellyStatus","responseHandler","new","NEW","waiting","SENT","confirming","exchanging","sending","hold","PENDING","finished","COMPLETE","failed","FAILED","overdue","refunded","CANCELLED"],"mappings":";;;;;;;;AAAA,OAAOA,SAAP,MAAsB,cAAtB;AAEA,SAASC,cAAT;AACA,SAASC,KAAT,QAAsB,WAAtB;AAEA,SACEC,oBADF,EAEEC,mBAFF,EAGEC,QAHF,EAIEC,eAJF,EAKEC,aALF;AAOA,OAAOC,cAAP;AACA,OAAOC,YAAP;AAEA,OAAOC,KAAP,MAAkB,OAAlB;AAEA,IAAMC,WAAW,GAAGD,KAAK,CAAC,uBAAD,CAAzB;;IAEqBE,S;;;AACnB,uBAAwB;AAAA,QAAZC,KAAY,uEAAJ,EAAI;;AAAA;;AACtB,SAAKC,IAAL,GAAYF,SAAS,CAACG,OAAV,EAAZ;AACA,SAAKC,OAAL,GAAeH,KAAK,CAACG,OAAN,IAAiBf,cAAc,CAACgB,GAA/C;AACA,SAAKC,cAAL,GACE,OAAOL,KAAK,CAACK,cAAb,KAAgC,SAAhC,GAA4CL,KAAK,CAACK,cAAlD,GAAmE,KADrE;AAEA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,eAAL,GAAuBP,KAAK,CAACQ,UAAN,IAAoBjB,mBAA3C;AACA,SAAKkB,QAAL,GAAgB,IAAhB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,sBAAL,CAA4B,KAAKR,OAAjC;AACD;;;;oCAMeS,I,EAAM;AACpB,UAAIA,IAAI,KAAK,KAAb,EAAoB;AAClB,eAAOhB,YAAP;AACD;;AACD,aAAOD,cAAP;AACD;;;;;;;;;;;;;;;uBAWaC,YAAY,CAACe,sBAAb,CAAoC,KAAKR,OAAzC,C;;;;AAFRI,gBAAAA,e,QAAAA,e;AACAG,gBAAAA,Y,QAAAA,Y;AAEF,qBAAKH,eAAL,GAAuBA,eAAvB;AACA,qBAAKG,YAAL,GAAoBA,YAApB;AACA,qBAAKJ,QAAL,GACEO,MAAM,CAACC,IAAP,CAAY,KAAKJ,YAAjB,EAA+BK,MAA/B,GAAwC,CAAxC,GAA4C,KAAKT,QAAL,GAAgB,CAA5D,GAAgE,CADlE;;;;;;;AAGAR,gBAAAA,WAAW,aAAX;;;;;;;;;;;;;;;;;;+BAYOK,O,EAAS;AAClB,WAAKA,OAAL,GAAeA,OAAf;AACD;;;8BASSa,Y,EAAcC,U,EAAY;AAClC,UAAI,KAAKC,cAAT,EAAyB;AACvB,eAAO,KAAKV,UAAL,CAAgBQ,YAAhB,KAAiC,KAAKR,UAAL,CAAgBS,UAAhB,CAAxC;AACD;;AACD,aAAO,KAAP;AACD;;;iCAEYE,Q,EAAU;AACrB,aACE,OAAO,KAAKX,UAAL,CAAgBW,QAAhB,EAA0BC,cAAjC,KAAoD,SAApD,IACA,KAAKZ,UAAL,CAAgBW,QAAhB,EAA0BC,cAF5B;AAID;;;;;;gDAEaJ,Y,EAAcC,U,EAAYI,S;;;;;sBAClC,KAAKZ,QAAL,IAAiB,KAAKD,UAAL,CAAgBS,UAAhB,C;;;;;sBACf,KAAKK,YAAL,CAAkBL,UAAlB,KAAiC,KAAKK,YAAL,CAAkBN,YAAlB,C;;;;;kDAC5B,KAAKO,YAAL,CAAkBP,YAAlB,EAAgCC,UAAhC,EAA4CI,SAA5C,C;;;kDAEF,KAAKG,aAAL,CAAmBR,YAAnB,EAAiCC,UAAjC,EAA6CI,SAA7C,C;;;kDAEF,KAAKG,aAAL,CAAmBR,YAAnB,EAAiCC,UAAjC,EAA6CI,SAA7C,C;;;;;;;;;;;;;;;;;;;;;gDAGWL,Y,EAAcC,U,EAAYI,S,EAAWI,O,EAASC,M;;;;;kDACzD,KAAKC,OAAL,CAAaX,YAAb,EAA2BC,UAA3B,EAAuCI,SAAvC,EAAkDI,OAAlD,EAA2DC,MAA3D,C;;;;;;;;;;;;;;;;;;iCAGIV,Y,EAAcC,U,EAAYI,S,EAAW;AAAA;;AAChD,aAAO,IAAIO,OAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAY,kBAAMC,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACXC,kBAAAA,OADW,GACDC,UAAU,CAAC,YAAM;AAC/BF,oBAAAA,OAAO,CAAC;AACNb,sBAAAA,YAAY,EAAZA,YADM;AAENC,sBAAAA,UAAU,EAAVA,UAFM;AAGNe,sBAAAA,QAAQ,EAAE,KAAI,CAAC/B,IAHT;AAINgC,sBAAAA,IAAI,EAAE;AAJA,qBAAD,CAAP;AAMD,mBAPyB,EAOvB,KAPuB,CADT;AAAA;AAAA,yBAUctC,cAAc,CAACuC,UAAf,CAC7BlB,YAD6B,EAE7BC,UAF6B,EAG7BI,SAH6B,EAI7B,KAAI,CAAClB,OAJwB,CAVd;;AAAA;AAUXgC,kBAAAA,gBAVW;AAgBjBC,kBAAAA,YAAY,CAACN,OAAD,CAAZ;;AAhBiB,sBAkBZO,KAAK,CAACC,OAAN,CAAcH,gBAAd,CAlBY;AAAA;AAAA;AAAA;;AAAA,oDAmBR;AACLnB,oBAAAA,YAAY,EAAZA,YADK;AAELC,oBAAAA,UAAU,EAAVA,UAFK;AAGLe,oBAAAA,QAAQ,EAAE,KAAI,CAAC/B,IAHV;AAILgC,oBAAAA,IAAI,EAAE;AAJD,mBAnBQ;;AAAA;AA2BjBJ,kBAAAA,OAAO,CAAC;AACNb,oBAAAA,YAAY,EAAZA,YADM;AAENC,oBAAAA,UAAU,EAAVA,UAFM;AAGNe,oBAAAA,QAAQ,EAAE,KAAI,CAAC/B,IAHT;AAINsC,oBAAAA,QAAQ,EAAEJ,gBAAgB,CAAC,CAAD,CAAhB,CAAoBK,GAJxB;AAKNC,oBAAAA,QAAQ,EAAEN,gBAAgB,CAAC,CAAD,CAAhB,CAAoBO,GALxB;AAMNT,oBAAAA,IAAI,EAAEE,gBAAgB,CAAC,CAAD,CAAhB,CAAoBQ,MANpB;AAONC,oBAAAA,MAAM,EAAET,gBAAgB,CAAC,CAAD,CAAhB,CAAoBU;AAPtB,mBAAD,CAAP;;AA3BiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAZ;;AAAA;AAAA;AAAA;AAAA,UAAP;AAqCD;;;kCAEaC,K,EAAOC,M,EAAQ;AAC3B,aAAO,IAAI5D,SAAJ,CAAc4D,MAAd,EAAsBC,GAAtB,CAA0BF,KAA1B,CAAP;AACD;;;;;;gDAEmB9B,Y,EAAcC,U,EAAYI,S;;;;;;;;uBAEXO,OAAO,CAACqB,GAAR,CAAY,CACzCtD,cAAc,CAACuD,MAAf,CACElC,YADF,EAEEC,UAFF,EAGEI,SAHF,EAIE,KAAKlB,OAJP,CADyC,EAOzCR,cAAc,CAACgC,OAAf,CACEX,YADF,EAEEC,UAFF,EAGEI,SAHF,EAIE,KAAKlB,OAJP,CAPyC,CAAZ,C;;;AAAzBgC,gBAAAA,gB;AAeAgB,gBAAAA,S,GAAY,IAAIhE,SAAJ,CAAcgD,gBAAgB,CAAC,CAAD,CAA9B,EACfiB,KADe,CACT,KADS,EAEfC,IAFe,CAEV,IAAIlE,SAAJ,CAAcgD,gBAAgB,CAAC,CAAD,CAA9B,CAFU,EAGfmB,OAHe,E;AAKZC,gBAAAA,gB,GAAmBpB,gBAAgB,CAAC,CAAD,CAAhB,CAAoB,CAApB,C;kDAElB;AACLnB,kBAAAA,YAAY,EAAZA,YADK;AAELC,kBAAAA,UAAU,EAAVA,UAFK;AAGLe,kBAAAA,QAAQ,EAAE,KAAK/B,IAHV;AAILsC,kBAAAA,QAAQ,EAAEY,SAJL;AAKLlB,kBAAAA,IAAI,EAAEsB,gBAAgB,CAACtB;AALlB,iB;;;;;kDAQA;AACLjB,kBAAAA,YAAY,EAAZA,YADK;AAELC,kBAAAA,UAAU,EAAVA,UAFK;AAGLe,kBAAAA,QAAQ,EAAE,KAAK/B,IAHV;AAILgC,kBAAAA,IAAI,EAAE;AAJD,iB;;;;;;;;;;;;;;;;;;8CASeuB,c,EAAgBC,Y,EAAc;AACtD,WAAK,IAAMC,IAAX,IAAmB,KAAKlD,UAAxB,EAAoC;AAClC,YAAI,KAAKA,UAAL,CAAgBkD,IAAhB,CAAJ,EACED,YAAY,CAACE,GAAb,CAAiBD,IAAjB,EAAuB;AACrBE,UAAAA,MAAM,EAAEF,IADa;AAErBzD,UAAAA,IAAI,EAAE,KAAKO,UAAL,CAAgBkD,IAAhB,EAAsBzD;AAFP,SAAvB;AAIFuD,QAAAA,cAAc,CAACG,GAAf,CAAmBD,IAAnB,EAAyB;AACvBE,UAAAA,MAAM,EAAEF,IADe;AAEvBzD,UAAAA,IAAI,EAAE,KAAKO,UAAL,CAAgBkD,IAAhB,EAAsBzD;AAFL,SAAzB;AAID;AACF;;;kDAE6B4D,K,EAAOC,U,EAAY;AAC/C,UAAI,KAAKtD,UAAL,CAAgBqD,KAAK,CAACD,MAAtB,CAAJ,EAAmC;AACjC,aAAK,IAAMF,IAAX,IAAmB,KAAKlD,UAAxB,EAAoC;AAClC,cAAI,KAAKA,UAAL,CAAgBkD,IAAhB,CAAJ,EACEI,UAAU,CAACH,GAAX,CAAeD,IAAf,EAAqB;AACnBE,YAAAA,MAAM,EAAEF,IADW;AAEnBzD,YAAAA,IAAI,EAAE,KAAKO,UAAL,CAAgBkD,IAAhB,EAAsBzD;AAFT,WAArB;AAIH;AACF;AACF;;;gDAE2B4D,K,EAAOC,U,EAAY;AAC7C,UAAI,KAAKtD,UAAL,CAAgBqD,KAAK,CAACD,MAAtB,CAAJ,EAAmC;AACjC,aAAK,IAAMF,IAAX,IAAmB,KAAKlD,UAAxB,EAAoC;AAClC,cAAI,KAAKA,UAAL,CAAgBkD,IAAhB,CAAJ,EACEI,UAAU,CAACH,GAAX,CAAeD,IAAf,EAAqB;AACnBE,YAAAA,MAAM,EAAEF,IADW;AAEnBzD,YAAAA,IAAI,EAAE,KAAKO,UAAL,CAAgBkD,IAAhB,EAAsBzD;AAFT,WAArB;AAIH;AACF;AACF;;;;;;gDAEe8D,W;;;;;;sBAEV,CAACA,WAAW,CAACxB,QAAb,IAAyB,CAACwB,WAAW,CAAC1C,S;;;;;;uBACxB,KAAK2C,iBAAL,CAAuBD,WAAvB,C;;;AAAhBE,gBAAAA,O;;oBACKA,O;;;;;sBAAeC,KAAK,CAAC,OAAD,C;;;qBACrBD,OAAO,CAACE,O;;;;;sBAAeD,KAAK,CAACD,OAAO,CAACE,OAAT,C;;;AAChCJ,gBAAAA,WAAW,CAACK,gBAAZ,GAA+BH,OAAO,CAACI,kBAAvC;AACAN,gBAAAA,WAAW,CAACO,aAAZ,GAA4BL,OAAO,CAACM,gBAApC;AACAR,gBAAAA,WAAW,CAACS,MAAZ,GAAqBzE,SAAS,CAAC0E,UAAV,CAAqBR,OAArB,CAArB;AACAF,gBAAAA,WAAW,CAACO,aAAZ,GAA4BP,WAAW,CAACS,MAAZ,CAAmBE,QAA/C;AACAX,gBAAAA,WAAW,CAACY,OAAZ,GAAsBZ,WAAW,CAACS,MAAZ,CAAmBG,OAAzC;AACAZ,gBAAAA,WAAW,CAACa,eAAZ,GAA8BX,OAAO,CAACY,YAAtC;AACAd,gBAAAA,WAAW,CAACe,qBAAZ,GAAoCb,OAApC;AACAF,gBAAAA,WAAW,CAACgB,KAAZ,GAAoBhF,SAAS,CAACgF,KAAV,EAApB;AACAhB,gBAAAA,WAAW,CAACiB,QAAZ,GAAuBjB,WAAW,CAACS,MAAZ,CAAmBQ,QAA1C;kDACOjB,W;;;kDAEFG,KAAK,CAAC,uDAAD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIZlD,gBAAAA,Y,SAAAA,Y,EACAC,U,SAAAA,U,EACAgE,S,SAAAA,S,EACAC,W,SAAAA,W,EACA7D,S,SAAAA,S,EACA8D,a,SAAAA,a;AAEMC,gBAAAA,kB,GAAqB;AACzBpE,kBAAAA,YAAY,EAAZA,YADyB;AAEzBC,kBAAAA,UAAU,EAAVA,UAFyB;AAGzBgE,kBAAAA,SAAS,EAATA,SAHyB;AAIzBC,kBAAAA,WAAW,EAAXA,WAJyB;AAKzB7D,kBAAAA,SAAS,EAATA,SALyB;AAMzB8D,kBAAAA,aAAa,EAAbA;AANyB,iB;;sBAQvB,KAAK1E,QAAL,IAAiB,KAAKD,UAAL,CAAgBS,UAAhB,C;;;;;sBACf,KAAKK,YAAL,CAAkBL,UAAlB,KAAiC,KAAKK,YAAL,CAAkBN,YAAlB,C;;;;;kDAC5B,KAAKqE,sBAAL,CAA4BD,kBAA5B,C;;;kDAEF,KAAKE,uBAAL,CAA6BF,kBAA7B,C;;;kDAEF,KAAKE,uBAAL,CAA6BF,kBAA7B,C;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIPpE,gBAAAA,Y,SAAAA,Y,EACAC,U,SAAAA,U,EACAgE,S,SAAAA,S,EACAC,W,SAAAA,W,EACA7D,S,SAAAA,S,EACA8D,a,SAAAA,a;;uBAE2B,KAAK5D,YAAL,CACzBP,YADyB,EAEzBC,UAFyB,EAGzBI,SAHyB,C;;;AAArBkE,gBAAAA,Y;AAKAC,gBAAAA,U,GAAa;AACjBC,kBAAAA,IAAI,EAAEzE,YAAY,CAAC0E,WAAb,EADW;AAEjBC,kBAAAA,EAAE,EAAE1E,UAAU,CAACyE,WAAX,EAFa;AAGjBE,kBAAAA,OAAO,EAAEX,SAHQ;AAIjBY,kBAAAA,OAAO,EAAE,IAJQ;AAKjBC,kBAAAA,MAAM,EAAEzE,SALS;AAMjB8D,kBAAAA,aAAa,EAAEA,aAAa,KAAK,EAAlB,GAAuBD,WAAvB,GAAqCC,aANnC;AAOjBY,kBAAAA,aAAa,EAAE,IAPE;AAQjBnD,kBAAAA,MAAM,EAAE2C,YAAY,CAAC3C;AARJ,iB;;uBAUNjD,cAAc,CAACqG,oBAAf,CAAoCR,UAApC,EAAgD,KAAKrF,OAArD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIba,gBAAAA,Y,SAAAA,Y,EACAC,U,SAAAA,U,EACAgE,S,SAAAA,S,EACAC,W,SAAAA,W,EACA7D,S,SAAAA,S,EACA8D,a,SAAAA,a;AAEMK,gBAAAA,U,GAAa;AACjBC,kBAAAA,IAAI,EAAEzE,YAAY,CAAC0E,WAAb,EADW;AAEjBC,kBAAAA,EAAE,EAAE1E,UAAU,CAACyE,WAAX,EAFa;AAGjBE,kBAAAA,OAAO,EAAEX,SAHQ;AAIjBY,kBAAAA,OAAO,EAAE,IAJQ;AAKjBC,kBAAAA,MAAM,EAAEzE,SALS;AAMjB8D,kBAAAA,aAAa,EAAEA,aAAa,KAAK,EAAlB,GAAuBD,WAAvB,GAAqCC,aANnC;AAOjBY,kBAAAA,aAAa,EAAE;AAPE,iB;;uBASNpG,cAAc,CAACqE,iBAAf,CAAiCwB,UAAjC,EAA6C,KAAKrF,OAAlD,C;;;;;;;;;;;;;;;;;;;;;;;;iDAiDOc,U,EAAY2E,O;;;;;;uBACnBjG,cAAc,CAACsG,eAAf,CACX;AACE9E,kBAAAA,QAAQ,EAAEF,UADZ;AAEE2E,kBAAAA,OAAO,EAAEA;AAFX,iBADW,EAKX,KAAKzF,OALM,C;;;;;;;;;;;;;;;;;;;;;wBApTM;AACnB,aAAOU,MAAM,CAACC,IAAP,CAAY,KAAKJ,YAAjB,EAA+BK,MAA/B,GAAwC,CAAxC,IAA6C,KAAKT,QAAL,GAAgB,CAApE;AACD;;;wBAEoB;AACnB,aAAO,KAAKH,OAAL,KAAiBf,cAAc,CAACgB,GAAvC;AACD;;;wBAMgB;AACf,UAAI,KAAKc,cAAT,EAAyB;AACvB,eAAO,KAAKX,eAAZ;AACD;;AACD,aAAO,EAAP;AACD;;;8BA/CgB;AACf,aAAOb,aAAP;AACD;;;4BASc;AACb,aAAO,KAAP;AACD;;;+BAsRiBwG,K,EAAO;AACvB,aAAO;AACLvB,QAAAA,OAAO,EAAEuB,KAAK,CAACrD,EADV;AAELsD,QAAAA,QAAQ,EAAED,KAAK,CAACrD,EAFX;AAGLuD,QAAAA,aAAa,EAAEF,KAAK,CAACrB,YAHhB;AAILH,QAAAA,QAAQ,EAAEwB,KAAK,CAAC3B,gBAJX;AAKL8B,QAAAA,SAAS,EAAEH,KAAK,CAAC7B,kBALZ;AAMLiC,QAAAA,MAAM,EAAEJ,KAAK,CAACI,MANT;AAOLC,QAAAA,SAAS,EAAEL,KAAK,CAACM,SAPZ;AAQLxB,QAAAA,QAAQ,EAAEvF,eARL,CAQqB;;AARrB,OAAP;AAUD;;;;;;iDAE2BgH,a,EAAetG,O;;;;;;;;uBAElBR,cAAc,CAAC+G,SAAf,CACnBD,aAAa,CAACN,QADK,EAEnBhG,OAFmB,C;;;AAAfmG,gBAAAA,M;mDAICvG,SAAS,CAAC4G,oBAAV,CAA+BL,MAA/B,C;;;;;AAEPjH,gBAAAA,KAAK,CAACuH,eAAN,gBAAyB,KAAzB;;;;;;;;;;;;;;;;;;yCAIwBN,M,EAAQ;AAClC,cAAQA,MAAR;AACE,aAAK9G,QAAQ,CAACqH,GAAd;AACE,iBAAOvH,oBAAoB,CAACwH,GAA5B;;AACF,aAAKtH,QAAQ,CAACuH,OAAd;AACE,iBAAOzH,oBAAoB,CAAC0H,IAA5B;;AACF,aAAKxH,QAAQ,CAACyH,UAAd;AACA,aAAKzH,QAAQ,CAAC0H,UAAd;AACA,aAAK1H,QAAQ,CAAC2H,OAAd;AACA,aAAK3H,QAAQ,CAAC4H,IAAd;AACE,iBAAO9H,oBAAoB,CAAC+H,OAA5B;;AACF,aAAK7H,QAAQ,CAAC8H,QAAd;AACE,iBAAOhI,oBAAoB,CAACiI,QAA5B;;AACF,aAAK/H,QAAQ,CAACgI,MAAd;AACE,iBAAOlI,oBAAoB,CAACmI,MAA5B;;AACF,aAAKjI,QAAQ,CAACkI,OAAd;AACA,aAAKlI,QAAQ,CAACmI,QAAd;AACE,iBAAOrI,oBAAoB,CAACsI,SAA5B;AAhBJ;AAkBD;;;;;;SA5VkB7H,S","sourcesContent":["import BigNumber from 'bignumber.js';\n\nimport { networkSymbols } from '../partnersConfig';\nimport { Toast } from '@/helpers';\n\nimport {\n  notificationStatuses,\n  ChangellyCurrencies,\n  statuses,\n  TIME_SWAP_VALID,\n  PROVIDER_NAME\n} from './config';\nimport changellyCalls from './changelly-calls';\nimport changellyApi from './changelly-api';\n\nimport debug from 'debug';\n\nconst errorLogger = debug('v5:partners-changelly');\n\nexport default class Changelly {\n  constructor(props = {}) {\n    this.name = Changelly.getName();\n    this.network = props.network || networkSymbols.ETH;\n    this.getRateForUnit =\n      typeof props.getRateForUnit === 'boolean' ? props.getRateForUnit : false;\n    this.hasRates = 0;\n    this.currencyDetails = props.currencies || ChangellyCurrencies;\n    this.useFixed = true;\n    this.tokenDetails = {};\n    this.getSupportedCurrencies(this.network);\n  }\n\n  static getName() {\n    return PROVIDER_NAME;\n  }\n\n  getApiConnector(type) {\n    if (type === 'api') {\n      return changellyApi;\n    }\n    return changellyCalls;\n  }\n\n  static isDex() {\n    return false;\n  }\n\n  async getSupportedCurrencies() {\n    try {\n      const {\n        currencyDetails,\n        tokenDetails\n      } = await changellyApi.getSupportedCurrencies(this.network);\n      this.currencyDetails = currencyDetails;\n      this.tokenDetails = tokenDetails;\n      this.hasRates =\n        Object.keys(this.tokenDetails).length > 0 ? this.hasRates + 1 : 0;\n    } catch (e) {\n      errorLogger(e);\n    }\n  }\n\n  get ratesRetrieved() {\n    return Object.keys(this.tokenDetails).length > 0 && this.hasRates > 0;\n  }\n\n  get isValidNetwork() {\n    return this.network === networkSymbols.ETH;\n  }\n\n  setNetwork(network) {\n    this.network = network;\n  }\n\n  get currencies() {\n    if (this.isValidNetwork) {\n      return this.currencyDetails;\n    }\n    return {};\n  }\n\n  validSwap(fromCurrency, toCurrency) {\n    if (this.isValidNetwork) {\n      return this.currencies[fromCurrency] && this.currencies[toCurrency];\n    }\n    return false;\n  }\n\n  fixedEnabled(currency) {\n    return (\n      typeof this.currencies[currency].fixRateEnabled === 'boolean' &&\n      this.currencies[currency].fixRateEnabled\n    );\n  }\n\n  async getRate(fromCurrency, toCurrency, fromValue) {\n    if (this.useFixed && this.currencies[toCurrency]) {\n      if (this.fixedEnabled(toCurrency) && this.fixedEnabled(fromCurrency)) {\n        return this.getFixedRate(fromCurrency, toCurrency, fromValue);\n      }\n      return this.getMarketRate(fromCurrency, toCurrency, fromValue);\n    }\n    return this.getMarketRate(fromCurrency, toCurrency, fromValue);\n  }\n\n  async getRateUpdate(fromCurrency, toCurrency, fromValue, toValue, isFiat) {\n    return this.getRate(fromCurrency, toCurrency, fromValue, toValue, isFiat);\n  }\n\n  getFixedRate(fromCurrency, toCurrency, fromValue) {\n    return new Promise(async resolve => {\n      const timeout = setTimeout(() => {\n        resolve({\n          fromCurrency,\n          toCurrency,\n          provider: this.name,\n          rate: 0\n        });\n      }, 20000);\n\n      const changellyDetails = await changellyCalls.getFixRate(\n        fromCurrency,\n        toCurrency,\n        fromValue,\n        this.network\n      );\n      clearTimeout(timeout);\n\n      if (!Array.isArray(changellyDetails)) {\n        return {\n          fromCurrency,\n          toCurrency,\n          provider: this.name,\n          rate: 0\n        };\n      }\n\n      resolve({\n        fromCurrency,\n        toCurrency,\n        provider: this.name,\n        minValue: changellyDetails[0].min,\n        maxValue: changellyDetails[0].max,\n        rate: changellyDetails[0].result,\n        rateId: changellyDetails[0].id\n      });\n    });\n  }\n\n  calculateRate(inVal, outVal) {\n    return new BigNumber(outVal).div(inVal);\n  }\n\n  async getMarketRate(fromCurrency, toCurrency, fromValue) {\n    try {\n      const changellyDetails = await Promise.all([\n        changellyCalls.getMin(\n          fromCurrency,\n          toCurrency,\n          fromValue,\n          this.network\n        ),\n        changellyCalls.getRate(\n          fromCurrency,\n          toCurrency,\n          fromValue,\n          this.network\n        )\n      ]);\n\n      const minAmount = new BigNumber(changellyDetails[0])\n        .times(0.001)\n        .plus(new BigNumber(changellyDetails[0]))\n        .toFixed();\n\n      const estValueResponse = changellyDetails[1][0];\n\n      return {\n        fromCurrency,\n        toCurrency,\n        provider: this.name,\n        minValue: minAmount,\n        rate: estValueResponse.rate\n      };\n    } catch (e) {\n      return {\n        fromCurrency,\n        toCurrency,\n        provider: this.name,\n        rate: 0\n      };\n    }\n  }\n\n  getInitialCurrencyEntries(collectMapFrom, collectMapTo) {\n    for (const prop in this.currencies) {\n      if (this.currencies[prop])\n        collectMapTo.set(prop, {\n          symbol: prop,\n          name: this.currencies[prop].name\n        });\n      collectMapFrom.set(prop, {\n        symbol: prop,\n        name: this.currencies[prop].name\n      });\n    }\n  }\n\n  getUpdatedFromCurrencyEntries(value, collectMap) {\n    if (this.currencies[value.symbol]) {\n      for (const prop in this.currencies) {\n        if (this.currencies[prop])\n          collectMap.set(prop, {\n            symbol: prop,\n            name: this.currencies[prop].name\n          });\n      }\n    }\n  }\n\n  getUpdatedToCurrencyEntries(value, collectMap) {\n    if (this.currencies[value.symbol]) {\n      for (const prop in this.currencies) {\n        if (this.currencies[prop])\n          collectMap.set(prop, {\n            symbol: prop,\n            name: this.currencies[prop].name\n          });\n      }\n    }\n  }\n\n  async startSwap(swapDetails) {\n    let details;\n    if (+swapDetails.minValue <= +swapDetails.fromValue) {\n      details = await this.createTransaction(swapDetails);\n      if (!details) throw Error('abort');\n      if (details.message) throw Error(details.message);\n      swapDetails.providerReceives = details.amountExpectedFrom;\n      swapDetails.providerSends = details.amountExpectedTo;\n      swapDetails.parsed = Changelly.parseOrder(details);\n      swapDetails.providerSends = swapDetails.parsed.recValue;\n      swapDetails.orderId = swapDetails.parsed.orderId;\n      swapDetails.providerAddress = details.payinAddress;\n      swapDetails.dataForInitialization = details;\n      swapDetails.isDex = Changelly.isDex();\n      swapDetails.validFor = swapDetails.parsed.validFor;\n      return swapDetails;\n    }\n    return Error('From amount below changelly minimum for currency pair');\n  }\n\n  async createTransaction({\n    fromCurrency,\n    toCurrency,\n    toAddress,\n    fromAddress,\n    fromValue,\n    refundAddress\n  }) {\n    const transactionDetails = {\n      fromCurrency,\n      toCurrency,\n      toAddress,\n      fromAddress,\n      fromValue,\n      refundAddress\n    };\n    if (this.useFixed && this.currencies[toCurrency]) {\n      if (this.fixedEnabled(toCurrency) && this.fixedEnabled(fromCurrency)) {\n        return this.createFixedTransaction(transactionDetails);\n      }\n      return this.createMarketTransaction(transactionDetails);\n    }\n    return this.createMarketTransaction(transactionDetails);\n  }\n\n  async createFixedTransaction({\n    fromCurrency,\n    toCurrency,\n    toAddress,\n    fromAddress,\n    fromValue,\n    refundAddress\n  }) {\n    const finalDetails = await this.getFixedRate(\n      fromCurrency,\n      toCurrency,\n      fromValue\n    );\n    const swapParams = {\n      from: fromCurrency.toLowerCase(),\n      to: toCurrency.toLowerCase(),\n      address: toAddress,\n      extraId: null,\n      amount: fromValue,\n      refundAddress: refundAddress === '' ? fromAddress : refundAddress,\n      refundExtraId: null,\n      rateId: finalDetails.rateId\n    };\n    return await changellyCalls.createFixTransaction(swapParams, this.network);\n  }\n\n  async createMarketTransaction({\n    fromCurrency,\n    toCurrency,\n    toAddress,\n    fromAddress,\n    fromValue,\n    refundAddress\n  }) {\n    const swapParams = {\n      from: fromCurrency.toLowerCase(),\n      to: toCurrency.toLowerCase(),\n      address: toAddress,\n      extraId: null,\n      amount: fromValue,\n      refundAddress: refundAddress === '' ? fromAddress : refundAddress,\n      refundExtraId: null\n    };\n    return await changellyCalls.createTransaction(swapParams, this.network);\n  }\n\n  static parseOrder(order) {\n    return {\n      orderId: order.id,\n      statusId: order.id,\n      sendToAddress: order.payinAddress,\n      recValue: order.amountExpectedTo,\n      sendValue: order.amountExpectedFrom,\n      status: order.status,\n      timestamp: order.createdAt,\n      validFor: TIME_SWAP_VALID // Rates provided are only an estimate\n    };\n  }\n\n  static async getOrderStatus(noticeDetails, network) {\n    try {\n      const status = await changellyCalls.getStatus(\n        noticeDetails.statusId,\n        network\n      );\n      return Changelly.parseChangellyStatus(status);\n    } catch (e) {\n      Toast.responseHandler(e, false);\n    }\n  }\n\n  static parseChangellyStatus(status) {\n    switch (status) {\n      case statuses.new:\n        return notificationStatuses.NEW;\n      case statuses.waiting:\n        return notificationStatuses.SENT;\n      case statuses.confirming:\n      case statuses.exchanging:\n      case statuses.sending:\n      case statuses.hold:\n        return notificationStatuses.PENDING;\n      case statuses.finished:\n        return notificationStatuses.COMPLETE;\n      case statuses.failed:\n        return notificationStatuses.FAILED;\n      case statuses.overdue:\n      case statuses.refunded:\n        return notificationStatuses.CANCELLED;\n    }\n  }\n\n  async validateAddress(toCurrency, address) {\n    return await changellyCalls.validateAddress(\n      {\n        currency: toCurrency,\n        address: address\n      },\n      this.network\n    );\n  }\n}\n"]}]}