{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/bitbox/digitalBitboxEth.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/bitbox/digitalBitboxEth.js","mtime":1574664278326},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js","mtime":1574664275010},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js","mtime":1574664275986}],"contextDependencies":[],"result":["/**\n *  (c) 2017 Douglas Bakkum, Shift Devices AG\n *  MIT license\n **/\n// Hijacks the U2F auth command to pass HWW API commands\n// TODO - Integrate the smart verification mobile app (send result['echo'] from sign response).\n//        Requires pairing, for example copy-pasting the pairing code from the desktop app (needs implementation).\n'use strict';\n\nimport \"core-js/modules/es6.regexp.to-string\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport * as Crypto from 'crypto';\nimport * as HDKey from 'hdkey';\nimport * as semver from 'semver';\nvar BitBoxLowestSupportedVersion = '7.0.1';\nvar BitBoxNonSupportedVersion = '8.0.0';\nvar hijackState = {\n  // Order must match that in the firmware code\n  responseReady: 0,\n  processingCommand: 1,\n  incompleteCommand: 2,\n  idle: 3\n};\n\nvar DigitalBitboxEth =\n/*#__PURE__*/\nfunction () {\n  function DigitalBitboxEth(comm, secret) {\n    var _this = this;\n\n    _classCallCheck(this, DigitalBitboxEth);\n\n    this.comm = comm;\n    this.secret = '';\n    this.timeout = null;\n    this.secret = secret || this.secret;\n    this.key = Crypto.createHash('sha256').update(new Buffer(this.secret, 'utf8')).digest();\n    this.key = Crypto.createHash('sha256').update(this.key).digest();\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(function () {\n      _this.secret = '';\n    }, 60000);\n  }\n\n  _createClass(DigitalBitboxEth, [{\n    key: \"send\",\n    value: function send(cmd, encrypt, callback) {\n      var _this2 = this;\n\n      var message = '';\n      if (encrypt) message = DigitalBitboxEth.aes_cbc_b64_encrypt(cmd, this.key);else message = cmd || ' '; // Need at least 1 byte length for U2F\n\n      this.comm.exchange(message, function (response, err) {\n        try {\n          if (typeof err !== 'undefined' || typeof response === 'undefined') {\n            // Entered on U2F timeouts\n            // Poll for the response\n            _this2.send('', false, callback);\n\n            return;\n          }\n\n          if (response.length == 1) {\n            if (response[0] == hijackState.processingCommand) {\n              // BitBox is processing the previous command\n              // Poll for the response\n              _this2.send('', false, callback);\n            }\n\n            return;\n          }\n\n          response = JSON.parse(response.toString('utf8'));\n\n          if ('error' in response) {\n            callback(undefined, DigitalBitboxEth.parseError(response.error));\n            return;\n          }\n\n          if ('ping' in response) {\n            if (!('device' in response)) {\n              callback(undefined, 'errorUpgradeFirmware');\n              return;\n            }\n\n            if (semver.lt(response.device.version, BitBoxLowestSupportedVersion)) {\n              callback(undefined, 'errorUpgradeFirmware');\n              return;\n            }\n\n            if (semver.gte(response.device.version, BitBoxNonSupportedVersion)) {\n              callback(undefined, 'errorUnsupportedFirmware');\n              return;\n            }\n\n            callback(response);\n          }\n\n          if ('ciphertext' in response) {\n            response = JSON.parse(DigitalBitboxEth.aes_cbc_b64_decrypt(response.ciphertext, _this2.key));\n\n            if ('error' in response) {\n              callback(undefined, DigitalBitboxEth.parseError(response.error));\n              return;\n            }\n\n            callback(response);\n          }\n        } catch (err) {\n          // unexpected error\n          callback(undefined, 'errorUnexpected');\n        }\n      });\n    }\n  }, {\n    key: \"getStarted\",\n    value: function getStarted(path, callback) {\n      var _this3 = this;\n\n      // First check firmware version compatibility\n      // Get extended public key if firmware is compatible\n      // Else return an error\n      var localCallback = function localCallback(response, error) {\n        if (typeof error != 'undefined') {\n          callback(undefined, error);\n          return;\n        }\n\n        _this3.getAddress(path, callback);\n      };\n\n      this.send('{\"ping\":\"\"}', false, localCallback);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress(path, callback) {\n      // Get extended public key\n      var cmd = '{\"xpub\":\"' + path + '\"}';\n\n      var localCallback = function localCallback(response, error) {\n        if (typeof error != 'undefined') {\n          callback(undefined, error);\n          return;\n        }\n\n        var hdkey = HDKey.fromExtendedKey(response.xpub);\n        var result = {\n          publicKey: hdkey.publicKey.toString('hex'),\n          chainCode: hdkey.chainCode.toString('hex')\n        };\n        callback(result);\n        return;\n      };\n\n      this.send(cmd, true, localCallback);\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(path, eTx) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        var chainId = eTx.getChainId();\n        var hashToSign = eTx.hash(false).toString('hex');\n        DigitalBitboxEth.signGeneric(_this4, path, chainId, hashToSign, function (result, error) {\n          if (error) return reject(error);\n          resolve(result);\n        });\n      });\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(path, messageHex) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        var hashToSign = messageHex.toString('hex');\n        DigitalBitboxEth.signGeneric(_this5, path, 0, hashToSign, function (result, error) {\n          if (error) return reject(error);\n          resolve(result);\n        });\n      });\n    }\n  }]);\n\n  return DigitalBitboxEth;\n}();\n\n_defineProperty(DigitalBitboxEth, \"aes_cbc_b64_decrypt\", function (ciphertext, key) {\n  try {\n    var h = Crypto.createHash('sha512').update(key).digest();\n    var encryptionKey = h.slice(0, 32);\n    var authenticationKey = h.slice(32, 64);\n    var ub64 = new Buffer(ciphertext, 'base64').toString('binary');\n    var cipher = new Buffer(ub64.slice(0, ub64.length - 32), 'binary');\n    var hmac = new Buffer(ub64.slice(ub64.length - 32), 'binary');\n    var expectedHmac = Crypto.createHmac('sha256', authenticationKey).update(cipher).digest();\n\n    if (!hmac.equals(expectedHmac)) {\n      throw 'hmac check failed';\n    }\n\n    var iv = new Buffer(cipher.slice(0, 16), 'binary');\n    var enc = new Buffer(cipher.slice(16), 'binary');\n    var decipher = Crypto.createDecipheriv('aes-256-cbc', encryptionKey, iv);\n    var dec = decipher.update(enc) + decipher.final();\n    return dec.toString('utf8');\n  } catch (err) {\n    return ciphertext;\n  }\n});\n\n_defineProperty(DigitalBitboxEth, \"aes_cbc_b64_encrypt\", function (plaintext, key) {\n  try {\n    var h = Crypto.createHash('sha512').update(key).digest();\n    var encryptionKey = h.slice(0, 32);\n    var authenticationKey = h.slice(32, 64);\n    var iv = Crypto.randomBytes(16);\n    var cipher = Crypto.createCipheriv('aes-256-cbc', encryptionKey, iv);\n    var ciphertext = Buffer.concat([iv, cipher.update(plaintext), cipher.final()]);\n    var hmac = Crypto.createHmac('sha256', authenticationKey).update(ciphertext).digest();\n    return Buffer.concat([ciphertext, hmac]).toString('base64');\n  } catch (err) {\n    return '';\n  }\n});\n\n_defineProperty(DigitalBitboxEth, \"parseError\", function (errObject) {\n  var errMsg = {\n    err101: 'errorNotInitialized',\n    // No password set\n    err250: 'errorNotInitialized',\n    // Wallet not seeded\n    err251: 'errorNotInitialized',\n    // Wallet not seeded\n    err109: 'errorInvalidPassword' + errObject.message,\n    // Wrong password (typically); append error message in order to parse login tries left\n    err600: 'errorUserAbort',\n    // User aborted action\n    err601: 'errorUserTimeout' // Touch button not pressed\n\n  };\n  var code = 'err' + ('code' in errObject ? errObject.code.toString() : '');\n  var err = {\n    message: errMsg[code] || 'errorUnexpected'\n  };\n  return err;\n});\n\n_defineProperty(DigitalBitboxEth, \"signGeneric\", function (self, path, chainId, hashToSign, callback) {\n  var cmd = '{\"sign\":{\"data\":[{\"hash\":\"' + hashToSign + '\",\"keypath\":\"' + path + '\"}]}}';\n\n  var localCallback = function localCallback(response, error) {\n    if (typeof error != 'undefined') {\n      callback(undefined, error);\n      return;\n    }\n\n    if ('echo' in response) {\n      self.send('{\"sign\":\"\"}', true, localCallback);\n      return;\n    }\n\n    if ('sign' in response) {\n      var vOffset = chainId ? chainId * 2 + 8 : 0;\n      var v = new Buffer([parseInt(response.sign[0].recid, 16) + 27 + vOffset]);\n      var result = {\n        v: v.toString('hex'),\n        r: response.sign[0].sig.slice(0, 64),\n        s: response.sign[0].sig.slice(64, 128)\n      };\n      callback(result);\n      return;\n    }\n  };\n\n  self.send(cmd, true, localCallback);\n});\n\nexport default DigitalBitboxEth;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/bitbox/digitalBitboxEth.js"],"names":["Crypto","HDKey","semver","BitBoxLowestSupportedVersion","BitBoxNonSupportedVersion","hijackState","responseReady","processingCommand","incompleteCommand","idle","DigitalBitboxEth","comm","secret","timeout","key","createHash","update","Buffer","digest","clearTimeout","setTimeout","cmd","encrypt","callback","message","aes_cbc_b64_encrypt","exchange","response","err","send","length","JSON","parse","toString","undefined","parseError","error","lt","device","version","gte","aes_cbc_b64_decrypt","ciphertext","path","localCallback","getAddress","hdkey","fromExtendedKey","xpub","result","publicKey","chainCode","eTx","Promise","resolve","reject","chainId","getChainId","hashToSign","hash","signGeneric","messageHex","h","encryptionKey","slice","authenticationKey","ub64","cipher","hmac","expectedHmac","createHmac","equals","iv","enc","decipher","createDecipheriv","dec","final","plaintext","randomBytes","createCipheriv","concat","errObject","errMsg","err101","err250","err251","err109","err600","err601","code","self","vOffset","v","parseInt","sign","recid","r","sig","s"],"mappings":"AAAA;;;;AAKA;AAEA;AACA;AAEA;;;;;;AAEA,OAAO,KAAKA,MAAZ,MAAwB,QAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,MAAZ,MAAwB,QAAxB;AAEA,IAAMC,4BAA4B,GAAG,OAArC;AACA,IAAMC,yBAAyB,GAAG,OAAlC;AACA,IAAMC,WAAW,GAAG;AAClB;AACAC,EAAAA,aAAa,EAAE,CAFG;AAGlBC,EAAAA,iBAAiB,EAAE,CAHD;AAIlBC,EAAAA,iBAAiB,EAAE,CAJD;AAKlBC,EAAAA,IAAI,EAAE;AALY,CAApB;;IAOMC,gB;;;AAmGJ,4BAAYC,IAAZ,EAAkBC,MAAlB,EAA0B;AAAA;;AAAA;;AACxB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKD,MAAL,GAAcA,MAAM,IAAI,KAAKA,MAA7B;AACA,SAAKE,GAAL,GAAWd,MAAM,CAACe,UAAP,CAAkB,QAAlB,EACRC,MADQ,CACD,IAAIC,MAAJ,CAAW,KAAKL,MAAhB,EAAwB,MAAxB,CADC,EAERM,MAFQ,EAAX;AAGA,SAAKJ,GAAL,GAAWd,MAAM,CAACe,UAAP,CAAkB,QAAlB,EACRC,MADQ,CACD,KAAKF,GADJ,EAERI,MAFQ,EAAX;AAGAC,IAAAA,YAAY,CAAC,KAAKN,OAAN,CAAZ;AACA,SAAKA,OAAL,GAAeO,UAAU,CAAC,YAAM;AAC9B,MAAA,KAAI,CAACR,MAAL,GAAc,EAAd;AACD,KAFwB,EAEtB,KAFsB,CAAzB;AAGD;;;;yBACIS,G,EAAKC,O,EAASC,Q,EAAU;AAAA;;AAC3B,UAAIC,OAAO,GAAG,EAAd;AACA,UAAIF,OAAJ,EAAaE,OAAO,GAAGd,gBAAgB,CAACe,mBAAjB,CAAqCJ,GAArC,EAA0C,KAAKP,GAA/C,CAAV,CAAb,KACKU,OAAO,GAAGH,GAAG,IAAI,GAAjB,CAHsB,CAGA;;AAC3B,WAAKV,IAAL,CAAUe,QAAV,CAAmBF,OAAnB,EAA4B,UAACG,QAAD,EAAWC,GAAX,EAAmB;AAC7C,YAAI;AACF,cAAI,OAAOA,GAAP,KAAe,WAAf,IAA8B,OAAOD,QAAP,KAAoB,WAAtD,EAAmE;AACjE;AACA;AACA,YAAA,MAAI,CAACE,IAAL,CAAU,EAAV,EAAc,KAAd,EAAqBN,QAArB;;AACA;AACD;;AACD,cAAII,QAAQ,CAACG,MAAT,IAAmB,CAAvB,EAA0B;AACxB,gBAAIH,QAAQ,CAAC,CAAD,CAAR,IAAetB,WAAW,CAACE,iBAA/B,EAAkD;AAChD;AACA;AACA,cAAA,MAAI,CAACsB,IAAL,CAAU,EAAV,EAAc,KAAd,EAAqBN,QAArB;AACD;;AACD;AACD;;AACDI,UAAAA,QAAQ,GAAGI,IAAI,CAACC,KAAL,CAAWL,QAAQ,CAACM,QAAT,CAAkB,MAAlB,CAAX,CAAX;;AACA,cAAI,WAAWN,QAAf,EAAyB;AACvBJ,YAAAA,QAAQ,CAACW,SAAD,EAAYxB,gBAAgB,CAACyB,UAAjB,CAA4BR,QAAQ,CAACS,KAArC,CAAZ,CAAR;AACA;AACD;;AAED,cAAI,UAAUT,QAAd,EAAwB;AACtB,gBAAI,EAAE,YAAYA,QAAd,CAAJ,EAA6B;AAC3BJ,cAAAA,QAAQ,CAACW,SAAD,EAAY,sBAAZ,CAAR;AACA;AACD;;AACD,gBACEhC,MAAM,CAACmC,EAAP,CAAUV,QAAQ,CAACW,MAAT,CAAgBC,OAA1B,EAAmCpC,4BAAnC,CADF,EAEE;AACAoB,cAAAA,QAAQ,CAACW,SAAD,EAAY,sBAAZ,CAAR;AACA;AACD;;AACD,gBAAIhC,MAAM,CAACsC,GAAP,CAAWb,QAAQ,CAACW,MAAT,CAAgBC,OAA3B,EAAoCnC,yBAApC,CAAJ,EAAoE;AAClEmB,cAAAA,QAAQ,CAACW,SAAD,EAAY,0BAAZ,CAAR;AACA;AACD;;AACDX,YAAAA,QAAQ,CAACI,QAAD,CAAR;AACD;;AAED,cAAI,gBAAgBA,QAApB,EAA8B;AAC5BA,YAAAA,QAAQ,GAAGI,IAAI,CAACC,KAAL,CACTtB,gBAAgB,CAAC+B,mBAAjB,CAAqCd,QAAQ,CAACe,UAA9C,EAA0D,MAAI,CAAC5B,GAA/D,CADS,CAAX;;AAGA,gBAAI,WAAWa,QAAf,EAAyB;AACvBJ,cAAAA,QAAQ,CAACW,SAAD,EAAYxB,gBAAgB,CAACyB,UAAjB,CAA4BR,QAAQ,CAACS,KAArC,CAAZ,CAAR;AACA;AACD;;AACDb,YAAAA,QAAQ,CAACI,QAAD,CAAR;AACD;AACF,SAjDD,CAiDE,OAAOC,GAAP,EAAY;AACZ;AACAL,UAAAA,QAAQ,CAACW,SAAD,EAAY,iBAAZ,CAAR;AACD;AACF,OAtDD;AAuDD;;;+BACUS,I,EAAMpB,Q,EAAU;AAAA;;AACzB;AACA;AACA;AACA,UAAMqB,aAAa,GAAG,SAAhBA,aAAgB,CAACjB,QAAD,EAAWS,KAAX,EAAqB;AACzC,YAAI,OAAOA,KAAP,IAAgB,WAApB,EAAiC;AAC/Bb,UAAAA,QAAQ,CAACW,SAAD,EAAYE,KAAZ,CAAR;AACA;AACD;;AACD,QAAA,MAAI,CAACS,UAAL,CAAgBF,IAAhB,EAAsBpB,QAAtB;AACD,OAND;;AAOA,WAAKM,IAAL,CAAU,aAAV,EAAyB,KAAzB,EAAgCe,aAAhC;AACD;;;+BACUD,I,EAAMpB,Q,EAAU;AACzB;AACA,UAAMF,GAAG,GAAG,cAAcsB,IAAd,GAAqB,IAAjC;;AACA,UAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACjB,QAAD,EAAWS,KAAX,EAAqB;AACzC,YAAI,OAAOA,KAAP,IAAgB,WAApB,EAAiC;AAC/Bb,UAAAA,QAAQ,CAACW,SAAD,EAAYE,KAAZ,CAAR;AACA;AACD;;AACD,YAAMU,KAAK,GAAG7C,KAAK,CAAC8C,eAAN,CAAsBpB,QAAQ,CAACqB,IAA/B,CAAd;AACA,YAAMC,MAAM,GAAG;AACbC,UAAAA,SAAS,EAAEJ,KAAK,CAACI,SAAN,CAAgBjB,QAAhB,CAAyB,KAAzB,CADE;AAEbkB,UAAAA,SAAS,EAAEL,KAAK,CAACK,SAAN,CAAgBlB,QAAhB,CAAyB,KAAzB;AAFE,SAAf;AAIAV,QAAAA,QAAQ,CAAC0B,MAAD,CAAR;AACA;AACD,OAZD;;AAaA,WAAKpB,IAAL,CAAUR,GAAV,EAAe,IAAf,EAAqBuB,aAArB;AACD;;;oCACeD,I,EAAMS,G,EAAK;AAAA;;AACzB,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,OAAO,GAAGJ,GAAG,CAACK,UAAJ,EAAhB;AACA,YAAMC,UAAU,GAAGN,GAAG,CAACO,IAAJ,CAAS,KAAT,EAAgB1B,QAAhB,CAAyB,KAAzB,CAAnB;AACAvB,QAAAA,gBAAgB,CAACkD,WAAjB,CACE,MADF,EAEEjB,IAFF,EAGEa,OAHF,EAIEE,UAJF,EAKE,UAACT,MAAD,EAASb,KAAT,EAAmB;AACjB,cAAIA,KAAJ,EAAW,OAAOmB,MAAM,CAACnB,KAAD,CAAb;AACXkB,UAAAA,OAAO,CAACL,MAAD,CAAP;AACD,SARH;AAUD,OAbM,CAAP;AAcD;;;gCACWN,I,EAAMkB,U,EAAY;AAAA;;AAC5B,aAAO,IAAIR,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMG,UAAU,GAAGG,UAAU,CAAC5B,QAAX,CAAoB,KAApB,CAAnB;AACAvB,QAAAA,gBAAgB,CAACkD,WAAjB,CACE,MADF,EAEEjB,IAFF,EAGE,CAHF,EAIEe,UAJF,EAKE,UAACT,MAAD,EAASb,KAAT,EAAmB;AACjB,cAAIA,KAAJ,EAAW,OAAOmB,MAAM,CAACnB,KAAD,CAAb;AACXkB,UAAAA,OAAO,CAACL,MAAD,CAAP;AACD,SARH;AAUD,OAZM,CAAP;AAaD;;;;;;gBA5OGvC,gB,yBACyB,UAACgC,UAAD,EAAa5B,GAAb,EAAqB;AAChD,MAAI;AACF,QAAMgD,CAAC,GAAG9D,MAAM,CAACe,UAAP,CAAkB,QAAlB,EACPC,MADO,CACAF,GADA,EAEPI,MAFO,EAAV;AAGA,QAAM6C,aAAa,GAAGD,CAAC,CAACE,KAAF,CAAQ,CAAR,EAAW,EAAX,CAAtB;AACA,QAAMC,iBAAiB,GAAGH,CAAC,CAACE,KAAF,CAAQ,EAAR,EAAY,EAAZ,CAA1B;AAEA,QAAME,IAAI,GAAG,IAAIjD,MAAJ,CAAWyB,UAAX,EAAuB,QAAvB,EAAiCT,QAAjC,CAA0C,QAA1C,CAAb;AACA,QAAMkC,MAAM,GAAG,IAAIlD,MAAJ,CAAWiD,IAAI,CAACF,KAAL,CAAW,CAAX,EAAcE,IAAI,CAACpC,MAAL,GAAc,EAA5B,CAAX,EAA4C,QAA5C,CAAf;AACA,QAAMsC,IAAI,GAAG,IAAInD,MAAJ,CAAWiD,IAAI,CAACF,KAAL,CAAWE,IAAI,CAACpC,MAAL,GAAc,EAAzB,CAAX,EAAyC,QAAzC,CAAb;AACA,QAAMuC,YAAY,GAAGrE,MAAM,CAACsE,UAAP,CAAkB,QAAlB,EAA4BL,iBAA5B,EAClBjD,MADkB,CACXmD,MADW,EAElBjD,MAFkB,EAArB;;AAGA,QAAI,CAACkD,IAAI,CAACG,MAAL,CAAYF,YAAZ,CAAL,EAAgC;AAC9B,YAAM,mBAAN;AACD;;AACD,QAAMG,EAAE,GAAG,IAAIvD,MAAJ,CAAWkD,MAAM,CAACH,KAAP,CAAa,CAAb,EAAgB,EAAhB,CAAX,EAAgC,QAAhC,CAAX;AACA,QAAMS,GAAG,GAAG,IAAIxD,MAAJ,CAAWkD,MAAM,CAACH,KAAP,CAAa,EAAb,CAAX,EAA6B,QAA7B,CAAZ;AACA,QAAMU,QAAQ,GAAG1E,MAAM,CAAC2E,gBAAP,CACf,aADe,EAEfZ,aAFe,EAGfS,EAHe,CAAjB;AAKA,QAAMI,GAAG,GAAGF,QAAQ,CAAC1D,MAAT,CAAgByD,GAAhB,IAAuBC,QAAQ,CAACG,KAAT,EAAnC;AACA,WAAOD,GAAG,CAAC3C,QAAJ,CAAa,MAAb,CAAP;AACD,GAzBD,CAyBE,OAAOL,GAAP,EAAY;AACZ,WAAOc,UAAP;AACD;AACF,C;;gBA9BGhC,gB,yBA+ByB,UAACoE,SAAD,EAAYhE,GAAZ,EAAoB;AAC/C,MAAI;AACF,QAAMgD,CAAC,GAAG9D,MAAM,CAACe,UAAP,CAAkB,QAAlB,EACPC,MADO,CACAF,GADA,EAEPI,MAFO,EAAV;AAGA,QAAM6C,aAAa,GAAGD,CAAC,CAACE,KAAF,CAAQ,CAAR,EAAW,EAAX,CAAtB;AACA,QAAMC,iBAAiB,GAAGH,CAAC,CAACE,KAAF,CAAQ,EAAR,EAAY,EAAZ,CAA1B;AAEA,QAAMQ,EAAE,GAAGxE,MAAM,CAAC+E,WAAP,CAAmB,EAAnB,CAAX;AACA,QAAMZ,MAAM,GAAGnE,MAAM,CAACgF,cAAP,CAAsB,aAAtB,EAAqCjB,aAArC,EAAoDS,EAApD,CAAf;AACA,QAAM9B,UAAU,GAAGzB,MAAM,CAACgE,MAAP,CAAc,CAC/BT,EAD+B,EAE/BL,MAAM,CAACnD,MAAP,CAAc8D,SAAd,CAF+B,EAG/BX,MAAM,CAACU,KAAP,EAH+B,CAAd,CAAnB;AAKA,QAAMT,IAAI,GAAGpE,MAAM,CAACsE,UAAP,CAAkB,QAAlB,EAA4BL,iBAA5B,EACVjD,MADU,CACH0B,UADG,EAEVxB,MAFU,EAAb;AAGA,WAAOD,MAAM,CAACgE,MAAP,CAAc,CAACvC,UAAD,EAAa0B,IAAb,CAAd,EAAkCnC,QAAlC,CAA2C,QAA3C,CAAP;AACD,GAlBD,CAkBE,OAAOL,GAAP,EAAY;AACZ,WAAO,EAAP;AACD;AACF,C;;gBArDGlB,gB,gBAsDgB,UAAAwE,SAAS,EAAI;AAC/B,MAAMC,MAAM,GAAG;AACbC,IAAAA,MAAM,EAAE,qBADK;AACkB;AAC/BC,IAAAA,MAAM,EAAE,qBAFK;AAEkB;AAC/BC,IAAAA,MAAM,EAAE,qBAHK;AAGkB;AAC/BC,IAAAA,MAAM,EAAE,yBAAyBL,SAAS,CAAC1D,OAJ9B;AAIuC;AACpDgE,IAAAA,MAAM,EAAE,gBALK;AAKa;AAC1BC,IAAAA,MAAM,EAAE,kBANK,CAMc;;AANd,GAAf;AAQA,MAAMC,IAAI,GAAG,SAAS,UAAUR,SAAV,GAAsBA,SAAS,CAACQ,IAAV,CAAezD,QAAf,EAAtB,GAAkD,EAA3D,CAAb;AACA,MAAML,GAAG,GAAG;AAAEJ,IAAAA,OAAO,EAAE2D,MAAM,CAACO,IAAD,CAAN,IAAgB;AAA3B,GAAZ;AACA,SAAO9D,GAAP;AACD,C;;gBAlEGlB,gB,iBAmEiB,UAACiF,IAAD,EAAOhD,IAAP,EAAaa,OAAb,EAAsBE,UAAtB,EAAkCnC,QAAlC,EAA+C;AAClE,MAAMF,GAAG,GACP,+BACAqC,UADA,GAEA,eAFA,GAGAf,IAHA,GAIA,OALF;;AAMA,MAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACjB,QAAD,EAAWS,KAAX,EAAqB;AACzC,QAAI,OAAOA,KAAP,IAAgB,WAApB,EAAiC;AAC/Bb,MAAAA,QAAQ,CAACW,SAAD,EAAYE,KAAZ,CAAR;AACA;AACD;;AACD,QAAI,UAAUT,QAAd,EAAwB;AACtBgE,MAAAA,IAAI,CAAC9D,IAAL,CAAU,aAAV,EAAyB,IAAzB,EAA+Be,aAA/B;AACA;AACD;;AACD,QAAI,UAAUjB,QAAd,EAAwB;AACtB,UAAMiE,OAAO,GAAGpC,OAAO,GAAGA,OAAO,GAAG,CAAV,GAAc,CAAjB,GAAqB,CAA5C;AACA,UAAMqC,CAAC,GAAG,IAAI5E,MAAJ,CAAW,CACnB6E,QAAQ,CAACnE,QAAQ,CAACoE,IAAT,CAAc,CAAd,EAAiBC,KAAlB,EAAyB,EAAzB,CAAR,GAAuC,EAAvC,GAA4CJ,OADzB,CAAX,CAAV;AAGA,UAAM3C,MAAM,GAAG;AACb4C,QAAAA,CAAC,EAAEA,CAAC,CAAC5D,QAAF,CAAW,KAAX,CADU;AAEbgE,QAAAA,CAAC,EAAEtE,QAAQ,CAACoE,IAAT,CAAc,CAAd,EAAiBG,GAAjB,CAAqBlC,KAArB,CAA2B,CAA3B,EAA8B,EAA9B,CAFU;AAGbmC,QAAAA,CAAC,EAAExE,QAAQ,CAACoE,IAAT,CAAc,CAAd,EAAiBG,GAAjB,CAAqBlC,KAArB,CAA2B,EAA3B,EAA+B,GAA/B;AAHU,OAAf;AAKAzC,MAAAA,QAAQ,CAAC0B,MAAD,CAAR;AACA;AACD;AACF,GAtBD;;AAuBA0C,EAAAA,IAAI,CAAC9D,IAAL,CAAUR,GAAV,EAAe,IAAf,EAAqBuB,aAArB;AACD,C;;AA4IH,eAAelC,gBAAf","sourcesContent":["/**\n *  (c) 2017 Douglas Bakkum, Shift Devices AG\n *  MIT license\n **/\n\n// Hijacks the U2F auth command to pass HWW API commands\n\n// TODO - Integrate the smart verification mobile app (send result['echo'] from sign response).\n//        Requires pairing, for example copy-pasting the pairing code from the desktop app (needs implementation).\n\n'use strict';\n\nimport * as Crypto from 'crypto';\nimport * as HDKey from 'hdkey';\nimport * as semver from 'semver';\n\nconst BitBoxLowestSupportedVersion = '7.0.1';\nconst BitBoxNonSupportedVersion = '8.0.0';\nconst hijackState = {\n  // Order must match that in the firmware code\n  responseReady: 0,\n  processingCommand: 1,\n  incompleteCommand: 2,\n  idle: 3\n};\nclass DigitalBitboxEth {\n  static aes_cbc_b64_decrypt = (ciphertext, key) => {\n    try {\n      const h = Crypto.createHash('sha512')\n        .update(key)\n        .digest();\n      const encryptionKey = h.slice(0, 32);\n      const authenticationKey = h.slice(32, 64);\n\n      const ub64 = new Buffer(ciphertext, 'base64').toString('binary');\n      const cipher = new Buffer(ub64.slice(0, ub64.length - 32), 'binary');\n      const hmac = new Buffer(ub64.slice(ub64.length - 32), 'binary');\n      const expectedHmac = Crypto.createHmac('sha256', authenticationKey)\n        .update(cipher)\n        .digest();\n      if (!hmac.equals(expectedHmac)) {\n        throw 'hmac check failed';\n      }\n      const iv = new Buffer(cipher.slice(0, 16), 'binary');\n      const enc = new Buffer(cipher.slice(16), 'binary');\n      const decipher = Crypto.createDecipheriv(\n        'aes-256-cbc',\n        encryptionKey,\n        iv\n      );\n      const dec = decipher.update(enc) + decipher.final();\n      return dec.toString('utf8');\n    } catch (err) {\n      return ciphertext;\n    }\n  };\n  static aes_cbc_b64_encrypt = (plaintext, key) => {\n    try {\n      const h = Crypto.createHash('sha512')\n        .update(key)\n        .digest();\n      const encryptionKey = h.slice(0, 32);\n      const authenticationKey = h.slice(32, 64);\n\n      const iv = Crypto.randomBytes(16);\n      const cipher = Crypto.createCipheriv('aes-256-cbc', encryptionKey, iv);\n      const ciphertext = Buffer.concat([\n        iv,\n        cipher.update(plaintext),\n        cipher.final()\n      ]);\n      const hmac = Crypto.createHmac('sha256', authenticationKey)\n        .update(ciphertext)\n        .digest();\n      return Buffer.concat([ciphertext, hmac]).toString('base64');\n    } catch (err) {\n      return '';\n    }\n  };\n  static parseError = errObject => {\n    const errMsg = {\n      err101: 'errorNotInitialized', // No password set\n      err250: 'errorNotInitialized', // Wallet not seeded\n      err251: 'errorNotInitialized', // Wallet not seeded\n      err109: 'errorInvalidPassword' + errObject.message, // Wrong password (typically); append error message in order to parse login tries left\n      err600: 'errorUserAbort', // User aborted action\n      err601: 'errorUserTimeout' // Touch button not pressed\n    };\n    const code = 'err' + ('code' in errObject ? errObject.code.toString() : '');\n    const err = { message: errMsg[code] || 'errorUnexpected' };\n    return err;\n  };\n  static signGeneric = (self, path, chainId, hashToSign, callback) => {\n    const cmd =\n      '{\"sign\":{\"data\":[{\"hash\":\"' +\n      hashToSign +\n      '\",\"keypath\":\"' +\n      path +\n      '\"}]}}';\n    const localCallback = (response, error) => {\n      if (typeof error != 'undefined') {\n        callback(undefined, error);\n        return;\n      }\n      if ('echo' in response) {\n        self.send('{\"sign\":\"\"}', true, localCallback);\n        return;\n      }\n      if ('sign' in response) {\n        const vOffset = chainId ? chainId * 2 + 8 : 0;\n        const v = new Buffer([\n          parseInt(response.sign[0].recid, 16) + 27 + vOffset\n        ]);\n        const result = {\n          v: v.toString('hex'),\n          r: response.sign[0].sig.slice(0, 64),\n          s: response.sign[0].sig.slice(64, 128)\n        };\n        callback(result);\n        return;\n      }\n    };\n    self.send(cmd, true, localCallback);\n  };\n  constructor(comm, secret) {\n    this.comm = comm;\n    this.secret = '';\n    this.timeout = null;\n    this.secret = secret || this.secret;\n    this.key = Crypto.createHash('sha256')\n      .update(new Buffer(this.secret, 'utf8'))\n      .digest();\n    this.key = Crypto.createHash('sha256')\n      .update(this.key)\n      .digest();\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(() => {\n      this.secret = '';\n    }, 60000);\n  }\n  send(cmd, encrypt, callback) {\n    let message = '';\n    if (encrypt) message = DigitalBitboxEth.aes_cbc_b64_encrypt(cmd, this.key);\n    else message = cmd || ' '; // Need at least 1 byte length for U2F\n    this.comm.exchange(message, (response, err) => {\n      try {\n        if (typeof err !== 'undefined' || typeof response === 'undefined') {\n          // Entered on U2F timeouts\n          // Poll for the response\n          this.send('', false, callback);\n          return;\n        }\n        if (response.length == 1) {\n          if (response[0] == hijackState.processingCommand) {\n            // BitBox is processing the previous command\n            // Poll for the response\n            this.send('', false, callback);\n          }\n          return;\n        }\n        response = JSON.parse(response.toString('utf8'));\n        if ('error' in response) {\n          callback(undefined, DigitalBitboxEth.parseError(response.error));\n          return;\n        }\n\n        if ('ping' in response) {\n          if (!('device' in response)) {\n            callback(undefined, 'errorUpgradeFirmware');\n            return;\n          }\n          if (\n            semver.lt(response.device.version, BitBoxLowestSupportedVersion)\n          ) {\n            callback(undefined, 'errorUpgradeFirmware');\n            return;\n          }\n          if (semver.gte(response.device.version, BitBoxNonSupportedVersion)) {\n            callback(undefined, 'errorUnsupportedFirmware');\n            return;\n          }\n          callback(response);\n        }\n\n        if ('ciphertext' in response) {\n          response = JSON.parse(\n            DigitalBitboxEth.aes_cbc_b64_decrypt(response.ciphertext, this.key)\n          );\n          if ('error' in response) {\n            callback(undefined, DigitalBitboxEth.parseError(response.error));\n            return;\n          }\n          callback(response);\n        }\n      } catch (err) {\n        // unexpected error\n        callback(undefined, 'errorUnexpected');\n      }\n    });\n  }\n  getStarted(path, callback) {\n    // First check firmware version compatibility\n    // Get extended public key if firmware is compatible\n    // Else return an error\n    const localCallback = (response, error) => {\n      if (typeof error != 'undefined') {\n        callback(undefined, error);\n        return;\n      }\n      this.getAddress(path, callback);\n    };\n    this.send('{\"ping\":\"\"}', false, localCallback);\n  }\n  getAddress(path, callback) {\n    // Get extended public key\n    const cmd = '{\"xpub\":\"' + path + '\"}';\n    const localCallback = (response, error) => {\n      if (typeof error != 'undefined') {\n        callback(undefined, error);\n        return;\n      }\n      const hdkey = HDKey.fromExtendedKey(response.xpub);\n      const result = {\n        publicKey: hdkey.publicKey.toString('hex'),\n        chainCode: hdkey.chainCode.toString('hex')\n      };\n      callback(result);\n      return;\n    };\n    this.send(cmd, true, localCallback);\n  }\n  signTransaction(path, eTx) {\n    return new Promise((resolve, reject) => {\n      const chainId = eTx.getChainId();\n      const hashToSign = eTx.hash(false).toString('hex');\n      DigitalBitboxEth.signGeneric(\n        this,\n        path,\n        chainId,\n        hashToSign,\n        (result, error) => {\n          if (error) return reject(error);\n          resolve(result);\n        }\n      );\n    });\n  }\n  signMessage(path, messageHex) {\n    return new Promise((resolve, reject) => {\n      const hashToSign = messageHex.toString('hex');\n      DigitalBitboxEth.signGeneric(\n        this,\n        path,\n        0,\n        hashToSign,\n        (result, error) => {\n          if (error) return reject(error);\n          resolve(result);\n        }\n      );\n    });\n  }\n}\nexport default DigitalBitboxEth;\n"]}]}