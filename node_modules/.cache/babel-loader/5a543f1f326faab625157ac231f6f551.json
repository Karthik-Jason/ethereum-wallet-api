{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hybrid/MEWconnect/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hybrid/MEWconnect/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.array.find\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport MEWconnect from '@myetherwallet/mewconnect-web-client';\nimport store from '@/store';\nimport { Transaction } from 'ethereumjs-tx';\nimport WalletInterface from '@/wallets/WalletInterface';\nimport { MEW_CONNECT as mewConnectType } from \"../../bip44/walletTypes\";\nimport { getSignTransactionObject, sanitizeHex, getBufferFromHex, calculateChainIdFromV } from \"../../utils\";\nimport { hashPersonalMessage, toBuffer } from 'ethereumjs-util';\nimport errorHandler from \"./errorHandler\";\nimport commonGenerator from '@/helpers/commonGenerator';\nvar SIGNALER_URL = 'https://connect.mewapi.io';\nvar IS_HARDWARE = true; // TODO: add listener and ui notification on RtcConnectedEvent and RtcClosedEvent\n\nvar MEWconnectWalletInterface =\n/*#__PURE__*/\nfunction (_WalletInterface) {\n  _inherits(MEWconnectWalletInterface, _WalletInterface);\n\n  function MEWconnectWalletInterface(pubkey, isHardware, identifier, txSigner, msgSigner, mewConnect) {\n    var _this;\n\n    _classCallCheck(this, MEWconnectWalletInterface);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MEWconnectWalletInterface).call(this, pubkey, true, identifier));\n    _this.errorHandler = errorHandler;\n    _this.txSigner = txSigner;\n    _this.msgSigner = msgSigner;\n    _this.isHardware = isHardware;\n    _this.mewConnect = mewConnect;\n    return _this;\n  }\n\n  _createClass(MEWconnectWalletInterface, [{\n    key: \"getConnection\",\n    value: function getConnection() {\n      return this.mewConnect;\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(txParams) {\n      return _get(_getPrototypeOf(MEWconnectWalletInterface.prototype), \"signTransaction\", this).call(this, txParams, this.txSigner);\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(msg) {\n      return _get(_getPrototypeOf(MEWconnectWalletInterface.prototype), \"signMessage\", this).call(this, msg, this.msgSigner);\n    }\n  }]);\n\n  return MEWconnectWalletInterface;\n}(WalletInterface);\n\nvar MEWconnectWallet =\n/*#__PURE__*/\nfunction () {\n  function MEWconnectWallet() {\n    _classCallCheck(this, MEWconnectWallet);\n\n    this.identifier = mewConnectType;\n    this.isHardware = IS_HARDWARE;\n    this.mewConnect = new MEWconnect.Initiator();\n  }\n\n  _createClass(MEWconnectWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(qrcode) {\n        var _this2 = this;\n\n        var txSigner, msgSigner, mewConnect, address;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.mewConnect.on('codeDisplay', qrcode);\n\n                txSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee(tx) {\n                    var tokenInfo, networkId;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (tx.data.slice(0, 10) === '0xa9059cbb') {\n                              tokenInfo = store.state.network.type.tokens.find(function (entry) {\n                                return entry.address.toLowerCase() === tx.to.toLowerCase();\n                              });\n\n                              if (tokenInfo) {\n                                tx.currency = {\n                                  symbol: tokenInfo.symbol,\n                                  decimals: tokenInfo.decimals,\n                                  address: tokenInfo.address\n                                };\n                              }\n                            }\n\n                            networkId = tx.chainId;\n                            return _context.abrupt(\"return\", new Promise(function (resolve) {\n                              _this2.mewConnect.sendRtcMessage('signTx', JSON.stringify(tx));\n\n                              _this2.mewConnect.once('signTx', function (result) {\n                                tx = new Transaction(sanitizeHex(result), {\n                                  common: commonGenerator(store.state.network)\n                                });\n                                var signedChainId = calculateChainIdFromV(tx.v);\n                                if (signedChainId !== networkId) throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n                                resolve(getSignTransactionObject(tx));\n                              });\n                            }));\n\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function txSigner(_x2) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                msgSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee2(msg) {\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                              var msgHash = hashPersonalMessage(toBuffer(msg));\n\n                              _this2.mewConnect.sendRtcMessage('signMessage', {\n                                hash: msgHash.toString('hex'),\n                                text: msg\n                              });\n\n                              _this2.mewConnect.once('signMessage', function (data) {\n                                resolve(getBufferFromHex(sanitizeHex(data.sig)));\n                              });\n                            }));\n\n                          case 1:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function msgSigner(_x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                mewConnect = function mewConnect() {\n                  return _this2.mewConnect;\n                };\n\n                _context3.next = 6;\n                return signalerConnect(SIGNALER_URL, this.mewConnect);\n\n              case 6:\n                address = _context3.sent;\n                return _context3.abrupt(\"return\", new MEWconnectWalletInterface(sanitizeHex(address), this.isHardware, this.identifier, txSigner, msgSigner, mewConnect // <- using this.mewConnect here was causing a circular reference and data clone error\n                ));\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }]);\n\n  return MEWconnectWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee4(qrcode) {\n    var _MEWconnectWallet, _tWallet;\n\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _MEWconnectWallet = new MEWconnectWallet();\n            _context4.next = 3;\n            return _MEWconnectWallet.init(qrcode);\n\n          case 3:\n            _tWallet = _context4.sent;\n            return _context4.abrupt(\"return\", _tWallet);\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function createWallet(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\n\nvar signalerConnect = function signalerConnect(url, mewConnect) {\n  return new Promise(function (resolve) {\n    mewConnect.initiatorStart(url);\n    mewConnect.on('RtcConnectedEvent', function () {\n      mewConnect.sendRtcMessage('address', '');\n      mewConnect.once('address', function (data) {\n        resolve(data.address);\n      });\n    });\n  });\n};\n\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hybrid/MEWconnect/index.js"],"names":["MEWconnect","store","Transaction","WalletInterface","MEW_CONNECT","mewConnectType","getSignTransactionObject","sanitizeHex","getBufferFromHex","calculateChainIdFromV","hashPersonalMessage","toBuffer","errorHandler","commonGenerator","SIGNALER_URL","IS_HARDWARE","MEWconnectWalletInterface","pubkey","isHardware","identifier","txSigner","msgSigner","mewConnect","txParams","msg","MEWconnectWallet","Initiator","qrcode","on","tx","data","slice","tokenInfo","state","network","type","tokens","find","entry","address","toLowerCase","to","currency","symbol","decimals","networkId","chainId","Promise","resolve","sendRtcMessage","JSON","stringify","once","result","common","signedChainId","v","Error","msgHash","hash","toString","text","sig","signalerConnect","createWallet","_MEWconnectWallet","init","_tWallet","url","initiatorStart"],"mappings":"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","sourcesContent":["import MEWconnect from '@myetherwallet/mewconnect-web-client';\nimport store from '@/store';\nimport { Transaction } from 'ethereumjs-tx';\nimport WalletInterface from '@/wallets/WalletInterface';\nimport { MEW_CONNECT as mewConnectType } from '../../bip44/walletTypes';\nimport {\n  getSignTransactionObject,\n  sanitizeHex,\n  getBufferFromHex,\n  calculateChainIdFromV\n} from '../../utils';\nimport { hashPersonalMessage, toBuffer } from 'ethereumjs-util';\nimport errorHandler from './errorHandler';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nconst SIGNALER_URL = 'https://connect.mewapi.io';\nconst IS_HARDWARE = true;\n\n// TODO: add listener and ui notification on RtcConnectedEvent and RtcClosedEvent\nclass MEWconnectWalletInterface extends WalletInterface {\n  constructor(pubkey, isHardware, identifier, txSigner, msgSigner, mewConnect) {\n    super(pubkey, true, identifier);\n    this.errorHandler = errorHandler;\n    this.txSigner = txSigner;\n    this.msgSigner = msgSigner;\n    this.isHardware = isHardware;\n    this.mewConnect = mewConnect;\n  }\n  getConnection() {\n    return this.mewConnect;\n  }\n  signTransaction(txParams) {\n    return super.signTransaction(txParams, this.txSigner);\n  }\n  signMessage(msg) {\n    return super.signMessage(msg, this.msgSigner);\n  }\n}\n\nclass MEWconnectWallet {\n  constructor() {\n    this.identifier = mewConnectType;\n    this.isHardware = IS_HARDWARE;\n    this.mewConnect = new MEWconnect.Initiator();\n  }\n  async init(qrcode) {\n    this.mewConnect.on('codeDisplay', qrcode);\n    const txSigner = async tx => {\n      let tokenInfo;\n      if (tx.data.slice(0, 10) === '0xa9059cbb') {\n        tokenInfo = store.state.network.type.tokens.find(\n          entry => entry.address.toLowerCase() === tx.to.toLowerCase()\n        );\n        if (tokenInfo) {\n          tx.currency = {\n            symbol: tokenInfo.symbol,\n            decimals: tokenInfo.decimals,\n            address: tokenInfo.address\n          };\n        }\n      }\n      const networkId = tx.chainId;\n      return new Promise(resolve => {\n        this.mewConnect.sendRtcMessage('signTx', JSON.stringify(tx));\n        this.mewConnect.once('signTx', result => {\n          tx = new Transaction(sanitizeHex(result), {\n            common: commonGenerator(store.state.network)\n          });\n          const signedChainId = calculateChainIdFromV(tx.v);\n          if (signedChainId !== networkId)\n            throw new Error(\n              'Invalid networkId signature returned. Expected: ' +\n                networkId +\n                ', Got: ' +\n                signedChainId,\n              'InvalidNetworkId'\n            );\n          resolve(getSignTransactionObject(tx));\n        });\n      });\n    };\n    const msgSigner = async msg => {\n      return new Promise(resolve => {\n        const msgHash = hashPersonalMessage(toBuffer(msg));\n        this.mewConnect.sendRtcMessage('signMessage', {\n          hash: msgHash.toString('hex'),\n          text: msg\n        });\n        this.mewConnect.once('signMessage', data => {\n          resolve(getBufferFromHex(sanitizeHex(data.sig)));\n        });\n      });\n    };\n\n    const mewConnect = () => {\n      return this.mewConnect;\n    };\n    const address = await signalerConnect(SIGNALER_URL, this.mewConnect);\n\n    return new MEWconnectWalletInterface(\n      sanitizeHex(address),\n      this.isHardware,\n      this.identifier,\n      txSigner,\n      msgSigner,\n      mewConnect // <- using this.mewConnect here was causing a circular reference and data clone error\n    );\n  }\n}\nconst createWallet = async qrcode => {\n  const _MEWconnectWallet = new MEWconnectWallet();\n  const _tWallet = await _MEWconnectWallet.init(qrcode);\n  return _tWallet;\n};\ncreateWallet.errorHandler = errorHandler;\nconst signalerConnect = (url, mewConnect) => {\n  return new Promise(resolve => {\n    mewConnect.initiatorStart(url);\n    mewConnect.on('RtcConnectedEvent', () => {\n      mewConnect.sendRtcMessage('address', '');\n      mewConnect.once('address', data => {\n        resolve(data.address);\n      });\n    });\n  });\n};\n\nexport default createWallet;\n"]}]}