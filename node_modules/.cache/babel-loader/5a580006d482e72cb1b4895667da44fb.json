{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/keepkey/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/keepkey/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport _slicedToArray from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { WebUSBDevice, Messages, KeepKey, bip32ToAddressNList } from '@keepkey/keepkey.js';\nimport { KEEPKEY as keepkeyType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { getUint8Tx } from \"./utils\";\nimport { getBufferFromHex, sanitizeHex, getSignTransactionObject, calculateChainIdFromV } from \"../../utils\";\nimport HDKey from 'hdkey';\nimport { toBuffer } from 'ethereumjs-util';\nimport { Transaction } from 'ethereumjs-tx';\nimport errorHandler from \"./errorHandler\";\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nvar MessageType = Messages.MessageType;\nvar MESSAGETYPE_PINMATRIXREQUEST = MessageType.MESSAGETYPE_PINMATRIXREQUEST,\n    MESSAGETYPE_PASSPHRASEREQUEST = MessageType.MESSAGETYPE_PASSPHRASEREQUEST;\nvar NEED_PASSWORD = false;\n\nvar KeepkeyWallet =\n/*#__PURE__*/\nfunction () {\n  function KeepkeyWallet(eventHub) {\n    _classCallCheck(this, KeepkeyWallet);\n\n    this.identifier = keepkeyType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.eventHub = eventHub;\n    this.supportedPaths = bip44Paths[keepkeyType];\n  }\n\n  _createClass(KeepkeyWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        var _this = this;\n\n        var usbDevice, device, rootPub;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                this.isHardened = this.basePath.split('/').length - 1 === 2;\n                _context.next = 4;\n                return WebUSBDevice.requestPair();\n\n              case 4:\n                usbDevice = _context.sent;\n                device = new WebUSBDevice({\n                  usbDevice: usbDevice\n                });\n                this.keepkey = KeepKey.withWebUSB(device);\n                this.keepkey.device.events.on(String(MESSAGETYPE_PINMATRIXREQUEST), function () {\n                  _this.eventHub.$emit('showHardwarePinMatrix', {\n                    name: _this.identifier\n                  }, function (pin) {\n                    _this.keepkey.acknowledgeWithPin(pin).catch(errorHandler);\n                  });\n                });\n                this.keepkey.device.events.on(String(MESSAGETYPE_PASSPHRASEREQUEST), function () {\n                  _this.eventHub.$emit('showHardwarePassword', {\n                    name: _this.identifier\n                  }, function (passPhrase) {\n                    _this.keepkey.acknowledgeWithPassphrase(passPhrase).catch(errorHandler);\n                  });\n                });\n                _context.next = 11;\n                return this.keepkey.initialize();\n\n              case 11:\n                if (this.isHardened) {\n                  _context.next = 20;\n                  break;\n                }\n\n                _context.next = 14;\n                return getRootPubKey(this.keepkey, this.basePath);\n\n              case 14:\n                rootPub = _context.sent;\n                this.hdKey = new HDKey();\n                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n                _context.next = 22;\n                break;\n\n              case 20:\n                _context.next = 22;\n                return getRootPubKey(this.keepkey, this.basePath + '/0 ');\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5(idx) {\n        var _this2 = this;\n\n        var derivedKey, accountPath, rootPub, hdKey, txSigner, msgSigner, displayAddress;\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this.isHardened) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                _context5.next = 3;\n                return getRootPubKey(this.keepkey, this.basePath + '/' + idx + \"'\");\n\n              case 3:\n                rootPub = _context5.sent;\n                hdKey = new HDKey();\n                hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n                derivedKey = hdKey.derive('m/0/0');\n                accountPath = this.basePath + '/' + idx + \"'\" + '/0/0';\n                _context5.next = 13;\n                break;\n\n              case 11:\n                derivedKey = this.hdKey.derive('m/' + idx);\n                accountPath = this.basePath + '/' + idx;\n\n              case 13:\n                txSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee2(tx) {\n                    var hexTx, networkId, result, signedChainId;\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            tx = new Transaction(tx, {\n                              common: commonGenerator(store.state.network)\n                            });\n                            hexTx = getUint8Tx(tx);\n                            networkId = tx.getChainId();\n                            hexTx.addressNList = bip32ToAddressNList(accountPath);\n                            _context2.next = 6;\n                            return _this2.keepkey.ethereumSignTx(hexTx, null, null, hexTx.data, networkId);\n\n                          case 6:\n                            result = _context2.sent;\n                            tx.v = getBufferFromHex(sanitizeHex(result.v));\n                            tx.r = getBufferFromHex(sanitizeHex(result.r));\n                            tx.s = getBufferFromHex(sanitizeHex(result.s));\n                            signedChainId = calculateChainIdFromV(tx.v);\n\n                            if (!(signedChainId !== networkId)) {\n                              _context2.next = 13;\n                              break;\n                            }\n\n                            throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n\n                          case 13:\n                            return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                          case 14:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function txSigner(_x3) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                msgSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee3(msg) {\n                    var signMessage, _ref3, _ref4, response;\n\n                    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            signMessage = new Messages.EthereumSignMessage();\n                            signMessage.setAddressNList(bip32ToAddressNList(accountPath));\n                            signMessage.setMessage(new Uint8Array(toBuffer(msg)));\n                            _context3.next = 5;\n                            return _this2.keepkey.device.exchange(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, signMessage);\n\n                          case 5:\n                            _ref3 = _context3.sent;\n                            _ref4 = _slicedToArray(_ref3, 2);\n                            response = _ref4[1];\n                            return _context3.abrupt(\"return\", Buffer.from(response.toObject().signature, 'base64'));\n\n                          case 9:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function msgSigner(_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                displayAddress =\n                /*#__PURE__*/\n                function () {\n                  var _ref5 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee4() {\n                    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _this2.keepkey.ethereumGetAddress({\n                              addressNList: bip32ToAddressNList(accountPath),\n                              showDisplay: true\n                            });\n\n                          case 2:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function displayAddress() {\n                    return _ref5.apply(this, arguments);\n                  };\n                }();\n\n                return _context5.abrupt(\"return\", new HDWalletInterface(accountPath, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, displayAddress));\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x2) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return KeepkeyWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee6(basePath, eventHub) {\n    var _keepkeyWallet;\n\n    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _keepkeyWallet = new KeepkeyWallet(eventHub);\n            _context6.next = 3;\n            return _keepkeyWallet.init(basePath);\n\n          case 3:\n            return _context6.abrupt(\"return\", _keepkeyWallet);\n\n          case 4:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function createWallet(_x5, _x6) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\n\nvar getRootPubKey =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee7(_keepkey, _path) {\n    var pubObj, hdkey;\n    return regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return _keepkey.getPublicKey({\n              addressNList: bip32ToAddressNList(_path),\n              showDisplay: false\n            });\n\n          case 2:\n            pubObj = _context7.sent;\n            hdkey = HDKey.fromExtendedKey(pubObj[1]);\n            return _context7.abrupt(\"return\", {\n              publicKey: hdkey.publicKey.toString('hex'),\n              chainCode: hdkey.chainCode.toString('hex')\n            });\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n\n  return function getRootPubKey(_x7, _x8) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/keepkey/index.js"],"names":["WebUSBDevice","Messages","KeepKey","bip32ToAddressNList","KEEPKEY","keepkeyType","bip44Paths","HDWalletInterface","getUint8Tx","getBufferFromHex","sanitizeHex","getSignTransactionObject","calculateChainIdFromV","HDKey","toBuffer","Transaction","errorHandler","store","commonGenerator","MessageType","MESSAGETYPE_PINMATRIXREQUEST","MESSAGETYPE_PASSPHRASEREQUEST","NEED_PASSWORD","KeepkeyWallet","eventHub","identifier","isHardware","needPassword","supportedPaths","basePath","path","isHardened","split","length","requestPair","usbDevice","device","keepkey","withWebUSB","events","on","String","$emit","name","pin","acknowledgeWithPin","catch","passPhrase","acknowledgeWithPassphrase","initialize","getRootPubKey","rootPub","hdKey","publicKey","Buffer","from","chainCode","idx","derivedKey","derive","accountPath","txSigner","tx","common","state","network","hexTx","networkId","getChainId","addressNList","ethereumSignTx","data","result","v","r","s","signedChainId","Error","msgSigner","msg","signMessage","EthereumSignMessage","setAddressNList","setMessage","Uint8Array","exchange","MESSAGETYPE_ETHEREUMSIGNMESSAGE","response","toObject","signature","displayAddress","ethereumGetAddress","showDisplay","createWallet","_keepkeyWallet","init","_keepkey","_path","getPublicKey","pubObj","hdkey","fromExtendedKey","toString"],"mappings":"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","sourcesContent":["import {\n  WebUSBDevice,\n  Messages,\n  KeepKey,\n  bip32ToAddressNList\n} from '@keepkey/keepkey.js';\nimport { KEEPKEY as keepkeyType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { getUint8Tx } from './utils';\nimport {\n  getBufferFromHex,\n  sanitizeHex,\n  getSignTransactionObject,\n  calculateChainIdFromV\n} from '../../utils';\nimport HDKey from 'hdkey';\nimport { toBuffer } from 'ethereumjs-util';\nimport { Transaction } from 'ethereumjs-tx';\nimport errorHandler from './errorHandler';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nconst { MessageType } = Messages;\nconst {\n  MESSAGETYPE_PINMATRIXREQUEST,\n  MESSAGETYPE_PASSPHRASEREQUEST\n} = MessageType;\n\nconst NEED_PASSWORD = false;\n\nclass KeepkeyWallet {\n  constructor(eventHub) {\n    this.identifier = keepkeyType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.eventHub = eventHub;\n    this.supportedPaths = bip44Paths[keepkeyType];\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    this.isHardened = this.basePath.split('/').length - 1 === 2;\n    const usbDevice = await WebUSBDevice.requestPair();\n    const device = new WebUSBDevice({ usbDevice });\n    this.keepkey = KeepKey.withWebUSB(device);\n    this.keepkey.device.events.on(String(MESSAGETYPE_PINMATRIXREQUEST), () => {\n      this.eventHub.$emit(\n        'showHardwarePinMatrix',\n        { name: this.identifier },\n        pin => {\n          this.keepkey.acknowledgeWithPin(pin).catch(errorHandler);\n        }\n      );\n    });\n    this.keepkey.device.events.on(String(MESSAGETYPE_PASSPHRASEREQUEST), () => {\n      this.eventHub.$emit(\n        'showHardwarePassword',\n        { name: this.identifier },\n        passPhrase => {\n          this.keepkey\n            .acknowledgeWithPassphrase(passPhrase)\n            .catch(errorHandler);\n        }\n      );\n    });\n    await this.keepkey.initialize();\n    if (!this.isHardened) {\n      const rootPub = await getRootPubKey(this.keepkey, this.basePath);\n      this.hdKey = new HDKey();\n      this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n      this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n    } else {\n      await getRootPubKey(this.keepkey, this.basePath + '/0 ');\n    }\n  }\n  async getAccount(idx) {\n    let derivedKey, accountPath;\n    if (this.isHardened) {\n      const rootPub = await getRootPubKey(\n        this.keepkey,\n        this.basePath + '/' + idx + \"'\"\n      );\n      const hdKey = new HDKey();\n      hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n      hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n      derivedKey = hdKey.derive('m/0/0');\n      accountPath = this.basePath + '/' + idx + \"'\" + '/0/0';\n    } else {\n      derivedKey = this.hdKey.derive('m/' + idx);\n      accountPath = this.basePath + '/' + idx;\n    }\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const hexTx = getUint8Tx(tx);\n      const networkId = tx.getChainId();\n      hexTx.addressNList = bip32ToAddressNList(accountPath);\n      const result = await this.keepkey.ethereumSignTx(\n        hexTx,\n        null,\n        null,\n        hexTx.data,\n        networkId\n      );\n      tx.v = getBufferFromHex(sanitizeHex(result.v));\n      tx.r = getBufferFromHex(sanitizeHex(result.r));\n      tx.s = getBufferFromHex(sanitizeHex(result.s));\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        throw new Error(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const signMessage = new Messages.EthereumSignMessage();\n      signMessage.setAddressNList(bip32ToAddressNList(accountPath));\n      signMessage.setMessage(new Uint8Array(toBuffer(msg)));\n      const [, response] = await this.keepkey.device.exchange(\n        Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE,\n        signMessage\n      );\n      return Buffer.from(response.toObject().signature, 'base64');\n    };\n    const displayAddress = async () => {\n      await this.keepkey.ethereumGetAddress({\n        addressNList: bip32ToAddressNList(accountPath),\n        showDisplay: true\n      });\n    };\n    return new HDWalletInterface(\n      accountPath,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      displayAddress\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst createWallet = async (basePath, eventHub) => {\n  const _keepkeyWallet = new KeepkeyWallet(eventHub);\n  await _keepkeyWallet.init(basePath);\n  return _keepkeyWallet;\n};\n\ncreateWallet.errorHandler = errorHandler;\n\nconst getRootPubKey = async (_keepkey, _path) => {\n  const pubObj = await _keepkey.getPublicKey({\n    addressNList: bip32ToAddressNList(_path),\n    showDisplay: false\n  });\n  const hdkey = HDKey.fromExtendedKey(pubObj[1]);\n  return {\n    publicKey: hdkey.publicKey.toString('hex'),\n    chainCode: hdkey.chainCode.toString('hex')\n  };\n};\n\nexport default createWallet;\n"]}]}