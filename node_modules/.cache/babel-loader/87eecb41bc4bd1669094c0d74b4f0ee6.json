{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/thread-loader/dist/cjs.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/secalot/secalotEth.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/secalot/secalotEth.js","mtime":1574664278326},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/thread-loader/dist/cjs.js","mtime":1574664277654},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js","mtime":1574664275010},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js","mtime":1574664275986}],"contextDependencies":[],"result":["'use strict';\n\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.split\";\nimport { toBuffer, stripZeros, rlp } from 'ethereumjs-util';\n\nvar SecalotEth = function SecalotEth(comm, pinCode) {\n  this.comm = comm;\n  if (typeof pinCode !== 'undefined') this.pinCode = pinCode;\n};\n\nSecalotEth.splitPath = function (path) {\n  var result = [];\n  var components = path.split('/');\n  components.forEach(function (element) {\n    var number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return;\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n};\n\nSecalotEth.getErrorMessage = function (sw, operation) {\n  var errorMessage;\n\n  if (sw === 0x6d00) {\n    errorMessage = 'Ethereum wallet on your Secalot is not initialized.';\n  } else if (sw === 0x6982) {\n    if (operation === 'getPublicKey') {\n      errorMessage = 'Invalid PIN-code. Be careful, after entering a wrong PIN-code three times in a row, your Secalot Ethereum wallet would be permanently wiped.';\n    } else {\n      errorMessage = 'PIN-code not verified.';\n    }\n  } else if (sw === 0x6700) {\n    errorMessage = 'Invalid PIN-code length.';\n  } else if (sw === 0x6985) {\n    errorMessage = 'Operation timed out.';\n  } else {\n    errorMessage = 'An error has occurred. SW = ' + sw.toString(16) + '.';\n  }\n\n  return errorMessage;\n};\n\nSecalotEth.prototype.getAddress = function (path, callback) {\n  var splitPath = SecalotEth.splitPath(path);\n  var apdus = [];\n  var buffer;\n  var self = this;\n\n  var localCallback = function localCallback(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      var result = {};\n      response = Buffer.from(response, 'hex');\n      var sw = response.readUInt16BE(response.length - 2);\n\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'getPublicKey'));\n        return;\n      }\n\n      if (apdus.length === 0) {\n        result['publicKey'] = response.slice(0, 65).toString('hex');\n        result['chainCode'] = response.slice(65, 97).toString('hex');\n        callback(result);\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n\n  buffer = Buffer.alloc(4);\n  buffer[0] = 0x80;\n  buffer[1] = 0xc4;\n  buffer[2] = 0x00;\n  buffer[3] = 0x00;\n  apdus.push(buffer.toString('hex'));\n\n  if (typeof this.pinCode !== 'undefined') {\n    var pin = Buffer.from(this.pinCode, 'utf8');\n    buffer = Buffer.alloc(5 + pin.length);\n    buffer[0] = 0x80;\n    buffer[1] = 0x22;\n    buffer[2] = 0x00;\n    buffer[3] = 0x00;\n    buffer[4] = pin.length;\n    pin.copy(buffer, 5, 0, pin.length);\n    apdus.push(buffer.toString('hex'));\n  }\n\n  buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n  buffer[0] = 0x80;\n  buffer[1] = 0x40;\n  buffer[2] = 0x00;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n  splitPath.forEach(function (element, idx) {\n    buffer.writeUInt32BE(element, 6 + 4 * idx);\n  });\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\n\nSecalotEth.prototype.signTransactionAsync = function (path, eTx) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    _this.signTransaction(path, eTx, function (result, error) {\n      if (error) return reject(error);\n      resolve(result);\n    });\n  });\n};\n\nSecalotEth.prototype.signTransaction = function (path, eTx, callback) {\n  var chainID = eTx.getChainId();\n  var splitPath = SecalotEth.splitPath(path);\n  var offset = 0;\n  var rawData = '';\n  var apdus = [];\n  var self = this;\n\n  var localCallback = function localCallback(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      response = Buffer.from(response, 'hex');\n      var sw = response.readUInt16BE(response.length - 2);\n\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'signTransaction'));\n        return;\n      }\n\n      if (apdus.length === 0) {\n        var result = {};\n        var v = response[0] + 27;\n\n        if (chainID > 0) {\n          v += chainID * 2 + 8;\n        }\n\n        result['v'] = Buffer.from([v]).toString('hex');\n        result['r'] = response.slice(1, 1 + 32).toString('hex');\n        result['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');\n        callback(result);\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n\n  var items = eTx.raw.slice(0, 6).concat([toBuffer(chainID), stripZeros(toBuffer(0)), stripZeros(toBuffer(0))]);\n  var dataToHash = rlp.encode(items);\n  rawData = Buffer.from(dataToHash, 'hex');\n\n  while (offset !== rawData.length) {\n    var maxChunkSize = 64;\n    var chunkSize = offset + maxChunkSize > rawData.length ? rawData.length - offset : maxChunkSize;\n\n    var _buffer = Buffer.alloc(5 + chunkSize);\n\n    _buffer[0] = 0x80;\n    _buffer[1] = 0xf2;\n    _buffer[2] = offset === 0 ? 0x00 : 0x01;\n    _buffer[3] = 0x00;\n    _buffer[4] = chunkSize;\n    rawData.copy(_buffer, 5, offset, offset + chunkSize);\n    apdus.push(_buffer.toString('hex'));\n    offset += chunkSize;\n  }\n\n  var buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n  buffer[0] = 0x80;\n  buffer[1] = 0xf2;\n  buffer[2] = 0x02;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n  splitPath.forEach(function (element, index) {\n    buffer.writeUInt32BE(element, 6 + 4 * index);\n  });\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\n\nSecalotEth.prototype.signMessageAsync = function (path, message) {\n  var _this2 = this;\n\n  return new Promise(function (resolve, reject) {\n    _this2.signMessage(path, message, function (result, error) {\n      if (error) return reject(error);\n      resolve(result);\n    });\n  });\n};\n\nSecalotEth.prototype.signMessage = function (path, message, callback) {\n  var splitPath = SecalotEth.splitPath(path);\n  var offset = 0;\n  var rawData = '';\n  var apdus = [];\n  var self = this;\n\n  var localCallback = function localCallback(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      response = Buffer.from(response, 'hex');\n      var sw = response.readUInt16BE(response.length - 2);\n\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'signMessage'));\n        return;\n      }\n\n      if (apdus.length === 0) {\n        var obj = {};\n        var v = response[0] + 27;\n        obj['v'] = Buffer.from([v]).toString('hex');\n        obj['r'] = response.slice(1, 1 + 32).toString('hex');\n        obj['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');\n        var result = obj['r'] + obj['s'] + obj['v'];\n        callback('0x' + result.toString('hex'));\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n\n  message = toBuffer(message);\n  var prefix = '\\x19Ethereum Signed Message:\\n' + message.length.toString();\n  rawData = Buffer.concat([toBuffer(prefix), message]);\n\n  while (offset !== rawData.length) {\n    var maxChunkSize = 64;\n    var chunkSize = offset + maxChunkSize > rawData.length ? rawData.length - offset : maxChunkSize;\n\n    var _buffer2 = Buffer.alloc(5 + chunkSize);\n\n    _buffer2[0] = 0x80;\n    _buffer2[1] = 0xf2;\n    _buffer2[2] = offset === 0 ? 0x00 : 0x01;\n    _buffer2[3] = offset === 0 ? 0x01 : 0x00;\n    _buffer2[4] = chunkSize;\n    rawData.copy(_buffer2, 5, offset, offset + chunkSize);\n    apdus.push(_buffer2.toString('hex'));\n    offset += chunkSize;\n  }\n\n  var buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n  buffer[0] = 0x80;\n  buffer[1] = 0xf2;\n  buffer[2] = 0x02;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n  splitPath.forEach(function (element, idx) {\n    buffer.writeUInt32BE(element, 6 + 4 * idx);\n  });\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\n\nexport default SecalotEth;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/hardware/secalot/secalotEth.js"],"names":["toBuffer","stripZeros","rlp","SecalotEth","comm","pinCode","splitPath","path","result","components","split","forEach","element","number","parseInt","isNaN","length","push","getErrorMessage","sw","operation","errorMessage","toString","prototype","getAddress","callback","apdus","buffer","self","localCallback","response","error","undefined","Buffer","from","readUInt16BE","slice","exchange","shift","alloc","pin","copy","idx","writeUInt32BE","signTransactionAsync","eTx","Promise","resolve","reject","signTransaction","chainID","getChainId","offset","rawData","v","items","raw","concat","dataToHash","encode","maxChunkSize","chunkSize","index","signMessageAsync","message","signMessage","obj","prefix"],"mappings":"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","sourcesContent":["'use strict';\nimport { toBuffer, stripZeros, rlp } from 'ethereumjs-util';\n\nconst SecalotEth = function(comm, pinCode) {\n  this.comm = comm;\n  if (typeof pinCode !== 'undefined') this.pinCode = pinCode;\n};\n\nSecalotEth.splitPath = function(path) {\n  const result = [];\n  const components = path.split('/');\n\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return;\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n};\n\nSecalotEth.getErrorMessage = function(sw, operation) {\n  let errorMessage;\n  if (sw === 0x6d00) {\n    errorMessage = 'Ethereum wallet on your Secalot is not initialized.';\n  } else if (sw === 0x6982) {\n    if (operation === 'getPublicKey') {\n      errorMessage =\n        'Invalid PIN-code. Be careful, after entering a wrong PIN-code three times in a row, your Secalot Ethereum wallet would be permanently wiped.';\n    } else {\n      errorMessage = 'PIN-code not verified.';\n    }\n  } else if (sw === 0x6700) {\n    errorMessage = 'Invalid PIN-code length.';\n  } else if (sw === 0x6985) {\n    errorMessage = 'Operation timed out.';\n  } else {\n    errorMessage = 'An error has occurred. SW = ' + sw.toString(16) + '.';\n  }\n\n  return errorMessage;\n};\n\nSecalotEth.prototype.getAddress = function(path, callback) {\n  const splitPath = SecalotEth.splitPath(path);\n  const apdus = [];\n  let buffer;\n  const self = this;\n  const localCallback = function(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      const result = {};\n      response = Buffer.from(response, 'hex');\n      const sw = response.readUInt16BE(response.length - 2);\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'getPublicKey'));\n        return;\n      }\n      if (apdus.length === 0) {\n        result['publicKey'] = response.slice(0, 65).toString('hex');\n        result['chainCode'] = response.slice(65, 97).toString('hex');\n        callback(result);\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n\n  buffer = Buffer.alloc(4);\n  buffer[0] = 0x80;\n  buffer[1] = 0xc4;\n  buffer[2] = 0x00;\n  buffer[3] = 0x00;\n\n  apdus.push(buffer.toString('hex'));\n\n  if (typeof this.pinCode !== 'undefined') {\n    const pin = Buffer.from(this.pinCode, 'utf8');\n    buffer = Buffer.alloc(5 + pin.length);\n    buffer[0] = 0x80;\n    buffer[1] = 0x22;\n    buffer[2] = 0x00;\n    buffer[3] = 0x00;\n    buffer[4] = pin.length;\n\n    pin.copy(buffer, 5, 0, pin.length);\n    apdus.push(buffer.toString('hex'));\n  }\n\n  buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n  buffer[0] = 0x80;\n  buffer[1] = 0x40;\n  buffer[2] = 0x00;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n  splitPath.forEach((element, idx) => {\n    buffer.writeUInt32BE(element, 6 + 4 * idx);\n  });\n\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\nSecalotEth.prototype.signTransactionAsync = function(path, eTx) {\n  return new Promise((resolve, reject) => {\n    this.signTransaction(path, eTx, (result, error) => {\n      if (error) return reject(error);\n      resolve(result);\n    });\n  });\n};\nSecalotEth.prototype.signTransaction = function(path, eTx, callback) {\n  const chainID = eTx.getChainId();\n  const splitPath = SecalotEth.splitPath(path);\n  let offset = 0;\n  let rawData = '';\n  const apdus = [];\n  const self = this;\n  const localCallback = function(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      response = Buffer.from(response, 'hex');\n      const sw = response.readUInt16BE(response.length - 2);\n\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'signTransaction'));\n        return;\n      }\n\n      if (apdus.length === 0) {\n        const result = {};\n        let v = response[0] + 27;\n\n        if (chainID > 0) {\n          v += chainID * 2 + 8;\n        }\n\n        result['v'] = Buffer.from([v]).toString('hex');\n        result['r'] = response.slice(1, 1 + 32).toString('hex');\n        result['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');\n        callback(result);\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n\n  const items = eTx.raw\n    .slice(0, 6)\n    .concat([\n      toBuffer(chainID),\n      stripZeros(toBuffer(0)),\n      stripZeros(toBuffer(0))\n    ]);\n\n  const dataToHash = rlp.encode(items);\n\n  rawData = Buffer.from(dataToHash, 'hex');\n\n  while (offset !== rawData.length) {\n    const maxChunkSize = 64;\n    const chunkSize =\n      offset + maxChunkSize > rawData.length\n        ? rawData.length - offset\n        : maxChunkSize;\n    const buffer = Buffer.alloc(5 + chunkSize);\n\n    buffer[0] = 0x80;\n    buffer[1] = 0xf2;\n    buffer[2] = offset === 0 ? 0x00 : 0x01;\n    buffer[3] = 0x00;\n    buffer[4] = chunkSize;\n\n    rawData.copy(buffer, 5, offset, offset + chunkSize);\n    apdus.push(buffer.toString('hex'));\n    offset += chunkSize;\n  }\n\n  const buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n\n  buffer[0] = 0x80;\n  buffer[1] = 0xf2;\n  buffer[2] = 0x02;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n\n  splitPath.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 6 + 4 * index);\n  });\n\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\nSecalotEth.prototype.signMessageAsync = function(path, message) {\n  return new Promise((resolve, reject) => {\n    this.signMessage(path, message, (result, error) => {\n      if (error) return reject(error);\n      resolve(result);\n    });\n  });\n};\nSecalotEth.prototype.signMessage = function(path, message, callback) {\n  const splitPath = SecalotEth.splitPath(path);\n  let offset = 0;\n  let rawData = '';\n  const apdus = [];\n  const self = this;\n  const localCallback = function(response, error) {\n    if (typeof error !== 'undefined') {\n      callback(undefined, error);\n    } else {\n      response = Buffer.from(response, 'hex');\n      const sw = response.readUInt16BE(response.length - 2);\n      if (sw !== 0x9000) {\n        callback(undefined, SecalotEth.getErrorMessage(sw, 'signMessage'));\n        return;\n      }\n      if (apdus.length === 0) {\n        const obj = {};\n        const v = response[0] + 27;\n        obj['v'] = Buffer.from([v]).toString('hex');\n        obj['r'] = response.slice(1, 1 + 32).toString('hex');\n        obj['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');\n        const result = obj['r'] + obj['s'] + obj['v'];\n\n        callback('0x' + result.toString('hex'));\n      } else {\n        self.comm.exchange(apdus.shift(), localCallback);\n      }\n    }\n  };\n  message = toBuffer(message);\n  const prefix = '\\x19Ethereum Signed Message:\\n' + message.length.toString();\n  rawData = Buffer.concat([toBuffer(prefix), message]);\n\n  while (offset !== rawData.length) {\n    const maxChunkSize = 64;\n    const chunkSize =\n      offset + maxChunkSize > rawData.length\n        ? rawData.length - offset\n        : maxChunkSize;\n    const buffer = Buffer.alloc(5 + chunkSize);\n    buffer[0] = 0x80;\n    buffer[1] = 0xf2;\n    buffer[2] = offset === 0 ? 0x00 : 0x01;\n    buffer[3] = offset === 0 ? 0x01 : 0x00;\n    buffer[4] = chunkSize;\n\n    rawData.copy(buffer, 5, offset, offset + chunkSize);\n\n    apdus.push(buffer.toString('hex'));\n    offset += chunkSize;\n  }\n\n  const buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);\n  buffer[0] = 0x80;\n  buffer[1] = 0xf2;\n  buffer[2] = 0x02;\n  buffer[3] = 0x00;\n  buffer[4] = 1 + splitPath.length * 4;\n  buffer[5] = splitPath.length;\n\n  splitPath.forEach((element, idx) => {\n    buffer.writeUInt32BE(element, 6 + 4 * idx);\n  });\n\n  apdus.push(buffer.toString('hex'));\n  self.comm.exchange(apdus.shift(), localCallback);\n};\n\nexport default SecalotEth;\n"]}]}