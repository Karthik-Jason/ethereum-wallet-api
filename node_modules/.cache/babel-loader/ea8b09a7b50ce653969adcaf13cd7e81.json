{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/secalot/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/secalot/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Transaction } from 'ethereumjs-tx';\nimport SecalotEth from \"./secalotEth\";\nimport SecalotUsb from \"./secalotUsb\";\nimport { SECALOT as secalotType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport { getSignTransactionObject, sanitizeHex, getBufferFromHex, calculateChainIdFromV } from \"../../utils\";\nimport errorHandler from \"./errorHandler\";\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nvar NEED_PASSWORD = true;\n\nvar SecalotWallet =\n/*#__PURE__*/\nfunction () {\n  function SecalotWallet(password) {\n    _classCallCheck(this, SecalotWallet);\n\n    this.identifier = secalotType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[secalotType];\n    this.password = password;\n  }\n\n  _createClass(SecalotWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        var transport, rootPub;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                transport = new SecalotUsb();\n                this.secalot = new SecalotEth(transport, this.password);\n                _context.next = 5;\n                return getRootPubKey(this.secalot, this.basePath);\n\n              case 5:\n                rootPub = _context.sent;\n                this.hdKey = new HDKey();\n                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(idx) {\n      var _this = this;\n\n      var derivedKey = this.hdKey.derive('m/' + idx);\n\n      var txSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(tx) {\n          var networkId, result, signedChainId;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  tx = new Transaction(tx, {\n                    common: commonGenerator(store.state.network)\n                  });\n                  networkId = tx.getChainId();\n                  _context2.next = 4;\n                  return _this.secalot.signTransactionAsync(_this.basePath + '/' + idx, tx);\n\n                case 4:\n                  result = _context2.sent;\n                  tx.v = getBufferFromHex(sanitizeHex(result.v));\n                  tx.r = getBufferFromHex(sanitizeHex(result.r));\n                  tx.s = getBufferFromHex(sanitizeHex(result.s));\n                  signedChainId = calculateChainIdFromV(tx.v);\n\n                  if (!(signedChainId !== networkId)) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n\n                case 11:\n                  return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                case 12:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function txSigner(_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var msgSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee3(msg) {\n          var result;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return _this.secalot.signMessageAsync(_this.basePath + '/' + idx, msg);\n\n                case 2:\n                  result = _context3.sent;\n                  return _context3.abrupt(\"return\", getBufferFromHex(result));\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function msgSigner(_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      return new HDWalletInterface(this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, null);\n    }\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return SecalotWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee4(basePath, password) {\n    var _secalotWallet;\n\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _secalotWallet = new SecalotWallet(password);\n            _context4.next = 3;\n            return _secalotWallet.init(basePath);\n\n          case 3:\n            return _context4.abrupt(\"return\", _secalotWallet);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function createWallet(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\n\nvar getRootPubKey = function getRootPubKey(_secalot, _path) {\n  return new Promise(function (resolve, reject) {\n    _secalot.getAddress(_path, function (result, error) {\n      if (error) return reject(error);\n      resolve({\n        publicKey: result.publicKey,\n        chainCode: result.chainCode\n      });\n    });\n  });\n};\n\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/secalot/index.js"],"names":["Transaction","SecalotEth","SecalotUsb","SECALOT","secalotType","bip44Paths","HDWalletInterface","HDKey","getSignTransactionObject","sanitizeHex","getBufferFromHex","calculateChainIdFromV","errorHandler","store","commonGenerator","NEED_PASSWORD","SecalotWallet","password","identifier","isHardware","needPassword","supportedPaths","basePath","path","transport","secalot","getRootPubKey","rootPub","hdKey","publicKey","Buffer","from","chainCode","idx","derivedKey","derive","txSigner","tx","common","state","network","networkId","getChainId","signTransactionAsync","result","v","r","s","signedChainId","Error","msgSigner","msg","signMessageAsync","createWallet","_secalotWallet","init","_secalot","_path","Promise","resolve","reject","getAddress","error"],"mappings":"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","sourcesContent":["import { Transaction } from 'ethereumjs-tx';\nimport SecalotEth from './secalotEth';\nimport SecalotUsb from './secalotUsb';\nimport { SECALOT as secalotType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport {\n  getSignTransactionObject,\n  sanitizeHex,\n  getBufferFromHex,\n  calculateChainIdFromV\n} from '../../utils';\nimport errorHandler from './errorHandler';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nconst NEED_PASSWORD = true;\n\nclass SecalotWallet {\n  constructor(password) {\n    this.identifier = secalotType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[secalotType];\n    this.password = password;\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    const transport = new SecalotUsb();\n    this.secalot = new SecalotEth(transport, this.password);\n    const rootPub = await getRootPubKey(this.secalot, this.basePath);\n    this.hdKey = new HDKey();\n    this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n    this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n  }\n  getAccount(idx) {\n    const derivedKey = this.hdKey.derive('m/' + idx);\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const networkId = tx.getChainId();\n      const result = await this.secalot.signTransactionAsync(\n        this.basePath + '/' + idx,\n        tx\n      );\n      tx.v = getBufferFromHex(sanitizeHex(result.v));\n      tx.r = getBufferFromHex(sanitizeHex(result.r));\n      tx.s = getBufferFromHex(sanitizeHex(result.s));\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        throw new Error(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const result = await this.secalot.signMessageAsync(\n        this.basePath + '/' + idx,\n        msg\n      );\n      return getBufferFromHex(result);\n    };\n    return new HDWalletInterface(\n      this.basePath + '/' + idx,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      null\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst createWallet = async (basePath, password) => {\n  const _secalotWallet = new SecalotWallet(password);\n  await _secalotWallet.init(basePath);\n  return _secalotWallet;\n};\ncreateWallet.errorHandler = errorHandler;\nconst getRootPubKey = (_secalot, _path) => {\n  return new Promise((resolve, reject) => {\n    _secalot.getAddress(_path, (result, error) => {\n      if (error) return reject(error);\n      resolve({\n        publicKey: result.publicKey,\n        chainCode: result.chainCode\n      });\n    });\n  });\n};\n\nexport default createWallet;\n"]}]}