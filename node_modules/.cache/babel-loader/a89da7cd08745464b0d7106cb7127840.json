{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/ledger/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/ledger/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport Ledger from '@ledgerhq/hw-app-eth';\nimport { byContractAddress } from '@ledgerhq/hw-app-eth/erc20';\nimport { Transaction } from 'ethereumjs-tx';\nimport u2fTransport from '@ledgerhq/hw-transport-u2f';\nimport webUsbTransport from '@ledgerhq/hw-transport-webusb';\nimport { LEDGER as ledgerType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport platform from 'platform';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nimport { getSignTransactionObject, getBufferFromHex, sanitizeHex, calculateChainIdFromV } from \"../../utils\";\nimport { toBuffer } from 'ethereumjs-util';\nimport errorHandler from \"./errorHandler\";\nvar NEED_PASSWORD = false;\nvar OPEN_TIMEOUT = 10000;\nvar LISTENER_TIMEOUT = 30000;\n\nvar ledgerWallet =\n/*#__PURE__*/\nfunction () {\n  function ledgerWallet() {\n    _classCallCheck(this, ledgerWallet);\n\n    this.identifier = ledgerType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[ledgerType];\n  }\n\n  _createClass(ledgerWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        var rootPub;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                this.isHardened = this.basePath.split('/').length - 1 === 2;\n                _context.next = 4;\n                return getLedgerTransport();\n\n              case 4:\n                this.transport = _context.sent;\n                this.ledger = new Ledger(this.transport);\n                _context.next = 8;\n                return getLedgerAppConfig(this.ledger);\n\n              case 8:\n                this.appConfig = _context.sent;\n\n                if (this.isHardened) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 12;\n                return getRootPubKey(this.ledger, this.basePath);\n\n              case 12:\n                rootPub = _context.sent;\n                this.hdKey = new HDKey();\n                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5(idx) {\n        var _this = this;\n\n        var derivedKey, accountPath, rootPub, hdKey, txSigner, msgSigner, displayAddress;\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this.isHardened) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                _context5.next = 3;\n                return getRootPubKey(this.ledger, this.basePath + '/' + idx + \"'\");\n\n              case 3:\n                rootPub = _context5.sent;\n                hdKey = new HDKey();\n                hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n                derivedKey = hdKey.derive('m/0/0');\n                accountPath = this.basePath + '/' + idx + \"'\" + '/0/0';\n                _context5.next = 13;\n                break;\n\n              case 11:\n                derivedKey = this.hdKey.derive('m/' + idx);\n                accountPath = this.basePath + '/' + idx;\n\n              case 13:\n                txSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee2(tx) {\n                    var networkId, tokenInfo, result, v, rv, cv, signedChainId;\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            tx = new Transaction(tx, {\n                              common: commonGenerator(store.state.network)\n                            });\n                            networkId = tx.getChainId();\n                            tx.raw[6] = networkId;\n                            tx.raw[7] = Buffer.from([]);\n                            tx.raw[8] = Buffer.from([]);\n                            tokenInfo = byContractAddress('0x' + tx.to.toString('hex'));\n\n                            if (!tokenInfo) {\n                              _context2.next = 9;\n                              break;\n                            }\n\n                            _context2.next = 9;\n                            return _this.ledger.provideERC20TokenInformation(tokenInfo);\n\n                          case 9:\n                            _context2.next = 11;\n                            return _this.ledger.signTransaction(accountPath, tx.serialize().toString('hex'));\n\n                          case 11:\n                            result = _context2.sent;\n                            // EIP155 support. check/recalc signature v value.\n                            v = result.v;\n                            rv = parseInt(v, 16);\n                            cv = networkId * 2 + 35;\n\n                            if (rv !== cv && (rv & cv) !== rv) {\n                              cv += 1; // add signature v bit.\n                            }\n\n                            v = cv.toString(16);\n                            tx.v = getBufferFromHex(v);\n                            tx.r = getBufferFromHex(result.r);\n                            tx.s = getBufferFromHex(result.s);\n                            signedChainId = calculateChainIdFromV(tx.v);\n\n                            if (!(signedChainId !== networkId)) {\n                              _context2.next = 23;\n                              break;\n                            }\n\n                            throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n\n                          case 23:\n                            return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                          case 24:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function txSigner(_x3) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                msgSigner =\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee3(msg) {\n                    var result, v, vHex;\n                    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return _this.ledger.signPersonalMessage(accountPath, toBuffer(msg).toString('hex'));\n\n                          case 2:\n                            result = _context3.sent;\n                            v = parseInt(result.v, 10) - 27;\n                            vHex = sanitizeHex(v.toString(16));\n                            return _context3.abrupt(\"return\", Buffer.concat([getBufferFromHex(result.r), getBufferFromHex(result.s), getBufferFromHex(vHex)]));\n\n                          case 6:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function msgSigner(_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                displayAddress =\n                /*#__PURE__*/\n                function () {\n                  var _ref3 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee4() {\n                    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _this.ledger.getAddress(accountPath, true, false);\n\n                          case 2:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function displayAddress() {\n                    return _ref3.apply(this, arguments);\n                  };\n                }();\n\n                return _context5.abrupt(\"return\", new HDWalletInterface(accountPath, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, displayAddress));\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x2) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return ledgerWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee6(basePath) {\n    var _ledgerWallet;\n\n    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ledgerWallet = new ledgerWallet();\n            _context6.next = 3;\n            return _ledgerWallet.init(basePath);\n\n          case 3:\n            return _context6.abrupt(\"return\", _ledgerWallet);\n\n          case 4:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function createWallet(_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\n\nvar isWebUsbSupported =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee7() {\n    var isSupported;\n    return regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return webUsbTransport.isSupported();\n\n          case 2:\n            isSupported = _context7.sent;\n            return _context7.abrupt(\"return\", isSupported && platform.os.family !== 'Windows' && platform.name !== 'Opera' // take it out later once the windows issue is fixed\n            );\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n\n  return function isWebUsbSupported() {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar getLedgerTransport =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee8() {\n    var transport, support;\n    return regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return isWebUsbSupported();\n\n          case 2:\n            support = _context8.sent;\n\n            if (!support) {\n              _context8.next = 9;\n              break;\n            }\n\n            _context8.next = 6;\n            return webUsbTransport.create();\n\n          case 6:\n            transport = _context8.sent;\n            _context8.next = 12;\n            break;\n\n          case 9:\n            _context8.next = 11;\n            return u2fTransport.create(OPEN_TIMEOUT, LISTENER_TIMEOUT);\n\n          case 11:\n            transport = _context8.sent;\n\n          case 12:\n            return _context8.abrupt(\"return\", transport);\n\n          case 13:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function getLedgerTransport() {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar getLedgerAppConfig =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee9(_ledger) {\n    var appConfig;\n    return regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _ledger.getAppConfiguration();\n\n          case 2:\n            appConfig = _context9.sent;\n            return _context9.abrupt(\"return\", appConfig);\n\n          case 4:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n\n  return function getLedgerAppConfig(_x6) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar getRootPubKey =\n/*#__PURE__*/\nfunction () {\n  var _ref8 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee10(_ledger, _path) {\n    var pubObj;\n    return regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return _ledger.getAddress(_path, false, true);\n\n          case 2:\n            pubObj = _context10.sent;\n            return _context10.abrupt(\"return\", {\n              publicKey: pubObj.publicKey,\n              chainCode: pubObj.chainCode\n            });\n\n          case 4:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n\n  return function getRootPubKey(_x7, _x8) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/wallets/hardware/ledger/index.js"],"names":["Ledger","byContractAddress","Transaction","u2fTransport","webUsbTransport","LEDGER","ledgerType","bip44Paths","HDWalletInterface","HDKey","platform","store","commonGenerator","getSignTransactionObject","getBufferFromHex","sanitizeHex","calculateChainIdFromV","toBuffer","errorHandler","NEED_PASSWORD","OPEN_TIMEOUT","LISTENER_TIMEOUT","ledgerWallet","identifier","isHardware","needPassword","supportedPaths","basePath","path","isHardened","split","length","getLedgerTransport","transport","ledger","getLedgerAppConfig","appConfig","getRootPubKey","rootPub","hdKey","publicKey","Buffer","from","chainCode","idx","derivedKey","derive","accountPath","txSigner","tx","common","state","network","networkId","getChainId","raw","tokenInfo","to","toString","provideERC20TokenInformation","signTransaction","serialize","result","v","rv","parseInt","cv","r","s","signedChainId","Error","msgSigner","msg","signPersonalMessage","vHex","concat","displayAddress","getAddress","createWallet","_ledgerWallet","init","isWebUsbSupported","isSupported","os","family","name","support","create","_ledger","getAppConfiguration","_path","pubObj"],"mappings":"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","sourcesContent":["import Ledger from '@ledgerhq/hw-app-eth';\nimport { byContractAddress } from '@ledgerhq/hw-app-eth/erc20';\nimport { Transaction } from 'ethereumjs-tx';\nimport u2fTransport from '@ledgerhq/hw-transport-u2f';\nimport webUsbTransport from '@ledgerhq/hw-transport-webusb';\nimport { LEDGER as ledgerType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport platform from 'platform';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nimport {\n  getSignTransactionObject,\n  getBufferFromHex,\n  sanitizeHex,\n  calculateChainIdFromV\n} from '../../utils';\nimport { toBuffer } from 'ethereumjs-util';\nimport errorHandler from './errorHandler';\n\nconst NEED_PASSWORD = false;\nconst OPEN_TIMEOUT = 10000;\nconst LISTENER_TIMEOUT = 30000;\n\nclass ledgerWallet {\n  constructor() {\n    this.identifier = ledgerType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[ledgerType];\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    this.isHardened = this.basePath.split('/').length - 1 === 2;\n    this.transport = await getLedgerTransport();\n    this.ledger = new Ledger(this.transport);\n    this.appConfig = await getLedgerAppConfig(this.ledger);\n    if (!this.isHardened) {\n      const rootPub = await getRootPubKey(this.ledger, this.basePath);\n      this.hdKey = new HDKey();\n      this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n      this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n    }\n  }\n  async getAccount(idx) {\n    let derivedKey, accountPath;\n    if (this.isHardened) {\n      const rootPub = await getRootPubKey(\n        this.ledger,\n        this.basePath + '/' + idx + \"'\"\n      );\n      const hdKey = new HDKey();\n      hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n      hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n      derivedKey = hdKey.derive('m/0/0');\n      accountPath = this.basePath + '/' + idx + \"'\" + '/0/0';\n    } else {\n      derivedKey = this.hdKey.derive('m/' + idx);\n      accountPath = this.basePath + '/' + idx;\n    }\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const networkId = tx.getChainId();\n      tx.raw[6] = networkId;\n      tx.raw[7] = Buffer.from([]);\n      tx.raw[8] = Buffer.from([]);\n      const tokenInfo = byContractAddress('0x' + tx.to.toString('hex'));\n      if (tokenInfo) await this.ledger.provideERC20TokenInformation(tokenInfo);\n      const result = await this.ledger.signTransaction(\n        accountPath,\n        tx.serialize().toString('hex')\n      );\n\n      // EIP155 support. check/recalc signature v value.\n      let v = result.v;\n      const rv = parseInt(v, 16);\n      let cv = networkId * 2 + 35;\n      if (rv !== cv && (rv & cv) !== rv) {\n        cv += 1; // add signature v bit.\n      }\n      v = cv.toString(16);\n\n      tx.v = getBufferFromHex(v);\n      tx.r = getBufferFromHex(result.r);\n      tx.s = getBufferFromHex(result.s);\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        throw new Error(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const result = await this.ledger.signPersonalMessage(\n        accountPath,\n        toBuffer(msg).toString('hex')\n      );\n      const v = parseInt(result.v, 10) - 27;\n      const vHex = sanitizeHex(v.toString(16));\n      return Buffer.concat([\n        getBufferFromHex(result.r),\n        getBufferFromHex(result.s),\n        getBufferFromHex(vHex)\n      ]);\n    };\n    const displayAddress = async () => {\n      await this.ledger.getAddress(accountPath, true, false);\n    };\n    return new HDWalletInterface(\n      accountPath,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      displayAddress\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst createWallet = async basePath => {\n  const _ledgerWallet = new ledgerWallet();\n  await _ledgerWallet.init(basePath);\n  return _ledgerWallet;\n};\ncreateWallet.errorHandler = errorHandler;\n\nconst isWebUsbSupported = async () => {\n  const isSupported = await webUsbTransport.isSupported();\n  return (\n    isSupported && platform.os.family !== 'Windows' && platform.name !== 'Opera' // take it out later once the windows issue is fixed\n  );\n};\n\nconst getLedgerTransport = async () => {\n  let transport;\n  const support = await isWebUsbSupported();\n  if (support) {\n    transport = await webUsbTransport.create();\n  } else {\n    transport = await u2fTransport.create(OPEN_TIMEOUT, LISTENER_TIMEOUT);\n  }\n  return transport;\n};\nconst getLedgerAppConfig = async _ledger => {\n  const appConfig = await _ledger.getAppConfiguration();\n  return appConfig;\n};\nconst getRootPubKey = async (_ledger, _path) => {\n  const pubObj = await _ledger.getAddress(_path, false, true);\n  return {\n    publicKey: pubObj.publicKey,\n    chainCode: pubObj.chainCode\n  };\n};\n\nexport default createWallet;\n"]}]}