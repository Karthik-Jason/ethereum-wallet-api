{"remainingRequest":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/software/mnemonic/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/software/mnemonic/index.js","mtime":1573477612132},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport * as HDKey from 'hdkey';\nimport { Transaction } from 'ethereumjs-tx';\nimport { hashPersonalMessage, toBuffer, ecsign } from 'ethereumjs-util';\nimport { MNEMONIC as mnemonicType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { getSignTransactionObject, calculateChainIdFromV } from \"../../utils\";\nimport errorHandler from \"./errorHandler\";\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nvar bip39 = require('bip39');\n\nvar NEED_PASSWORD = true;\nvar IS_HARDWARE = false;\n\nvar MnemonicWallet =\n/*#__PURE__*/\nfunction () {\n  function MnemonicWallet(mnemonic, password) {\n    _classCallCheck(this, MnemonicWallet);\n\n    if (!bip39.validateMnemonic(mnemonic)) throw new Error('Invalid Mnemonic');\n    this.identifier = mnemonicType;\n    this.isHardware = IS_HARDWARE;\n    this.needPassword = NEED_PASSWORD;\n    this.mnemonic = mnemonic;\n    this.password = password;\n    this.supportedPaths = bip44Paths[mnemonicType];\n  }\n\n  _createClass(MnemonicWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                this.hdKey = HDKey.fromMasterSeed(bip39.mnemonicToSeedSync(this.mnemonic, this.password));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(idx) {\n      var derivedKey = this.hdKey.derive(this.basePath + '/' + idx);\n\n      var txSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(tx) {\n          var networkId, signedChainId;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  tx = new Transaction(tx, {\n                    common: commonGenerator(store.state.network)\n                  });\n                  networkId = tx.getChainId();\n                  tx.sign(derivedKey.privateKey);\n                  signedChainId = calculateChainIdFromV(tx.v);\n\n                  if (!(signedChainId !== networkId)) {\n                    _context2.next = 6;\n                    break;\n                  }\n\n                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n\n                case 6:\n                  return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                case 7:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function txSigner(_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var msgSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee3(msg) {\n          var msgHash, signed;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  msgHash = hashPersonalMessage(toBuffer(msg));\n                  signed = ecsign(msgHash, derivedKey.privateKey);\n                  return _context3.abrupt(\"return\", Buffer.concat([Buffer.from(signed.r), Buffer.from(signed.s), Buffer.from([signed.v])]));\n\n                case 3:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function msgSigner(_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      return new HDWalletInterface(this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, null);\n    }\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return MnemonicWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee4(mnemonic, password, basePath) {\n    var _mnemonicWallet;\n\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _mnemonicWallet = new MnemonicWallet(mnemonic, password);\n            _context4.next = 3;\n            return _mnemonicWallet.init(basePath);\n\n          case 3:\n            return _context4.abrupt(\"return\", _mnemonicWallet);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function createWallet(_x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/software/mnemonic/index.js"],"names":["HDKey","Transaction","hashPersonalMessage","toBuffer","ecsign","MNEMONIC","mnemonicType","bip44Paths","HDWalletInterface","getSignTransactionObject","calculateChainIdFromV","errorHandler","store","commonGenerator","bip39","require","NEED_PASSWORD","IS_HARDWARE","MnemonicWallet","mnemonic","password","validateMnemonic","Error","identifier","isHardware","needPassword","supportedPaths","basePath","path","hdKey","fromMasterSeed","mnemonicToSeedSync","idx","derivedKey","derive","txSigner","tx","common","state","network","networkId","getChainId","sign","privateKey","signedChainId","v","msgSigner","msg","msgHash","signed","Buffer","concat","from","r","s","publicKey","createWallet","_mnemonicWallet","init"],"mappings":"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","sourcesContent":["import * as HDKey from 'hdkey';\nimport { Transaction } from 'ethereumjs-tx';\nimport { hashPersonalMessage, toBuffer, ecsign } from 'ethereumjs-util';\nimport { MNEMONIC as mnemonicType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { getSignTransactionObject, calculateChainIdFromV } from '../../utils';\nimport errorHandler from './errorHandler';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nconst bip39 = require('bip39');\nconst NEED_PASSWORD = true;\nconst IS_HARDWARE = false;\n\nclass MnemonicWallet {\n  constructor(mnemonic, password) {\n    if (!bip39.validateMnemonic(mnemonic)) throw new Error('Invalid Mnemonic');\n    this.identifier = mnemonicType;\n    this.isHardware = IS_HARDWARE;\n    this.needPassword = NEED_PASSWORD;\n    this.mnemonic = mnemonic;\n    this.password = password;\n    this.supportedPaths = bip44Paths[mnemonicType];\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    this.hdKey = HDKey.fromMasterSeed(\n      bip39.mnemonicToSeedSync(this.mnemonic, this.password)\n    );\n  }\n  getAccount(idx) {\n    const derivedKey = this.hdKey.derive(this.basePath + '/' + idx);\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const networkId = tx.getChainId();\n      tx.sign(derivedKey.privateKey);\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        throw new Error(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const msgHash = hashPersonalMessage(toBuffer(msg));\n      const signed = ecsign(msgHash, derivedKey.privateKey);\n      return Buffer.concat([\n        Buffer.from(signed.r),\n        Buffer.from(signed.s),\n        Buffer.from([signed.v])\n      ]);\n    };\n    return new HDWalletInterface(\n      this.basePath + '/' + idx,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      null\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst createWallet = async (mnemonic, password, basePath) => {\n  const _mnemonicWallet = new MnemonicWallet(mnemonic, password);\n  await _mnemonicWallet.init(basePath);\n  return _mnemonicWallet;\n};\ncreateWallet.errorHandler = errorHandler;\n\nexport default createWallet;\n"]}]}