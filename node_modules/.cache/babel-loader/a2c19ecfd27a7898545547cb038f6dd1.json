{"remainingRequest":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/bitbox/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/bitbox/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Transaction } from 'ethereumjs-tx';\nimport { hashPersonalMessage, toBuffer } from 'ethereumjs-util';\nimport DigitalBitboxUsb from \"./digitalBitboxUsb\";\nimport DigitalBitboxEth from \"./digitalBitboxEth\";\nimport { BITBOX as bitboxType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { Toast } from '@/helpers';\nimport errorHandler from \"./errorHandler\";\nimport * as HDKey from 'hdkey';\nimport store from '@/store';\nimport { getSignTransactionObject, sanitizeHex, getBufferFromHex, calculateChainIdFromV } from \"../../utils\";\nimport commonGenerator from '@/helpers/commonGenerator';\nvar NEED_PASSWORD = true;\n\nvar BitBoxWallet =\n/*#__PURE__*/\nfunction () {\n  function BitBoxWallet(password) {\n    _classCallCheck(this, BitBoxWallet);\n\n    this.identifier = bitboxType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[bitboxType];\n    this.password = password;\n  }\n\n  _createClass(BitBoxWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        var transport, rootPub;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                transport = new DigitalBitboxUsb();\n                this.bitbox = new DigitalBitboxEth(transport, this.password);\n                _context.next = 5;\n                return getRootPubKey(this.bitbox, this.basePath);\n\n              case 5:\n                rootPub = _context.sent;\n                this.hdKey = new HDKey();\n                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(idx) {\n      var _this = this;\n\n      var derivedKey = this.hdKey.derive('m/' + idx);\n\n      var txSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(tx) {\n          var networkId, result, signedChainId;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  tx = new Transaction(tx, {\n                    common: commonGenerator(store.state.network)\n                  });\n                  networkId = tx.getChainId();\n                  _context2.next = 4;\n                  return _this.bitbox.signTransaction(_this.basePath + '/' + idx, tx);\n\n                case 4:\n                  result = _context2.sent;\n                  tx.v = getBufferFromHex(sanitizeHex(result.v));\n                  tx.r = getBufferFromHex(sanitizeHex(result.r));\n                  tx.s = getBufferFromHex(sanitizeHex(result.s));\n                  signedChainId = calculateChainIdFromV(tx.v);\n                  if (signedChainId !== networkId) Toast.responseHandler(new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId'), false);\n                  return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function txSigner(_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var msgSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee3(msg) {\n          var msgHash, result;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  msgHash = hashPersonalMessage(toBuffer(msg));\n                  _context3.next = 3;\n                  return _this.bitbox.signMessage(_this.basePath + '/' + idx, msgHash);\n\n                case 3:\n                  result = _context3.sent;\n                  return _context3.abrupt(\"return\", Buffer.concat([getBufferFromHex(sanitizeHex(result.r)), getBufferFromHex(sanitizeHex(result.s)), getBufferFromHex(sanitizeHex(result.v))]));\n\n                case 5:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function msgSigner(_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      return new HDWalletInterface(this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, null);\n    }\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return BitBoxWallet;\n}();\n\nvar getRootPubKey = function getRootPubKey(_bitbox, _path) {\n  return new Promise(function (resolve, reject) {\n    _bitbox.getStarted(_path, function (result, error) {\n      if (error) return reject(error);\n      resolve({\n        publicKey: result.publicKey,\n        chainCode: result.chainCode\n      });\n    });\n  });\n};\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee4(basePath, password) {\n    var _bitboxWallet;\n\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _bitboxWallet = new BitBoxWallet(password);\n            _context4.next = 3;\n            return _bitboxWallet.init(basePath);\n\n          case 3:\n            return _context4.abrupt(\"return\", _bitboxWallet);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function createWallet(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/bitbox/index.js"],"names":["Transaction","hashPersonalMessage","toBuffer","DigitalBitboxUsb","DigitalBitboxEth","BITBOX","bitboxType","bip44Paths","HDWalletInterface","Toast","errorHandler","HDKey","store","getSignTransactionObject","sanitizeHex","getBufferFromHex","calculateChainIdFromV","commonGenerator","NEED_PASSWORD","BitBoxWallet","password","identifier","isHardware","needPassword","supportedPaths","basePath","path","transport","bitbox","getRootPubKey","rootPub","hdKey","publicKey","Buffer","from","chainCode","idx","derivedKey","derive","txSigner","tx","common","state","network","networkId","getChainId","signTransaction","result","v","r","s","signedChainId","responseHandler","Error","msgSigner","msg","msgHash","signMessage","concat","_bitbox","_path","Promise","resolve","reject","getStarted","error","createWallet","_bitboxWallet","init"],"mappings":"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","sourcesContent":["import { Transaction } from 'ethereumjs-tx';\nimport { hashPersonalMessage, toBuffer } from 'ethereumjs-util';\nimport DigitalBitboxUsb from './digitalBitboxUsb';\nimport DigitalBitboxEth from './digitalBitboxEth';\nimport { BITBOX as bitboxType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport { Toast } from '@/helpers';\nimport errorHandler from './errorHandler';\nimport * as HDKey from 'hdkey';\nimport store from '@/store';\nimport {\n  getSignTransactionObject,\n  sanitizeHex,\n  getBufferFromHex,\n  calculateChainIdFromV\n} from '../../utils';\nimport commonGenerator from '@/helpers/commonGenerator';\n\nconst NEED_PASSWORD = true;\n\nclass BitBoxWallet {\n  constructor(password) {\n    this.identifier = bitboxType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[bitboxType];\n    this.password = password;\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    const transport = new DigitalBitboxUsb();\n    this.bitbox = new DigitalBitboxEth(transport, this.password);\n    const rootPub = await getRootPubKey(this.bitbox, this.basePath);\n    this.hdKey = new HDKey();\n    this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n    this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n  }\n  getAccount(idx) {\n    const derivedKey = this.hdKey.derive('m/' + idx);\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const networkId = tx.getChainId();\n      const result = await this.bitbox.signTransaction(\n        this.basePath + '/' + idx,\n        tx\n      );\n      tx.v = getBufferFromHex(sanitizeHex(result.v));\n      tx.r = getBufferFromHex(sanitizeHex(result.r));\n      tx.s = getBufferFromHex(sanitizeHex(result.s));\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        Toast.responseHandler(\n          new Error(\n            'Invalid networkId signature returned. Expected: ' +\n              networkId +\n              ', Got: ' +\n              signedChainId,\n            'InvalidNetworkId'\n          ),\n          false\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const msgHash = hashPersonalMessage(toBuffer(msg));\n      const result = await this.bitbox.signMessage(\n        this.basePath + '/' + idx,\n        msgHash\n      );\n      return Buffer.concat([\n        getBufferFromHex(sanitizeHex(result.r)),\n        getBufferFromHex(sanitizeHex(result.s)),\n        getBufferFromHex(sanitizeHex(result.v))\n      ]);\n    };\n    return new HDWalletInterface(\n      this.basePath + '/' + idx,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      null\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst getRootPubKey = (_bitbox, _path) => {\n  return new Promise((resolve, reject) => {\n    _bitbox.getStarted(_path, (result, error) => {\n      if (error) return reject(error);\n      resolve({\n        publicKey: result.publicKey,\n        chainCode: result.chainCode\n      });\n    });\n  });\n};\n\nconst createWallet = async (basePath, password) => {\n  const _bitboxWallet = new BitBoxWallet(password);\n  await _bitboxWallet.init(basePath);\n  return _bitboxWallet;\n};\ncreateWallet.errorHandler = errorHandler;\n\nexport default createWallet;\n"]}]}