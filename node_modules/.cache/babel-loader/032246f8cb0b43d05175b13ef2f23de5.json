{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/partners/partners.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/partners/partners.js","mtime":1574664278314},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js","mtime":1574664275010},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js","mtime":1574664275986}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es6.number.is-nan\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.sort\";\nimport _toConsumableArray from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport BigNumber from 'bignumber.js';\nimport WAValidator from 'wallet-address-validator';\nimport MAValidator from 'multicoin-address-validator';\nimport { checkInvalidOrMissingValue, bestProviderForQuantity, utils } from \"./helpers\";\nimport { BASE_CURRENCY, TOP_OPTIONS_ORDER, EthereumTokens, OtherCoins, fiat } from \"./partnersConfig\";\n\nfunction comparator(arrayForSort) {\n  if (!arrayForSort) arrayForSort = TOP_OPTIONS_ORDER;\n  return function (a, b) {\n    a = a.symbol;\n    b = b.symbol;\n\n    if (arrayForSort.includes(a) || arrayForSort.includes(b)) {\n      return arrayForSort.indexOf(b) - arrayForSort.indexOf(a);\n    }\n\n    return a < b ? -1 : a > b ? 1 : 0;\n  };\n}\n\nvar SwapProviders =\n/*#__PURE__*/\nfunction () {\n  function SwapProviders(providers, environmentSupplied) {\n    var misc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, SwapProviders);\n\n    this.online = true;\n\n    if (misc.hasOwnProperty('online')) {\n      this.online = misc.online;\n    }\n\n    this.providerConstructors = providers;\n    this.setup(providers, environmentSupplied, misc);\n  }\n\n  _createClass(SwapProviders, [{\n    key: \"setup\",\n    value: function setup(providers, environmentSupplied, misc) {\n      var _this = this;\n\n      this.overrideDecimals = misc.overrideDecimals || false;\n      this.updateProviderRates = 0;\n      this.providers = new Map();\n      this.providerRateUpdates = {};\n      this.ownedTokenList = misc.tokensWithBalance || [];\n      this.providerRatesRecieved = [];\n      if (!this.online) return;\n      providers.forEach(function (entry) {\n        _this.providerRateUpdates[entry.getName()] = 0;\n\n        _this.providers.set(entry.getName(), new entry(environmentSupplied));\n      });\n      this.providerRatesRecieved = [];\n      var checkCount = 0;\n\n      if (environmentSupplied.network !== BASE_CURRENCY) {\n        var checkIfAllRatesReceived = setInterval(function () {\n          checkCount++;\n\n          _this.checkIfRatesPresent();\n\n          if (_this.ratesRetrieved || checkCount > 20) {\n            _this.providerRatesRecieved = Object.keys(_this.providerRateUpdates);\n            clearInterval(checkIfAllRatesReceived);\n          }\n        }, 150);\n      } else {\n        var _checkIfAllRatesReceived = setInterval(function () {\n          checkCount++;\n\n          _this.checkIfRatesPresent();\n\n          if (_this.ratesRetrieved || checkCount > 50) {\n            _this.providerRatesRecieved = Object.keys(_this.providerRateUpdates);\n            clearInterval(_checkIfAllRatesReceived);\n          }\n        }, 150);\n      }\n\n      this.initialCurrencyArrays = this.buildInitialCurrencyArrays();\n    }\n  }, {\n    key: \"ownedTokens\",\n    value: function ownedTokens(tokens) {\n      this.ownedTokenList = tokens;\n    }\n  }, {\n    key: \"getProviders\",\n    value: function getProviders() {\n      return utils.mapToObject(this.providers);\n    }\n  }, {\n    key: \"getProvider\",\n    value: function getProvider(name) {\n      if (!this.isProvider(name)) throw Error(\"\".concat(name, \" is not a supported swap provider\"));\n      return this.providers.get(name);\n    }\n  }, {\n    key: \"isProvider\",\n    value: function isProvider(name) {\n      if (!this.online) return false;\n      return this.providers.has(name);\n    }\n  }, {\n    key: \"updateNetwork\",\n    value: function updateNetwork(network, web3) {\n      this.providers.forEach(function (provider) {\n        provider.setNetwork(network, web3);\n      });\n    }\n  }, {\n    key: \"checkIfRatesPresent\",\n    value: function checkIfRatesPresent() {\n      var _this2 = this;\n\n      this.providers.forEach(function (provider) {\n        if (!_this2.providerRatesRecieved.includes(provider.name) && provider.hasRates > 0) {\n          _this2.updateProviderRates++;\n\n          _this2.providerRatesRecieved.push(provider.name);\n        }\n      });\n    } // Note: Seems to not always float user held tokens to the top??\n    // Does in general, but have observed some instances where it did not.\n\n  }, {\n    key: \"optionSorting\",\n    value: function optionSorting(array) {\n      var tokens = _toConsumableArray(this.ownedTokenList);\n\n      var tokenNameMap = tokens.sort(function (a, b) {\n        if (a.hasOwnProperty('balance') && b.hasOwnProperty('balance')) {\n          return b.balance - a.balance;\n        }\n\n        return 0;\n      }).map(function (item) {\n        return item.symbol;\n      }).reverse();\n      var arraysForSort = [].concat(_toConsumableArray(tokenNameMap), _toConsumableArray(TOP_OPTIONS_ORDER));\n      return array.sort(comparator(arraysForSort));\n    }\n  }, {\n    key: \"buildInitialCurrencyArrays\",\n    value: function buildInitialCurrencyArrays() {\n      var collectMapTo = new Map();\n      var collectMapFrom = new Map();\n      this.providers.forEach(function (provider) {\n        provider.getInitialCurrencyEntries(collectMapFrom, collectMapTo);\n      });\n      var toArray = this.optionSorting(Array.from(collectMapTo.values()));\n      var fromArray = this.optionSorting(Array.from(collectMapFrom.values()));\n      return {\n        toArray: toArray,\n        fromArray: fromArray\n      };\n    }\n  }, {\n    key: \"setFromCurrencyBuilder\",\n    value: function setFromCurrencyBuilder(value) {\n      var collectMap = new Map();\n      this.providers.forEach(function (provider) {\n        provider.getUpdatedFromCurrencyEntries(value, collectMap);\n      });\n      return this.optionSorting(Array.from(collectMap.values()));\n    }\n  }, {\n    key: \"setToCurrencyBuilder\",\n    value: function setToCurrencyBuilder(value) {\n      var collectMap = new Map();\n      this.providers.forEach(function (provider) {\n        provider.getUpdatedToCurrencyEntries(value, collectMap);\n      });\n      return this.optionSorting(Array.from(collectMap.values()));\n    }\n  }, {\n    key: \"updateRateEstimate\",\n    value: function () {\n      var _updateRateEstimate = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(fromCurrency, toCurrency, fromValue) {\n        var providersFound, callsToMake;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.haveProviderRates) {\n                  _context.next = 6;\n                  break;\n                }\n\n                providersFound = [];\n                callsToMake = [];\n\n                if (!(+fromValue > 0 && fromCurrency !== toCurrency && !Number.isNaN(+fromValue))) {\n                  _context.next = 6;\n                  break;\n                }\n\n                this.providers.forEach(function (provider) {\n                  if (provider.validSwap(fromCurrency, toCurrency)) {\n                    callsToMake.push(provider.getRate.bind(provider));\n                    providersFound.push(provider.name);\n                  }\n                });\n                return _context.abrupt(\"return\", {\n                  providersFound: providersFound,\n                  callsToMake: callsToMake\n                });\n\n              case 6:\n                return _context.abrupt(\"return\", {\n                  providersFound: [],\n                  callsToMake: []\n                });\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateRateEstimate(_x, _x2, _x3) {\n        return _updateRateEstimate.apply(this, arguments);\n      }\n\n      return updateRateEstimate;\n    }()\n  }, {\n    key: \"standAloneRateEstimate\",\n    value: function () {\n      var _standAloneRateEstimate = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(fromCurrency, toCurrency, fromValue) {\n        var toValue,\n            _ref,\n            callsToMake,\n            results,\n            vals,\n            _args2 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                toValue = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;\n\n                if (!this.haveProviderRates) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this.updateRateEstimate(fromCurrency, toCurrency, fromValue, toValue);\n\n              case 4:\n                _ref = _context2.sent;\n                callsToMake = _ref.callsToMake;\n                _context2.next = 8;\n                return Promise.all(callsToMake.map(function (func) {\n                  return func(fromCurrency, toCurrency, fromValue, toValue);\n                }));\n\n              case 8:\n                results = _context2.sent;\n\n                if (!results.every(function (entry) {\n                  return entry.fromCurrency === fromCurrency && entry.toCurrency === toCurrency;\n                })) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                vals = bestProviderForQuantity(results.map(function (entry) {\n                  if (+entry.rate > 0) {\n                    return {\n                      provider: entry.provider,\n                      fromCurrency: fromCurrency,\n                      fromValue: fromValue,\n                      toCurrency: toCurrency,\n                      rate: +entry.rate,\n                      minValue: entry.minValue || 0,\n                      maxValue: entry.maxValue || 0,\n                      computeConversion: function computeConversion(_fromValue) {\n                        return new BigNumber(_fromValue).times(this.rate).toFixed(6).toString(10);\n                      }\n                    };\n                  }\n                }), fromValue);\n\n                if (!(vals.length === 0)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", [{}]);\n\n              case 13:\n                return _context2.abrupt(\"return\", vals);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function standAloneRateEstimate(_x4, _x5, _x6) {\n        return _standAloneRateEstimate.apply(this, arguments);\n      }\n\n      return standAloneRateEstimate;\n    }()\n  }, {\n    key: \"getTokenAddress\",\n    value: function getTokenAddress(currency, noError) {\n      if (SwapProviders.isToken(currency)) {\n        return EthereumTokens[currency].contractAddress;\n      }\n\n      if (noError) {\n        return false;\n      }\n\n      throw Error('Not an Ethereum Token');\n    }\n  }, {\n    key: \"calculateFromValue\",\n    value: function calculateFromValue(toValue, bestRate, currency) {\n      var decimals = this.decimalForCalculation(currency);\n      return checkInvalidOrMissingValue(new BigNumber(toValue).div(new BigNumber(bestRate)).toFixed(decimals).toString(10), false);\n    }\n  }, {\n    key: \"calculateToValue\",\n    value: function calculateToValue(fromValue, bestRate, currency) {\n      var decimals = this.decimalForCalculation(currency);\n      return checkInvalidOrMissingValue(new BigNumber(fromValue).times(new BigNumber(bestRate)).toFixed(decimals).toString(10), true);\n    }\n  }, {\n    key: \"decimalForCalculation\",\n    value: function decimalForCalculation(currency) {\n      if (!currency) return 6;\n\n      if (fiat.find(function (entry) {\n        return entry.symbol === currency;\n      })) {\n        return 2;\n      } else if (SwapProviders.isToken(currency)) {\n        var decimal = SwapProviders.getTokenDecimals(currency);\n        if (decimal < 6) return decimal;\n        if (this.overrideDecimals) return decimal;\n        return 6;\n      }\n\n      return 6;\n    }\n  }, {\n    key: \"convertToTokenWei\",\n    value: function convertToTokenWei(token, value) {\n      var decimals = SwapProviders.getTokenDecimals(token);\n      var denominator = new BigNumber(10).pow(decimals);\n      return new BigNumber(value).times(denominator).toFixed(0).toString(10);\n    }\n  }, {\n    key: \"convertToTokenBase\",\n    value: function convertToTokenBase(token, value) {\n      var decimals = SwapProviders.getTokenDecimals(token);\n      var denominator = new BigNumber(10).pow(decimals);\n      return new BigNumber(value).div(denominator).toString(10);\n    }\n  }, {\n    key: \"startSwap\",\n    value: function () {\n      var _startSwap = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(_ref2) {\n        var providerDetails, fromValue, toValue, toAddress, fromAddress, refundAddress, swapDetails, provider;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                providerDetails = _ref2.providerDetails, fromValue = _ref2.fromValue, toValue = _ref2.toValue, toAddress = _ref2.toAddress, fromAddress = _ref2.fromAddress, refundAddress = _ref2.refundAddress;\n                _context3.prev = 1;\n                swapDetails = {\n                  provider: providerDetails.provider,\n                  fromCurrency: providerDetails.fromCurrency,\n                  fromValue: fromValue,\n                  toValue: toValue,\n                  toCurrency: providerDetails.toCurrency,\n                  rate: providerDetails.rate,\n                  minValue: providerDetails.minValue,\n                  maxValue: providerDetails.maxValue,\n                  toAddress: toAddress,\n                  fromAddress: fromAddress,\n                  timestamp: new Date().toISOString(),\n                  refundAddress: refundAddress\n                };\n\n                if (!this.providers.has(swapDetails.provider)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                provider = this.providers.get(swapDetails.provider);\n                swapDetails.maybeToken = SwapProviders.isToken(swapDetails.fromCurrency);\n                return _context3.abrupt(\"return\", provider.startSwap(swapDetails));\n\n              case 7:\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](1);\n                throw _context3.t0;\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 9]]);\n      }));\n\n      function startSwap(_x7) {\n        return _startSwap.apply(this, arguments);\n      }\n\n      return startSwap;\n    }() // Helper Methods\n\n  }, {\n    key: \"hasEnough\",\n    value: function hasEnough(fromCurrency, fromValue, baseCurrency, tokenBalances, balance) {\n      if (SwapProviders.isToken(fromCurrency) && fromCurrency !== baseCurrency) {\n        var enteredVal = this.convertToTokenWei(fromCurrency, fromValue);\n        return new BigNumber(tokenBalances[fromCurrency]).gte(new BigNumber(enteredVal));\n      } else if (fromCurrency === baseCurrency) {\n        var _enteredVal = this.convertToTokenWei(fromCurrency, fromValue);\n\n        return new BigNumber(balance).gt(new BigNumber(_enteredVal));\n      }\n\n      return true;\n    } // Static Methods\n\n  }, {\n    key: \"initialCurrencyLists\",\n    get: function get() {\n      return this.initialCurrencyArrays;\n    }\n  }, {\n    key: \"haveProviderRates\",\n    get: function get() {\n      var _this3 = this;\n\n      return Object.keys(this.providerRateUpdates).every(function (providerName) {\n        return _this3.providerRatesRecieved.includes(providerName);\n      });\n    }\n  }, {\n    key: \"ratesRetrieved\",\n    get: function get() {\n      var result = true;\n      this.providers.forEach(function (provider) {\n        if (!provider.ratesRetrieved) {\n          result = false;\n        }\n      });\n      return result;\n    }\n  }], [{\n    key: \"isToken\",\n    value: function isToken(currency) {\n      return !!EthereumTokens[currency];\n    }\n  }, {\n    key: \"isNotToken\",\n    value: function isNotToken(currency) {\n      return !EthereumTokens[currency];\n    }\n  }, {\n    key: \"getTokenDecimals\",\n    value: function getTokenDecimals(currency) {\n      if (SwapProviders.isToken(currency)) {\n        return EthereumTokens[currency].decimals;\n      } else if (currency === 'ETH') {\n        return 18;\n      }\n\n      throw Error('Not an Ethereum Token');\n    } // Get address explorer base url for non-ethereum blockchain\n\n  }, {\n    key: \"getAddressLookupUrl\",\n    value: function getAddressLookupUrl(coin, address) {\n      if (OtherCoins[coin] && OtherCoins[coin].addressLookup) {\n        if (address) {\n          return OtherCoins[coin].addressLookup.replace('[[address]]', address);\n        }\n\n        return OtherCoins[coin].addressLookup;\n      }\n\n      return '';\n    } // Get transaction explorer base url for non-ethereum blockchain\n\n  }, {\n    key: \"getBlockChainExplorerUrl\",\n    value: function getBlockChainExplorerUrl(coin, hash) {\n      if (OtherCoins[coin] && OtherCoins[coin].explorer) {\n        if (hash) {\n          return OtherCoins[coin].explorer.replace('[[txHash]]', hash);\n        }\n\n        return OtherCoins[coin].explorer;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"checkAddress\",\n    value: function checkAddress(address, currency) {\n      var validAddress = false;\n\n      try {\n        validAddress = WAValidator.validate(address, currency);\n      } catch (e) {\n        try {\n          validAddress = MAValidator.validate(address, currency);\n        } catch (e) {\n          validAddress = false;\n        }\n      }\n\n      return validAddress;\n    }\n  }]);\n\n  return SwapProviders;\n}();\n\nexport { SwapProviders as default };",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/partners/partners.js"],"names":["BigNumber","WAValidator","MAValidator","checkInvalidOrMissingValue","bestProviderForQuantity","utils","BASE_CURRENCY","TOP_OPTIONS_ORDER","EthereumTokens","OtherCoins","fiat","comparator","arrayForSort","a","b","symbol","includes","indexOf","SwapProviders","providers","environmentSupplied","misc","online","hasOwnProperty","providerConstructors","setup","overrideDecimals","updateProviderRates","Map","providerRateUpdates","ownedTokenList","tokensWithBalance","providerRatesRecieved","forEach","entry","getName","set","checkCount","network","checkIfAllRatesReceived","setInterval","checkIfRatesPresent","ratesRetrieved","Object","keys","clearInterval","initialCurrencyArrays","buildInitialCurrencyArrays","tokens","mapToObject","name","isProvider","Error","get","has","web3","provider","setNetwork","hasRates","push","array","tokenNameMap","sort","balance","map","item","reverse","arraysForSort","collectMapTo","collectMapFrom","getInitialCurrencyEntries","toArray","optionSorting","Array","from","values","fromArray","value","collectMap","getUpdatedFromCurrencyEntries","getUpdatedToCurrencyEntries","fromCurrency","toCurrency","fromValue","haveProviderRates","providersFound","callsToMake","Number","isNaN","validSwap","getRate","bind","toValue","updateRateEstimate","Promise","all","func","results","every","vals","rate","minValue","maxValue","computeConversion","_fromValue","times","toFixed","toString","length","currency","noError","isToken","contractAddress","bestRate","decimals","decimalForCalculation","div","find","decimal","getTokenDecimals","token","denominator","pow","providerDetails","toAddress","fromAddress","refundAddress","swapDetails","timestamp","Date","toISOString","maybeToken","startSwap","baseCurrency","tokenBalances","enteredVal","convertToTokenWei","gte","gt","providerName","result","coin","address","addressLookup","replace","hash","explorer","validAddress","validate","e"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js';\nimport WAValidator from 'wallet-address-validator';\nimport MAValidator from 'multicoin-address-validator';\nimport {\n  checkInvalidOrMissingValue,\n  bestProviderForQuantity,\n  utils\n} from './helpers';\nimport {\n  BASE_CURRENCY,\n  TOP_OPTIONS_ORDER,\n  EthereumTokens,\n  OtherCoins,\n  fiat\n} from './partnersConfig';\n\nfunction comparator(arrayForSort) {\n  if (!arrayForSort) arrayForSort = TOP_OPTIONS_ORDER;\n  return (a, b) => {\n    a = a.symbol;\n    b = b.symbol;\n    if (arrayForSort.includes(a) || arrayForSort.includes(b)) {\n      return arrayForSort.indexOf(b) - arrayForSort.indexOf(a);\n    }\n    return a < b ? -1 : a > b ? 1 : 0;\n  };\n}\n\nexport default class SwapProviders {\n  constructor(providers, environmentSupplied, misc = {}) {\n    this.online = true;\n    if (misc.hasOwnProperty('online')) {\n      this.online = misc.online;\n    }\n    this.providerConstructors = providers;\n    this.setup(providers, environmentSupplied, misc);\n  }\n\n  setup(providers, environmentSupplied, misc) {\n    this.overrideDecimals = misc.overrideDecimals || false;\n    this.updateProviderRates = 0;\n    this.providers = new Map();\n    this.providerRateUpdates = {};\n    this.ownedTokenList = misc.tokensWithBalance || [];\n    this.providerRatesRecieved = [];\n\n    if (!this.online) return;\n    providers.forEach(entry => {\n      this.providerRateUpdates[entry.getName()] = 0;\n      this.providers.set(entry.getName(), new entry(environmentSupplied));\n    });\n\n    this.providerRatesRecieved = [];\n\n    let checkCount = 0;\n    if (environmentSupplied.network !== BASE_CURRENCY) {\n      const checkIfAllRatesReceived = setInterval(() => {\n        checkCount++;\n        this.checkIfRatesPresent();\n        if (this.ratesRetrieved || checkCount > 20) {\n          this.providerRatesRecieved = Object.keys(this.providerRateUpdates);\n          clearInterval(checkIfAllRatesReceived);\n        }\n      }, 150);\n    } else {\n      const checkIfAllRatesReceived = setInterval(() => {\n        checkCount++;\n        this.checkIfRatesPresent();\n        if (this.ratesRetrieved || checkCount > 50) {\n          this.providerRatesRecieved = Object.keys(this.providerRateUpdates);\n          clearInterval(checkIfAllRatesReceived);\n        }\n      }, 150);\n    }\n\n    this.initialCurrencyArrays = this.buildInitialCurrencyArrays();\n  }\n\n  get initialCurrencyLists() {\n    return this.initialCurrencyArrays;\n  }\n\n  get haveProviderRates() {\n    return Object.keys(this.providerRateUpdates).every(providerName => {\n      return this.providerRatesRecieved.includes(providerName);\n    });\n  }\n\n  get ratesRetrieved() {\n    let result = true;\n    this.providers.forEach(provider => {\n      if (!provider.ratesRetrieved) {\n        result = false;\n      }\n    });\n    return result;\n  }\n\n  ownedTokens(tokens) {\n    this.ownedTokenList = tokens;\n  }\n\n  getProviders() {\n    return utils.mapToObject(this.providers);\n  }\n\n  getProvider(name) {\n    if (!this.isProvider(name))\n      throw Error(`${name} is not a supported swap provider`);\n    return this.providers.get(name);\n  }\n\n  isProvider(name) {\n    if (!this.online) return false;\n    return this.providers.has(name);\n  }\n\n  updateNetwork(network, web3) {\n    this.providers.forEach(provider => {\n      provider.setNetwork(network, web3);\n    });\n  }\n\n  checkIfRatesPresent() {\n    this.providers.forEach(provider => {\n      if (\n        !this.providerRatesRecieved.includes(provider.name) &&\n        provider.hasRates > 0\n      ) {\n        this.updateProviderRates++;\n        this.providerRatesRecieved.push(provider.name);\n      }\n    });\n  }\n\n  // Note: Seems to not always float user held tokens to the top??\n  // Does in general, but have observed some instances where it did not.\n  optionSorting(array) {\n    const tokens = [...this.ownedTokenList];\n\n    const tokenNameMap = tokens\n      .sort((a, b) => {\n        if (a.hasOwnProperty('balance') && b.hasOwnProperty('balance')) {\n          return b.balance - a.balance;\n        }\n        return 0;\n      })\n      .map(item => item.symbol)\n      .reverse();\n    const arraysForSort = [...tokenNameMap, ...TOP_OPTIONS_ORDER];\n    return array.sort(comparator(arraysForSort));\n  }\n\n  buildInitialCurrencyArrays() {\n    const collectMapTo = new Map();\n    const collectMapFrom = new Map();\n    this.providers.forEach(provider => {\n      provider.getInitialCurrencyEntries(collectMapFrom, collectMapTo);\n    });\n\n    const toArray = this.optionSorting(Array.from(collectMapTo.values()));\n    const fromArray = this.optionSorting(Array.from(collectMapFrom.values()));\n    return { toArray, fromArray };\n  }\n\n  setFromCurrencyBuilder(value) {\n    const collectMap = new Map();\n    this.providers.forEach(provider => {\n      provider.getUpdatedFromCurrencyEntries(value, collectMap);\n    });\n    return this.optionSorting(Array.from(collectMap.values()));\n  }\n\n  setToCurrencyBuilder(value) {\n    const collectMap = new Map();\n    this.providers.forEach(provider => {\n      provider.getUpdatedToCurrencyEntries(value, collectMap);\n    });\n    return this.optionSorting(Array.from(collectMap.values()));\n  }\n\n  async updateRateEstimate(fromCurrency, toCurrency, fromValue) {\n    if (this.haveProviderRates) {\n      const providersFound = [];\n      const callsToMake = [];\n      if (\n        +fromValue > 0 &&\n        fromCurrency !== toCurrency &&\n        !Number.isNaN(+fromValue)\n      ) {\n        this.providers.forEach(provider => {\n          if (provider.validSwap(fromCurrency, toCurrency)) {\n            callsToMake.push(provider.getRate.bind(provider));\n            providersFound.push(provider.name);\n          }\n        });\n        return { providersFound, callsToMake };\n      }\n    }\n    return {\n      providersFound: [],\n      callsToMake: []\n    };\n  }\n\n  async standAloneRateEstimate(\n    fromCurrency,\n    toCurrency,\n    fromValue,\n    toValue = 0\n  ) {\n    if (this.haveProviderRates) {\n      const { callsToMake } = await this.updateRateEstimate(\n        fromCurrency,\n        toCurrency,\n        fromValue,\n        toValue\n      );\n      const results = await Promise.all(\n        callsToMake.map(func =>\n          func(fromCurrency, toCurrency, fromValue, toValue)\n        )\n      );\n      if (\n        results.every(\n          entry =>\n            entry.fromCurrency === fromCurrency &&\n            entry.toCurrency === toCurrency\n        )\n      ) {\n        const vals = bestProviderForQuantity(\n          results.map(entry => {\n            if (+entry.rate > 0) {\n              return {\n                provider: entry.provider,\n                fromCurrency,\n                fromValue: fromValue,\n                toCurrency,\n                rate: +entry.rate,\n                minValue: entry.minValue || 0,\n                maxValue: entry.maxValue || 0,\n                computeConversion: function(_fromValue) {\n                  return new BigNumber(_fromValue)\n                    .times(this.rate)\n                    .toFixed(6)\n                    .toString(10);\n                }\n              };\n            }\n          }),\n          fromValue\n        );\n        if (vals.length === 0) {\n          return [{}];\n        }\n        return vals;\n      }\n    }\n  }\n\n  getTokenAddress(currency, noError) {\n    if (SwapProviders.isToken(currency)) {\n      return EthereumTokens[currency].contractAddress;\n    }\n    if (noError) {\n      return false;\n    }\n    throw Error('Not an Ethereum Token');\n  }\n\n  calculateFromValue(toValue, bestRate, currency) {\n    const decimals = this.decimalForCalculation(currency);\n    return checkInvalidOrMissingValue(\n      new BigNumber(toValue)\n        .div(new BigNumber(bestRate))\n        .toFixed(decimals)\n        .toString(10),\n      false\n    );\n  }\n\n  calculateToValue(fromValue, bestRate, currency) {\n    const decimals = this.decimalForCalculation(currency);\n    return checkInvalidOrMissingValue(\n      new BigNumber(fromValue)\n        .times(new BigNumber(bestRate))\n        .toFixed(decimals)\n        .toString(10),\n      true\n    );\n  }\n\n  decimalForCalculation(currency) {\n    if (!currency) return 6;\n    if (fiat.find(entry => entry.symbol === currency)) {\n      return 2;\n    } else if (SwapProviders.isToken(currency)) {\n      const decimal = SwapProviders.getTokenDecimals(currency);\n      if (decimal < 6) return decimal;\n      if (this.overrideDecimals) return decimal;\n      return 6;\n    }\n    return 6;\n  }\n\n  convertToTokenWei(token, value) {\n    const decimals = SwapProviders.getTokenDecimals(token);\n    const denominator = new BigNumber(10).pow(decimals);\n    return new BigNumber(value)\n      .times(denominator)\n      .toFixed(0)\n      .toString(10);\n  }\n\n  convertToTokenBase(token, value) {\n    const decimals = SwapProviders.getTokenDecimals(token);\n    const denominator = new BigNumber(10).pow(decimals);\n    return new BigNumber(value).div(denominator).toString(10);\n  }\n\n  async startSwap({\n    providerDetails,\n    fromValue,\n    toValue,\n    toAddress,\n    fromAddress,\n    refundAddress\n  }) {\n    try {\n      const swapDetails = {\n        provider: providerDetails.provider,\n        fromCurrency: providerDetails.fromCurrency,\n        fromValue: fromValue,\n        toValue: toValue,\n        toCurrency: providerDetails.toCurrency,\n        rate: providerDetails.rate,\n        minValue: providerDetails.minValue,\n        maxValue: providerDetails.maxValue,\n        toAddress: toAddress,\n        fromAddress: fromAddress,\n        timestamp: new Date().toISOString(),\n        refundAddress: refundAddress\n      };\n      if (this.providers.has(swapDetails.provider)) {\n        const provider = this.providers.get(swapDetails.provider);\n        swapDetails.maybeToken = SwapProviders.isToken(\n          swapDetails.fromCurrency\n        );\n        return provider.startSwap(swapDetails);\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  // Helper Methods\n  hasEnough(fromCurrency, fromValue, baseCurrency, tokenBalances, balance) {\n    if (SwapProviders.isToken(fromCurrency) && fromCurrency !== baseCurrency) {\n      const enteredVal = this.convertToTokenWei(fromCurrency, fromValue);\n\n      return new BigNumber(tokenBalances[fromCurrency]).gte(\n        new BigNumber(enteredVal)\n      );\n    } else if (fromCurrency === baseCurrency) {\n      const enteredVal = this.convertToTokenWei(fromCurrency, fromValue);\n      return new BigNumber(balance).gt(new BigNumber(enteredVal));\n    }\n    return true;\n  }\n\n  // Static Methods\n\n  static isToken(currency) {\n    return !!EthereumTokens[currency];\n  }\n\n  static isNotToken(currency) {\n    return !EthereumTokens[currency];\n  }\n\n  static getTokenDecimals(currency) {\n    if (SwapProviders.isToken(currency)) {\n      return EthereumTokens[currency].decimals;\n    } else if (currency === 'ETH') {\n      return 18;\n    }\n    throw Error('Not an Ethereum Token');\n  }\n\n  // Get address explorer base url for non-ethereum blockchain\n  static getAddressLookupUrl(coin, address) {\n    if (OtherCoins[coin] && OtherCoins[coin].addressLookup) {\n      if (address) {\n        return OtherCoins[coin].addressLookup.replace('[[address]]', address);\n      }\n      return OtherCoins[coin].addressLookup;\n    }\n    return '';\n  }\n  // Get transaction explorer base url for non-ethereum blockchain\n  static getBlockChainExplorerUrl(coin, hash) {\n    if (OtherCoins[coin] && OtherCoins[coin].explorer) {\n      if (hash) {\n        return OtherCoins[coin].explorer.replace('[[txHash]]', hash);\n      }\n      return OtherCoins[coin].explorer;\n    }\n    return '';\n  }\n\n  static checkAddress(address, currency) {\n    let validAddress = false;\n    try {\n      validAddress = WAValidator.validate(address, currency);\n    } catch (e) {\n      try {\n        validAddress = MAValidator.validate(address, currency);\n      } catch (e) {\n        validAddress = false;\n      }\n    }\n    return validAddress;\n  }\n}\n"]}]}