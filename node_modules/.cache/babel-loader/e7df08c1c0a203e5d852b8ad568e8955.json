{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/thread-loader/dist/cjs.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/WalletInterface.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/WalletInterface.js","mtime":1574664278322},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/thread-loader/dist/cjs.js","mtime":1574664277654},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js","mtime":1574664275010},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/eslint-loader/index.js","mtime":1574664275986}],"contextDependencies":[],"result":["import _classCallCheck from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { getBufferFromHex, getSignTransactionObject, sanitizeHex, calculateChainIdFromV } from \"./utils\";\nimport { hashPersonalMessage, publicToAddress, toBuffer, bufferToHex, ecsign, isValidPrivate, isValidPublic, privateToPublic } from 'ethereumjs-util';\nimport commonGenerator from '@/helpers/commonGenerator';\nimport { Transaction } from 'ethereumjs-tx';\nimport { toChecksumAddress } from '@/helpers/addressUtils';\nimport store from '@/store';\n\nvar WalletInterface =\n/*#__PURE__*/\nfunction () {\n  function WalletInterface(key) {\n    var isPub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var identifier = arguments.length > 2 ? arguments[2] : undefined;\n    var nick = arguments.length > 3 ? arguments[3] : undefined;\n    var keystore = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, WalletInterface);\n\n    this.nickname = nick !== null && nick !== '' ? nick : '';\n    this.keystore = keystore !== null && keystore !== '' ? keystore : '';\n    this.identifier = identifier;\n\n    if (!isPub) {\n      var _privKey = Buffer.isBuffer(key) ? key : getBufferFromHex(sanitizeHex(key));\n\n      if (!isValidPrivate(_privKey)) throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');\n      this.privateKey = _privKey;\n      this.publicKey = privateToPublic(_privKey);\n      this.isPubOnly = false;\n    } else {\n      var _pubKey = Buffer.isBuffer(key) ? key : getBufferFromHex(key);\n\n      if (_pubKey.length !== 20 && !isValidPublic(_pubKey, true)) throw new Error('Invalid public key');\n      if (_pubKey.length === 20) this.isAddress = true;\n      this.publicKey = _pubKey;\n      this.isPubOnly = true;\n    }\n  }\n\n  _createClass(WalletInterface, [{\n    key: \"getPrivateKey\",\n    value: function getPrivateKey() {\n      if (this.isPubOnly) throw new Error('public key only wallet');\n      return this.privateKey;\n    }\n  }, {\n    key: \"getPrivateKeyString\",\n    value: function getPrivateKeyString() {\n      if (this.isPubOnly) throw new Error('public key only wallet');\n      return bufferToHex(this.getPrivateKey());\n    }\n  }, {\n    key: \"getNickname\",\n    value: function getNickname() {\n      if (this.nickname === '') return '';\n      return this.nickname;\n    }\n  }, {\n    key: \"getKeystore\",\n    value: function getKeystore() {\n      if (this.keystore === '') return '';\n      return this.keystore;\n    }\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey() {\n      if (this.isAddress) throw new Error('Address only wallet');\n      return this.publicKey;\n    }\n  }, {\n    key: \"getPublicKeyString\",\n    value: function getPublicKeyString() {\n      return bufferToHex(this.getPublicKey());\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      if (this.isAddress) return this.publicKey;\n      return publicToAddress(this.publicKey, true);\n    }\n  }, {\n    key: \"getAddressString\",\n    value: function getAddressString() {\n      return bufferToHex(this.getAddress());\n    }\n  }, {\n    key: \"getChecksumAddressString\",\n    value: function getChecksumAddressString() {\n      return toChecksumAddress(this.getAddressString());\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(txParams, signer) {\n      var _this = this;\n\n      if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');\n      return new Promise(function (resolve, reject) {\n        if (!_this.isPubOnly) {\n          var tx = new Transaction(txParams, {\n            common: commonGenerator(store.state.network)\n          });\n          var networkId = tx.getChainId();\n          tx.sign(_this.privateKey);\n          var signedChainId = calculateChainIdFromV(tx.v);\n          if (signedChainId !== networkId) throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n          resolve(getSignTransactionObject(tx));\n        } else {\n          signer(txParams).then(resolve).catch(reject);\n        }\n      });\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(msg, signer) {\n      var _this2 = this;\n\n      if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');\n      return new Promise(function (resolve, reject) {\n        if (!_this2.isPubOnly) {\n          var msgHash = hashPersonalMessage(toBuffer(msg));\n          var signed = ecsign(msgHash, _this2.privateKey);\n          resolve(Buffer.concat([Buffer.from(signed.r), Buffer.from(signed.s), Buffer.from([signed.v])]));\n        } else {\n          signer(msg).then(resolve).catch(reject);\n        }\n      });\n    }\n  }]);\n\n  return WalletInterface;\n}();\n\nexport default WalletInterface;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/wallets/WalletInterface.js"],"names":["getBufferFromHex","getSignTransactionObject","sanitizeHex","calculateChainIdFromV","hashPersonalMessage","publicToAddress","toBuffer","bufferToHex","ecsign","isValidPrivate","isValidPublic","privateToPublic","commonGenerator","Transaction","toChecksumAddress","store","WalletInterface","key","isPub","identifier","nick","keystore","nickname","_privKey","Buffer","isBuffer","Error","privateKey","publicKey","isPubOnly","_pubKey","length","isAddress","getPrivateKey","getPublicKey","getAddress","getAddressString","txParams","signer","Promise","resolve","reject","tx","common","state","network","networkId","getChainId","sign","signedChainId","v","then","catch","msg","msgHash","signed","concat","from","r","s"],"mappings":"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","sourcesContent":["import {\n  getBufferFromHex,\n  getSignTransactionObject,\n  sanitizeHex,\n  calculateChainIdFromV\n} from './utils';\nimport {\n  hashPersonalMessage,\n  publicToAddress,\n  toBuffer,\n  bufferToHex,\n  ecsign,\n  isValidPrivate,\n  isValidPublic,\n  privateToPublic\n} from 'ethereumjs-util';\nimport commonGenerator from '@/helpers/commonGenerator';\nimport { Transaction } from 'ethereumjs-tx';\nimport { toChecksumAddress } from '@/helpers/addressUtils';\nimport store from '@/store';\nclass WalletInterface {\n  constructor(key, isPub = false, identifier, nick, keystore) {\n    this.nickname = nick !== null && nick !== '' ? nick : '';\n    this.keystore = keystore !== null && keystore !== '' ? keystore : '';\n    this.identifier = identifier;\n    if (!isPub) {\n      const _privKey = Buffer.isBuffer(key)\n        ? key\n        : getBufferFromHex(sanitizeHex(key));\n      if (!isValidPrivate(_privKey))\n        throw new Error(\n          'Private key does not satisfy the curve requirements (ie. it is invalid)'\n        );\n      this.privateKey = _privKey;\n      this.publicKey = privateToPublic(_privKey);\n      this.isPubOnly = false;\n    } else {\n      const _pubKey = Buffer.isBuffer(key) ? key : getBufferFromHex(key);\n      if (_pubKey.length !== 20 && !isValidPublic(_pubKey, true))\n        throw new Error('Invalid public key');\n      if (_pubKey.length === 20) this.isAddress = true;\n      this.publicKey = _pubKey;\n      this.isPubOnly = true;\n    }\n  }\n  getPrivateKey() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return this.privateKey;\n  }\n\n  getPrivateKeyString() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return bufferToHex(this.getPrivateKey());\n  }\n\n  getNickname() {\n    if (this.nickname === '') return '';\n    return this.nickname;\n  }\n\n  getKeystore() {\n    if (this.keystore === '') return '';\n    return this.keystore;\n  }\n\n  getPublicKey() {\n    if (this.isAddress) throw new Error('Address only wallet');\n    return this.publicKey;\n  }\n\n  getPublicKeyString() {\n    return bufferToHex(this.getPublicKey());\n  }\n\n  getAddress() {\n    if (this.isAddress) return this.publicKey;\n    return publicToAddress(this.publicKey, true);\n  }\n\n  getAddressString() {\n    return bufferToHex(this.getAddress());\n  }\n\n  getChecksumAddressString() {\n    return toChecksumAddress(this.getAddressString());\n  }\n  signTransaction(txParams, signer) {\n    if (this.isPubOnly && typeof signer !== 'function')\n      throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n      if (!this.isPubOnly) {\n        const tx = new Transaction(txParams, {\n          common: commonGenerator(store.state.network)\n        });\n        const networkId = tx.getChainId();\n        tx.sign(this.privateKey);\n        const signedChainId = calculateChainIdFromV(tx.v);\n        if (signedChainId !== networkId)\n          throw new Error(\n            'Invalid networkId signature returned. Expected: ' +\n              networkId +\n              ', Got: ' +\n              signedChainId,\n            'InvalidNetworkId'\n          );\n        resolve(getSignTransactionObject(tx));\n      } else {\n        signer(txParams)\n          .then(resolve)\n          .catch(reject);\n      }\n    });\n  }\n  signMessage(msg, signer) {\n    if (this.isPubOnly && typeof signer !== 'function')\n      throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n      if (!this.isPubOnly) {\n        const msgHash = hashPersonalMessage(toBuffer(msg));\n        const signed = ecsign(msgHash, this.privateKey);\n        resolve(\n          Buffer.concat([\n            Buffer.from(signed.r),\n            Buffer.from(signed.s),\n            Buffer.from([signed.v])\n          ])\n        );\n      } else {\n        signer(msg)\n          .then(resolve)\n          .catch(reject);\n      }\n    });\n  }\n}\nexport default WalletInterface;\n"]}]}