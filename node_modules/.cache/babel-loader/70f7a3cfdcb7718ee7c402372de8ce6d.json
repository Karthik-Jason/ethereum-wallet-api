{"remainingRequest":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/thread-loader/dist/cjs.js!/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js!/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js??ref--13-0!/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/trezor/index.js","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/trezor/index.js","mtime":1573477612120},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/karthik/Desktop/myetherwallet/MyEtherWallet/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport Trezor from 'trezor-connect';\nimport { TREZOR as trezorType } from \"../../bip44/walletTypes\";\nimport bip44Paths from \"../../bip44\";\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport { Transaction } from 'ethereumjs-tx';\nimport { getSignTransactionObject, getHexTxObject, getBufferFromHex, calculateChainIdFromV } from \"../../utils\";\nimport { toBuffer } from 'ethereumjs-util';\nimport errorHandler from \"./errorHandler\";\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nvar NEED_PASSWORD = false;\n\nvar TrezorWallet =\n/*#__PURE__*/\nfunction () {\n  function TrezorWallet() {\n    _classCallCheck(this, TrezorWallet);\n\n    Trezor.manifest({\n      email: 'dev@myetherwallet.com',\n      appUrl: 'https://www.myetherwallet.com'\n    });\n    this.identifier = trezorType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[trezorType];\n  }\n\n  _createClass(TrezorWallet, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(basePath) {\n        var rootPub;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n                _context.next = 3;\n                return getRootPubKey(this.basePath);\n\n              case 3:\n                rootPub = _context.sent;\n                this.hdKey = new HDKey();\n                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(idx) {\n      var _this = this;\n\n      var derivedKey = this.hdKey.derive('m/' + idx);\n\n      var txSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(tx) {\n          var networkId, options, result, signedChainId;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  tx = new Transaction(tx, {\n                    common: commonGenerator(store.state.network)\n                  });\n                  networkId = tx.getChainId();\n                  options = {\n                    path: _this.basePath + '/' + idx,\n                    transaction: getHexTxObject(tx)\n                  };\n                  _context2.next = 5;\n                  return Trezor.ethereumSignTransaction(options);\n\n                case 5:\n                  result = _context2.sent;\n\n                  if (result.success) {\n                    _context2.next = 8;\n                    break;\n                  }\n\n                  throw new Error(result.payload.error);\n\n                case 8:\n                  tx.v = getBufferFromHex(result.payload.v);\n                  tx.r = getBufferFromHex(result.payload.r);\n                  tx.s = getBufferFromHex(result.payload.s);\n                  signedChainId = calculateChainIdFromV(tx.v);\n\n                  if (!(signedChainId !== networkId)) {\n                    _context2.next = 14;\n                    break;\n                  }\n\n                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');\n\n                case 14:\n                  return _context2.abrupt(\"return\", getSignTransactionObject(tx));\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function txSigner(_x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var msgSigner =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee3(msg) {\n          var result;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return Trezor.ethereumSignMessage({\n                    path: _this.basePath + '/' + idx,\n                    message: toBuffer(msg).toString('hex'),\n                    hex: true\n                  });\n\n                case 2:\n                  result = _context3.sent;\n\n                  if (result.success) {\n                    _context3.next = 5;\n                    break;\n                  }\n\n                  throw new Error(result.payload.error);\n\n                case 5:\n                  return _context3.abrupt(\"return\", getBufferFromHex(result.payload.signature));\n\n                case 6:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function msgSigner(_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      var displayAddress =\n      /*#__PURE__*/\n      function () {\n        var _ref3 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee4() {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return Trezor.ethereumGetAddress({\n                    path: _this.basePath + '/' + idx,\n                    showOnTrezor: true\n                  });\n\n                case 2:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        return function displayAddress() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n\n      return new HDWalletInterface(this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, errorHandler, txSigner, msgSigner, displayAddress);\n    }\n  }, {\n    key: \"getCurrentPath\",\n    value: function getCurrentPath() {\n      return this.basePath;\n    }\n  }, {\n    key: \"getSupportedPaths\",\n    value: function getSupportedPaths() {\n      return this.supportedPaths;\n    }\n  }]);\n\n  return TrezorWallet;\n}();\n\nvar createWallet =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee5(basePath) {\n    var _trezorWallet;\n\n    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _trezorWallet = new TrezorWallet();\n            _context5.next = 3;\n            return _trezorWallet.init(basePath);\n\n          case 3:\n            return _context5.abrupt(\"return\", _trezorWallet);\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function createWallet(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\ncreateWallet.errorHandler = errorHandler;\n\nvar getRootPubKey =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee6(_path) {\n    var result;\n    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return Trezor.ethereumGetPublicKey({\n              path: _path\n            });\n\n          case 2:\n            result = _context6.sent;\n\n            if (result.payload) {\n              _context6.next = 5;\n              break;\n            }\n\n            throw new Error('popup failed to open');\n\n          case 5:\n            if (result.success) {\n              _context6.next = 7;\n              break;\n            }\n\n            throw new Error(result.payload.error);\n\n          case 7:\n            return _context6.abrupt(\"return\", {\n              publicKey: result.payload.publicKey,\n              chainCode: result.payload.chainCode\n            });\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function getRootPubKey(_x5) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexport default createWallet;",{"version":3,"sources":["/home/karthik/Desktop/myetherwallet/MyEtherWallet/src/wallets/hardware/trezor/index.js"],"names":["Trezor","TREZOR","trezorType","bip44Paths","HDWalletInterface","HDKey","Transaction","getSignTransactionObject","getHexTxObject","getBufferFromHex","calculateChainIdFromV","toBuffer","errorHandler","store","commonGenerator","NEED_PASSWORD","TrezorWallet","manifest","email","appUrl","identifier","isHardware","needPassword","supportedPaths","basePath","path","getRootPubKey","rootPub","hdKey","publicKey","Buffer","from","chainCode","idx","derivedKey","derive","txSigner","tx","common","state","network","networkId","getChainId","options","transaction","ethereumSignTransaction","result","success","Error","payload","error","v","r","s","signedChainId","msgSigner","msg","ethereumSignMessage","message","toString","hex","signature","displayAddress","ethereumGetAddress","showOnTrezor","createWallet","_trezorWallet","init","_path","ethereumGetPublicKey"],"mappings":"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","sourcesContent":["import Trezor from 'trezor-connect';\nimport { TREZOR as trezorType } from '../../bip44/walletTypes';\nimport bip44Paths from '../../bip44';\nimport HDWalletInterface from '@/wallets/HDWalletInterface';\nimport * as HDKey from 'hdkey';\nimport { Transaction } from 'ethereumjs-tx';\nimport {\n  getSignTransactionObject,\n  getHexTxObject,\n  getBufferFromHex,\n  calculateChainIdFromV\n} from '../../utils';\nimport { toBuffer } from 'ethereumjs-util';\nimport errorHandler from './errorHandler';\nimport store from '@/store';\nimport commonGenerator from '@/helpers/commonGenerator';\nconst NEED_PASSWORD = false;\n\nclass TrezorWallet {\n  constructor() {\n    Trezor.manifest({\n      email: 'dev@myetherwallet.com',\n      appUrl: 'https://www.myetherwallet.com'\n    });\n\n    this.identifier = trezorType;\n    this.isHardware = true;\n    this.needPassword = NEED_PASSWORD;\n    this.supportedPaths = bip44Paths[trezorType];\n  }\n  async init(basePath) {\n    this.basePath = basePath ? basePath : this.supportedPaths[0].path;\n    const rootPub = await getRootPubKey(this.basePath);\n    this.hdKey = new HDKey();\n    this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');\n    this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');\n  }\n  getAccount(idx) {\n    const derivedKey = this.hdKey.derive('m/' + idx);\n    const txSigner = async tx => {\n      tx = new Transaction(tx, {\n        common: commonGenerator(store.state.network)\n      });\n      const networkId = tx.getChainId();\n      const options = {\n        path: this.basePath + '/' + idx,\n        transaction: getHexTxObject(tx)\n      };\n      const result = await Trezor.ethereumSignTransaction(options);\n      if (!result.success) throw new Error(result.payload.error);\n      tx.v = getBufferFromHex(result.payload.v);\n      tx.r = getBufferFromHex(result.payload.r);\n      tx.s = getBufferFromHex(result.payload.s);\n      const signedChainId = calculateChainIdFromV(tx.v);\n      if (signedChainId !== networkId)\n        throw new Error(\n          'Invalid networkId signature returned. Expected: ' +\n            networkId +\n            ', Got: ' +\n            signedChainId,\n          'InvalidNetworkId'\n        );\n      return getSignTransactionObject(tx);\n    };\n    const msgSigner = async msg => {\n      const result = await Trezor.ethereumSignMessage({\n        path: this.basePath + '/' + idx,\n        message: toBuffer(msg).toString('hex'),\n        hex: true\n      });\n      if (!result.success) throw new Error(result.payload.error);\n      return getBufferFromHex(result.payload.signature);\n    };\n    const displayAddress = async () => {\n      await Trezor.ethereumGetAddress({\n        path: this.basePath + '/' + idx,\n        showOnTrezor: true\n      });\n    };\n    return new HDWalletInterface(\n      this.basePath + '/' + idx,\n      derivedKey.publicKey,\n      this.isHardware,\n      this.identifier,\n      errorHandler,\n      txSigner,\n      msgSigner,\n      displayAddress\n    );\n  }\n  getCurrentPath() {\n    return this.basePath;\n  }\n  getSupportedPaths() {\n    return this.supportedPaths;\n  }\n}\nconst createWallet = async basePath => {\n  const _trezorWallet = new TrezorWallet();\n  await _trezorWallet.init(basePath);\n  return _trezorWallet;\n};\ncreateWallet.errorHandler = errorHandler;\nconst getRootPubKey = async _path => {\n  const result = await Trezor.ethereumGetPublicKey({ path: _path });\n  if (!result.payload) {\n    throw new Error('popup failed to open');\n  }\n  if (!result.success) throw new Error(result.payload.error);\n  return {\n    publicKey: result.payload.publicKey,\n    chainCode: result.payload.chainCode\n  };\n};\n\nexport default createWallet;\n"]}]}