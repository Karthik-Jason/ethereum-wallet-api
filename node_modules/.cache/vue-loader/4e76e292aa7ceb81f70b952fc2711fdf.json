{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/layouts/InterfaceLayout/containers/NFTManagerContainer/NFTManagerContainer.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/layouts/InterfaceLayout/containers/NFTManagerContainer/NFTManagerContainer.vue","mtime":1573477612020},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport store from 'store';\nimport LoadingSign from '@/components/LoadingSign';\nimport InterfaceContainerTitle from '@/layouts/InterfaceLayout/components/InterfaceContainerTitle';\nimport ContentBlockTitle from '@/layouts/InterfaceLayout/components/ContentBlockTitle';\nimport NFTSideMenu from '@/layouts/InterfaceLayout/containers/NFTManagerContainer/components/NFTSideMenu';\nimport NftDetails from './components/NftDetails';\nimport NftCustomAddModal from './components/NftCustomAddModal';\nimport NftCustomConfirmRemove from './components/NftCustomConfirmRemove';\nimport { mapState } from 'vuex';\nimport hexDecoder from './binaryDecoderNFT';\nimport { nftABI } from './abis';\nimport StandardButton from '@/components/Buttons/StandardButton';\nimport placeholderImage from '@/assets/images/icons/defaultToken.png';\nimport utils from 'web3-utils';\n\nconst URL_BASE = 'https://nft.mewapi.io/nft';\n\nexport default {\n  components: {\n    'nft-custom-add-modal': NftCustomAddModal,\n    'nft-custom-confirm-remove-modal': NftCustomConfirmRemove,\n    'loading-sign': LoadingSign,\n    'content-block-title': ContentBlockTitle,\n    'nft-side-menu': NFTSideMenu,\n    'interface-container-title': InterfaceContainerTitle,\n    'nft-details': NftDetails,\n    'standard-button': StandardButton\n  },\n  filters: {\n    ConcatToken(value) {\n      if (!value) return '';\n      if (value.length > 20)\n        return `${value.substr(0, 15)}...${value.substr(value.length - 6)}`;\n      return value;\n    }\n  },\n  data() {\n    return {\n      nftABI,\n      countPerPage: 9,\n      nftConfig: [],\n      tokenHelper: {},\n      mayHaveTokens: [true, true],\n      countsRetrieved: false,\n      showDetails: false,\n      reLoading: false,\n      selectedContract: '0x06012c8cf97bead5deae237070f9587f8e7a266d',\n      detailsFor: {},\n      nftTokens: {},\n      nftData: {},\n      ownedTokens: [],\n      tokenContractAddress: '0xeA3352C1a3480Ac5a32Fcd1F2854529BA7193F14',\n      sentUpdate: 0,\n      customNFTs: [],\n      forRemoval: {},\n      collectionLoading: false,\n      onlyCustom: {\n        title: this.$t('dapps.addCustomNFT'),\n        buttonStyle: 'green',\n        helpCenter: false,\n        noMinWidth: true,\n        fullWidth: false\n      },\n      nftObjectClone: {}\n    };\n  },\n  computed: {\n    ...mapState(['account', 'web3', 'online', 'network']),\n    endIndex() {\n      if (this.nftData[this.selectedContract]) {\n        if (!this.nftData[this.selectedContract].details) return 0;\n        const ids_retrieved = this.nftData[this.selectedContract].details\n          .length;\n        const increment =\n          ids_retrieved > this.countPerPage ? this.countPerPage : ids_retrieved;\n        return this.nftData[this.selectedContract].currentIndex + increment;\n      }\n    },\n    nftTitle() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract].title;\n      }\n      return 'Loading';\n    },\n    nftToShow() {\n      if (this.nftData[this.selectedContract]) {\n        if (!this.nftData[this.selectedContract].details) return [];\n        return this.nftData[this.selectedContract].details.length >\n          this.countPerPage\n          ? this.nftData[this.selectedContract].details.slice(\n              this.nftData[this.selectedContract].currentIndex,\n              this.nftData[this.selectedContract].currentIndex +\n                this.countPerPage\n            )\n          : this.nftData[this.selectedContract].details;\n      }\n      return [];\n    },\n    ntfCount() {\n      if (this.nftData[this.selectedContract]) {\n        return this.$t('dapps.nftOwnCount', {\n          perPage: this.countPerPage,\n          count: this.nftData[this.selectedContract].count\n        });\n      }\n\n      return this.$t('dapps.noneOwned');\n    },\n    selectedNtf() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract];\n      }\n      return {};\n    },\n    showNextButton() {\n      if (this.nftData[this.selectedContract]) {\n        const ids_retrieved = this.nftData[this.selectedContract].count;\n        return (\n          this.endIndex !== ids_retrieved && this.endIndex <= ids_retrieved\n        );\n      }\n    },\n    sideMenuData() {\n      return this.nftData;\n    },\n    startIndex() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract].currentIndex;\n      }\n      return 0;\n    },\n    activeAddress() {\n      return this.account.address;\n    },\n    hasNfts() {\n      return Object.values(this.nftData).some(entry => entry.count > 0);\n    },\n    isReady() {\n      return this.isOnlineAndEth && this.countsRetrieved;\n    },\n    isOnlineAndEth() {\n      return this.online && this.network.type.name === 'ETH';\n    }\n  },\n  watch: {},\n  async mounted() {\n    await this.setup();\n  },\n  methods: {\n    addCustom(address, symbol) {\n      this.reLoading = true;\n      this.customNFTs.push({\n        ERC721Extension: true,\n        contract: address,\n        customNft: true,\n        title: symbol\n      });\n      this.$refs.customModal.$refs.modal.hide();\n      store.set('customNFTs', this.customNFTs);\n      this.sentUpdate += 1;\n      this.setup();\n    },\n    removeCustomNft(item) {\n      this.reLoading = true;\n      const customNFTs = store.get('customNFTs');\n      if (customNFTs !== undefined && customNFTs !== null) {\n        const entryIndex = customNFTs.findIndex(\n          entry => item.contract === entry.contract\n        );\n        customNFTs.splice(entryIndex, 1);\n        store.set('customNFTs', customNFTs);\n        this.setup();\n        this.sentUpdate += 1;\n      }\n    },\n    openRemovalConfirmModal(item) {\n      this.forRemoval = item;\n      this.$refs.customRemoveModal.$refs.modal.show();\n    },\n    openCustomModal() {\n      this.$refs.customModal.$refs.modal.show();\n    },\n    hasLoaded(nft) {\n      this.$set(nft, 'loaded', true);\n    },\n    hasImage(nft) {\n      if (nft.customNft) {\n        return true;\n      }\n      if (nft.loaded) {\n        return true;\n      }\n    },\n    removeSentNft(nft) {\n      this.nftObjectClone = utils._.clone(this.nftData[nft.contract]);\n      const afterSent = this.nftData[nft.contract].details.filter(entry => {\n        return entry.token !== nft.token;\n      });\n      this.$set(this.nftData[nft.contract], 'details', afterSent);\n      this.nftData[nft.contract].count -= 1;\n      if (this.nftData[nft.contract].count === 0) this.sentUpdate += 1;\n      this.showDetails = false;\n    },\n    resetNFT(nft) {\n      this.nftData[nft.contract] = this.nftObjectClone;\n    },\n    changeSelectedContract(selectedContract) {\n      this.selectedContract = selectedContract;\n      this.showDetails = false;\n    },\n    comeBack() {\n      this.showDetails = false;\n    },\n    getImage(nft) {\n      if (nft.customNft) {\n        return placeholderImage;\n      }\n      return nft.image;\n    },\n    async setup() {\n      const stateItems = {\n        count: 0,\n        selected: false,\n        startIndex: 0,\n        priorIndex: 0,\n        currentIndex: 0,\n        details: []\n      };\n\n      const customNFTs = store.get('customNFTs');\n\n      if (customNFTs !== undefined && customNFTs !== null) {\n        this.customNFTs = customNFTs;\n      }\n      const configData = await this.getTokenConfig();\n\n      const nftConfig = configData\n        .map(entry => {\n          return {\n            ...entry,\n            contract: entry.contractAddress\n          };\n        })\n        .reduce((accumulator, currentValue) => {\n          if (currentValue.active) {\n            accumulator.push(currentValue);\n          }\n          return accumulator;\n        }, []);\n\n      this.nftConfig = [...this.customNFTs, ...nftConfig];\n      this.nftData = this.nftConfig.reduce((accumulator, currentValue) => {\n        accumulator[currentValue.contract] = {\n          ...currentValue,\n          ...stateItems\n        };\n        return accumulator;\n      }, {});\n\n      if (this.network.type.name === 'ETH') {\n        this.getOwnedCounts();\n        this.getOwned();\n      }\n    },\n    async getNftImagePath(contract, token) {\n      const image = await fetch(\n        `${URL_BASE}?contract=${contract}&token=${token}`,\n        {\n          mode: 'cors',\n          cache: 'no-cache',\n          method: 'GET'\n        }\n      );\n      return await image.json();\n    },\n    async getOwnedCounts(address = this.activeAddress) {\n      const supportedNftTokens = this.nftConfig\n        .filter(entry => entry.ERC721Extension)\n        .map(entry => entry.contract);\n      const tokenContract = new this.web3.eth.Contract(nftABI);\n      tokenContract.options.address = this.tokenContractAddress;\n\n      const res = await tokenContract.methods\n        .getTokenBalances(supportedNftTokens, address.toLowerCase())\n        .call();\n      hexDecoder(res).map((val, idx) => {\n        this.nftData[supportedNftTokens[idx]].count = Number.isNaN(\n          val.toNumber()\n        )\n          ? 0\n          : val.toNumber();\n        return val.toString();\n      });\n    },\n    async getOwned(address = this.activeAddress, nftData = this.nftData) {\n      if (!this.processing) {\n        this.processing = true;\n        const supportedNftTokens = Object.keys(nftData);\n\n        const result = await this.getOwnedTokens(\n          supportedNftTokens,\n          address,\n          nftData\n        );\n        this.ready = true;\n        this.processing = false;\n        return result;\n      }\n    },\n    async getOwnedNonStandard(\n      contract,\n      address,\n      offset = 0,\n      limit = this.countPerPage\n    ) {\n      fetch(\n        `${URL_BASE}?nonStandardContract=${contract}&address=${address}&offset=${offset}&limit=${limit}`,\n        {\n          mode: 'cors',\n          cache: 'no-cache',\n          method: 'GET'\n        }\n      )\n        .then(data => {\n          return data.json();\n        })\n        .then(rawJson => {\n          this.nftData[contract].count = rawJson.total;\n          this.countsRetrieved = true;\n          const getNestedObject = (nestedObj, pathArr, token) => {\n            return pathArr.reduce((obj, key) => {\n              if (key === '@tokenvalue@') {\n                key = token.toString();\n              }\n              return obj && obj[key] !== 'undefined' ? obj[key] : undefined;\n            }, nestedObj);\n          };\n\n          const metadataKeys = this.nftData[contract].metadataKeys || [\n            'kitties'\n          ];\n          const imageKey = this.nftData[contract].imageKey || 'image_url_png';\n\n          const list = getNestedObject(rawJson, metadataKeys).map(val => {\n            return {\n              contract: contract,\n              token: val.id,\n              image: val[imageKey]\n                ? `${URL_BASE}/image?path=${val[imageKey]}`\n                : ''\n            };\n          });\n\n          this.nftData[contract].details = list.slice(0, 9);\n          this.$set(this.nftData[contract], 'details', list.slice(0, 9));\n          return this.nftData[contract].details;\n        })\n        .then(list => {\n          if (!list) return;\n          if (list.length > 0) {\n            const retrieveCount =\n              list.length > this.countPerPage ? this.countPerPage : list.length;\n            for (let j = 0; j < retrieveCount; j++) {\n              if (!Number.isNaN(list[j].token) && list[j].image === '') {\n                this.getNftImagePath(contract, list[j].token)\n                  .then(image => {\n                    this.nftData[contract].details[\n                      j\n                    ].image = `${URL_BASE}/image?path=${image.image}`;\n                  })\n                  .catch(() => {\n                    if (this.nftData[contract].details[j]) {\n                      this.nftData[contract].details[j].image = '';\n                    }\n                  });\n              }\n            }\n          }\n          setTimeout(() => {\n            this.reLoading = false;\n          }, 3000);\n        });\n    },\n    async getOwnedStandard(\n      contract,\n      offset,\n      count = this.countPerPage,\n      address = this.activeAddress,\n      tokenContract = undefined,\n      custom = false\n    ) {\n      if (!tokenContract) {\n        tokenContract = new this.web3.eth.Contract(nftABI);\n        tokenContract.options.address = this.tokenContractAddress;\n      }\n\n      tokenContract.methods\n        .getOwnedTokens(contract, address.toLowerCase(), offset, count)\n        .call()\n        .then(res => {\n          return hexDecoder(res).map(val => {\n            const content = {\n              contract: contract,\n              token: val.toNumber(),\n              image: ''\n            };\n            if (custom) {\n              content.customNft = true;\n              content.token = val.toFixed(0).toString();\n            }\n            return content;\n          });\n        })\n        .then(list => {\n          if (!list) return;\n          this.nftData[contract].details = list;\n          this.$set(this.nftData[contract], 'details', list);\n          if (list.length > 0) {\n            const retrieveCount =\n              list.length > this.countPerPage ? this.countPerPage : list.length;\n            for (let j = 0; j < retrieveCount; j++) {\n              if (!Number.isNaN(list[j].token) && !list[j].customNft) {\n                this.getNftImagePath(contract, list[j].token)\n                  .then(image => {\n                    this.nftData[contract].details[\n                      j\n                    ].image = `${URL_BASE}/image?path=${image.image}`;\n                  })\n                  .catch(() => {\n                    if (this.nftData[contract].details[j]) {\n                      this.nftData[contract].details[j].image = '';\n                    }\n                  });\n              } else if (list[j].customNft) {\n                this.nftData[contract].details[j].image = '';\n              }\n            }\n          }\n          this.collectionLoading = false;\n        });\n    },\n    async getOwnedTokens(contracts, address, nftData) {\n      const tokenContract = new this.web3.eth.Contract(nftABI);\n      tokenContract.options.address = this.tokenContractAddress;\n      for (let i = 0; i < contracts.length; i++) {\n        nftData = await this.loadForContract(\n          contracts[i],\n          nftData,\n          address,\n          tokenContract\n        );\n      }\n    },\n    getNext(address = this.account.address) {\n      this.collectionLoading = true;\n      const content = this.nftData[this.selectedContract];\n      const offset = content.currentIndex + this.countPerPage;\n      if (offset <= content.count) {\n        // update offsets if not at the end\n        content.priorIndex = content.currentIndex;\n        content.currentIndex = offset;\n      } else {\n        // update offsets if not at the end\n        content.priorIndex = content.currentIndex;\n        content.currentIndex = content.count;\n      }\n\n      if (content.nonStandard) {\n        this.getOwnedNonStandard(\n          content.contract,\n          address,\n          offset,\n          this.countPerPage\n        );\n      } else {\n        if (content.customNft) {\n          this.getOwnedStandard(\n            content.contract,\n            offset,\n            this.countPerPage,\n            undefined,\n            undefined,\n            true\n          );\n        } else {\n          this.getOwnedStandard(content.contract, offset, this.countPerPage);\n        }\n      }\n    },\n    getPrevious(address = this.activeAddress) {\n      this.collectionLoading = true;\n      const content = this.nftData[this.selectedContract];\n\n      let offset = content.currentIndex - content.priorIndex;\n\n      if (content.currentIndex - offset >= 0) {\n        content.currentIndex = content.currentIndex - offset;\n      } else {\n        content.currentIndex = 0;\n      }\n\n      if (content.priorIndex - offset >= 0) {\n        content.priorIndex = content.priorIndex - offset;\n      } else {\n        content.priorIndex = 0;\n      }\n\n      if (content.currentIndex === 0 && content.priorIndex === 0) {\n        offset = 0;\n      } else {\n        offset = content.currentIndex;\n      }\n\n      if (offset >= 0) {\n        if (content.nonStandard) {\n          this.getOwnedNonStandard(\n            content.contract,\n            address,\n            offset,\n            this.countPerPage\n          );\n        } else {\n          if (content.customNft) {\n            this.getOwnedStandard(\n              content.contract,\n              offset,\n              this.countPerPage,\n              undefined,\n              undefined,\n              true\n            );\n          } else {\n            this.getOwnedStandard(content.contract, offset, this.countPerPage);\n          }\n        }\n      }\n    },\n    async getTokenConfig() {\n      const data = await fetch(`${URL_BASE}?supported=true`, {\n        mode: 'cors',\n        cache: 'no-cache',\n        method: 'GET',\n        'Cache-Control': 'no-cache'\n      });\n      return await data.json();\n    },\n    async loadForContract(\n      contract,\n      nftData,\n      address = this.activeAddress,\n      tokenContract = null\n    ) {\n      if (nftData[contract].ERC721Extension) {\n        this.getOwnedStandard(\n          contract,\n          0,\n          this.countPerPage,\n          address,\n          tokenContract,\n          nftData[contract].customNft\n        ).then(result => {\n          this.nftData[contract].details = result;\n        });\n\n        return nftData;\n      } else if (nftData[contract].nonStandard) {\n        this.getOwnedNonStandard(contract, address);\n      }\n      return nftData;\n    },\n    showNftDetails(nft) {\n      this.detailsFor = nft;\n      this.showDetails = true;\n    }\n  }\n};\n",{"version":3,"sources":["NFTManagerContainer.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"NFTManagerContainer.vue","sourceRoot":"src/layouts/InterfaceLayout/containers/NFTManagerContainer","sourcesContent":["<template>\n  <div class=\"crypto-kitties-manager\">\n    <interface-container-title :title=\"$t('common.ntfManager')\" />\n    <div\n      v-if=\"!isReady && isOnlineAndEth\"\n      class=\"inner-side-menu content-container\"\n    >\n      <nft-side-menu :supported-nft-obj=\"sideMenuData\" :nft-config=\"nftConfig\">\n      </nft-side-menu>\n      <loading-sign :loadingmessage1=\"$t('common.loading')\" />\n    </div>\n    <div v-if=\"isReady && hasNfts\" class=\"inner-side-menu content-container\">\n      <nft-side-menu\n        :supported-nft-obj=\"sideMenuData\"\n        :nft-config=\"nftConfig\"\n        :initial-highlighted=\"selectedContract\"\n        :loading-complete=\"countsRetrieved\"\n        :sent-update=\"sentUpdate\"\n        @selected=\"changeSelectedContract\"\n        @openCustomModal=\"openCustomModal\"\n        @removeCustomNft=\"openRemovalConfirmModal\"\n      >\n      </nft-side-menu>\n      <div v-if=\"showDetails\">\n        <nft-details\n          :nft=\"detailsFor\"\n          :selected-title=\"nftTitle\"\n          @nftTransferred=\"removeSentNft\"\n          @resetNFT=\"resetNFT\"\n          @back=\"comeBack\"\n        ></nft-details>\n      </div>\n      <div v-if=\"!showDetails\">\n        <content-block-title :button-text=\"ntfCount\" :title=\"nftTitle\" />\n        <!-- TODO Clean Up Design and Improve Mobile -->\n        <div class=\"grid-container\">\n          <div v-for=\"nft in nftToShow\" :key=\"nft.key\" class=\"kitty\">\n            <div class=\"kitty-img\" @click=\"showNftDetails(nft)\">\n              <div v-show=\"!hasImage(nft)\" class=\"placeholder\">\n                <div class=\"animated-background\"></div>\n              </div>\n              <div v-show=\"hasImage(nft)\">\n                <img :src=\"getImage(nft)\" alt @load=\"hasLoaded(nft)\" />\n              </div>\n              <p>#{{ nft.token | ConcatToken }}</p>\n            </div>\n          </div>\n          <div v-show=\"selectedNtf.count > 9\" class=\"internal-nav-container\">\n            <span\n              v-show=\"startIndex > 0\"\n              class=\"internal-nav prev\"\n              @click=\"getPrevious()\"\n            >\n              <i class=\"fa fa-chevron-left\"></i>\n            </span>\n            <span v-show=\"!collectionLoading\">{{\n              $t('dapps.showingRange', { first: startIndex, last: endIndex })\n            }}</span>\n            <span v-show=\"collectionLoading\">{{\n              $t('dapps.loadingRange', { first: startIndex, last: endIndex })\n            }}</span>\n            <span\n              v-show=\"showNextButton\"\n              class=\"internal-nav next\"\n              @click=\"getNext()\"\n            >\n              <i class=\"fa fa-chevron-right\"></i>\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div v-if=\"isReady && !hasNfts\" class=\"inner-side-menu content-container\">\n      <div v-show=\"!reLoading\">\n        <h3 class=\"no-nft-notice\">{{ $t('dapps.noNFTs') }}</h3>\n        <standard-button\n          :options=\"onlyCustom\"\n          @click.native=\"openCustomModal\"\n        />\n      </div>\n      <span v-show=\"reLoading\">{{ $t('dapps.reloading') }}</span>\n    </div>\n\n    <div v-if=\"!isOnlineAndEth\">\n      <div v-show=\"!online\">\n        NFTs are\n      </div>\n      <div v-show=\"online\">\n        {{ $t('dapps.removeCustomNFT', { value: network.type.name_long }) }}\n      </div>\n    </div>\n    <div class=\"flex--row--align-start mft-manager-content-container\"></div>\n    <nft-custom-add-modal\n      ref=\"customModal\"\n      :add-token=\"addCustom\"\n      :active-address=\"activeAddress\"\n    ></nft-custom-add-modal>\n    <nft-custom-confirm-remove-modal\n      ref=\"customRemoveModal\"\n      :for-removal=\"forRemoval\"\n      @remove=\"removeCustomNft\"\n    >\n    </nft-custom-confirm-remove-modal>\n  </div>\n</template>\n\n<script>\nimport store from 'store';\nimport LoadingSign from '@/components/LoadingSign';\nimport InterfaceContainerTitle from '@/layouts/InterfaceLayout/components/InterfaceContainerTitle';\nimport ContentBlockTitle from '@/layouts/InterfaceLayout/components/ContentBlockTitle';\nimport NFTSideMenu from '@/layouts/InterfaceLayout/containers/NFTManagerContainer/components/NFTSideMenu';\nimport NftDetails from './components/NftDetails';\nimport NftCustomAddModal from './components/NftCustomAddModal';\nimport NftCustomConfirmRemove from './components/NftCustomConfirmRemove';\nimport { mapState } from 'vuex';\nimport hexDecoder from './binaryDecoderNFT';\nimport { nftABI } from './abis';\nimport StandardButton from '@/components/Buttons/StandardButton';\nimport placeholderImage from '@/assets/images/icons/defaultToken.png';\nimport utils from 'web3-utils';\n\nconst URL_BASE = 'https://nft.mewapi.io/nft';\n\nexport default {\n  components: {\n    'nft-custom-add-modal': NftCustomAddModal,\n    'nft-custom-confirm-remove-modal': NftCustomConfirmRemove,\n    'loading-sign': LoadingSign,\n    'content-block-title': ContentBlockTitle,\n    'nft-side-menu': NFTSideMenu,\n    'interface-container-title': InterfaceContainerTitle,\n    'nft-details': NftDetails,\n    'standard-button': StandardButton\n  },\n  filters: {\n    ConcatToken(value) {\n      if (!value) return '';\n      if (value.length > 20)\n        return `${value.substr(0, 15)}...${value.substr(value.length - 6)}`;\n      return value;\n    }\n  },\n  data() {\n    return {\n      nftABI,\n      countPerPage: 9,\n      nftConfig: [],\n      tokenHelper: {},\n      mayHaveTokens: [true, true],\n      countsRetrieved: false,\n      showDetails: false,\n      reLoading: false,\n      selectedContract: '0x06012c8cf97bead5deae237070f9587f8e7a266d',\n      detailsFor: {},\n      nftTokens: {},\n      nftData: {},\n      ownedTokens: [],\n      tokenContractAddress: '0xeA3352C1a3480Ac5a32Fcd1F2854529BA7193F14',\n      sentUpdate: 0,\n      customNFTs: [],\n      forRemoval: {},\n      collectionLoading: false,\n      onlyCustom: {\n        title: this.$t('dapps.addCustomNFT'),\n        buttonStyle: 'green',\n        helpCenter: false,\n        noMinWidth: true,\n        fullWidth: false\n      },\n      nftObjectClone: {}\n    };\n  },\n  computed: {\n    ...mapState(['account', 'web3', 'online', 'network']),\n    endIndex() {\n      if (this.nftData[this.selectedContract]) {\n        if (!this.nftData[this.selectedContract].details) return 0;\n        const ids_retrieved = this.nftData[this.selectedContract].details\n          .length;\n        const increment =\n          ids_retrieved > this.countPerPage ? this.countPerPage : ids_retrieved;\n        return this.nftData[this.selectedContract].currentIndex + increment;\n      }\n    },\n    nftTitle() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract].title;\n      }\n      return 'Loading';\n    },\n    nftToShow() {\n      if (this.nftData[this.selectedContract]) {\n        if (!this.nftData[this.selectedContract].details) return [];\n        return this.nftData[this.selectedContract].details.length >\n          this.countPerPage\n          ? this.nftData[this.selectedContract].details.slice(\n              this.nftData[this.selectedContract].currentIndex,\n              this.nftData[this.selectedContract].currentIndex +\n                this.countPerPage\n            )\n          : this.nftData[this.selectedContract].details;\n      }\n      return [];\n    },\n    ntfCount() {\n      if (this.nftData[this.selectedContract]) {\n        return this.$t('dapps.nftOwnCount', {\n          perPage: this.countPerPage,\n          count: this.nftData[this.selectedContract].count\n        });\n      }\n\n      return this.$t('dapps.noneOwned');\n    },\n    selectedNtf() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract];\n      }\n      return {};\n    },\n    showNextButton() {\n      if (this.nftData[this.selectedContract]) {\n        const ids_retrieved = this.nftData[this.selectedContract].count;\n        return (\n          this.endIndex !== ids_retrieved && this.endIndex <= ids_retrieved\n        );\n      }\n    },\n    sideMenuData() {\n      return this.nftData;\n    },\n    startIndex() {\n      if (this.nftData[this.selectedContract]) {\n        return this.nftData[this.selectedContract].currentIndex;\n      }\n      return 0;\n    },\n    activeAddress() {\n      return this.account.address;\n    },\n    hasNfts() {\n      return Object.values(this.nftData).some(entry => entry.count > 0);\n    },\n    isReady() {\n      return this.isOnlineAndEth && this.countsRetrieved;\n    },\n    isOnlineAndEth() {\n      return this.online && this.network.type.name === 'ETH';\n    }\n  },\n  watch: {},\n  async mounted() {\n    await this.setup();\n  },\n  methods: {\n    addCustom(address, symbol) {\n      this.reLoading = true;\n      this.customNFTs.push({\n        ERC721Extension: true,\n        contract: address,\n        customNft: true,\n        title: symbol\n      });\n      this.$refs.customModal.$refs.modal.hide();\n      store.set('customNFTs', this.customNFTs);\n      this.sentUpdate += 1;\n      this.setup();\n    },\n    removeCustomNft(item) {\n      this.reLoading = true;\n      const customNFTs = store.get('customNFTs');\n      if (customNFTs !== undefined && customNFTs !== null) {\n        const entryIndex = customNFTs.findIndex(\n          entry => item.contract === entry.contract\n        );\n        customNFTs.splice(entryIndex, 1);\n        store.set('customNFTs', customNFTs);\n        this.setup();\n        this.sentUpdate += 1;\n      }\n    },\n    openRemovalConfirmModal(item) {\n      this.forRemoval = item;\n      this.$refs.customRemoveModal.$refs.modal.show();\n    },\n    openCustomModal() {\n      this.$refs.customModal.$refs.modal.show();\n    },\n    hasLoaded(nft) {\n      this.$set(nft, 'loaded', true);\n    },\n    hasImage(nft) {\n      if (nft.customNft) {\n        return true;\n      }\n      if (nft.loaded) {\n        return true;\n      }\n    },\n    removeSentNft(nft) {\n      this.nftObjectClone = utils._.clone(this.nftData[nft.contract]);\n      const afterSent = this.nftData[nft.contract].details.filter(entry => {\n        return entry.token !== nft.token;\n      });\n      this.$set(this.nftData[nft.contract], 'details', afterSent);\n      this.nftData[nft.contract].count -= 1;\n      if (this.nftData[nft.contract].count === 0) this.sentUpdate += 1;\n      this.showDetails = false;\n    },\n    resetNFT(nft) {\n      this.nftData[nft.contract] = this.nftObjectClone;\n    },\n    changeSelectedContract(selectedContract) {\n      this.selectedContract = selectedContract;\n      this.showDetails = false;\n    },\n    comeBack() {\n      this.showDetails = false;\n    },\n    getImage(nft) {\n      if (nft.customNft) {\n        return placeholderImage;\n      }\n      return nft.image;\n    },\n    async setup() {\n      const stateItems = {\n        count: 0,\n        selected: false,\n        startIndex: 0,\n        priorIndex: 0,\n        currentIndex: 0,\n        details: []\n      };\n\n      const customNFTs = store.get('customNFTs');\n\n      if (customNFTs !== undefined && customNFTs !== null) {\n        this.customNFTs = customNFTs;\n      }\n      const configData = await this.getTokenConfig();\n\n      const nftConfig = configData\n        .map(entry => {\n          return {\n            ...entry,\n            contract: entry.contractAddress\n          };\n        })\n        .reduce((accumulator, currentValue) => {\n          if (currentValue.active) {\n            accumulator.push(currentValue);\n          }\n          return accumulator;\n        }, []);\n\n      this.nftConfig = [...this.customNFTs, ...nftConfig];\n      this.nftData = this.nftConfig.reduce((accumulator, currentValue) => {\n        accumulator[currentValue.contract] = {\n          ...currentValue,\n          ...stateItems\n        };\n        return accumulator;\n      }, {});\n\n      if (this.network.type.name === 'ETH') {\n        this.getOwnedCounts();\n        this.getOwned();\n      }\n    },\n    async getNftImagePath(contract, token) {\n      const image = await fetch(\n        `${URL_BASE}?contract=${contract}&token=${token}`,\n        {\n          mode: 'cors',\n          cache: 'no-cache',\n          method: 'GET'\n        }\n      );\n      return await image.json();\n    },\n    async getOwnedCounts(address = this.activeAddress) {\n      const supportedNftTokens = this.nftConfig\n        .filter(entry => entry.ERC721Extension)\n        .map(entry => entry.contract);\n      const tokenContract = new this.web3.eth.Contract(nftABI);\n      tokenContract.options.address = this.tokenContractAddress;\n\n      const res = await tokenContract.methods\n        .getTokenBalances(supportedNftTokens, address.toLowerCase())\n        .call();\n      hexDecoder(res).map((val, idx) => {\n        this.nftData[supportedNftTokens[idx]].count = Number.isNaN(\n          val.toNumber()\n        )\n          ? 0\n          : val.toNumber();\n        return val.toString();\n      });\n    },\n    async getOwned(address = this.activeAddress, nftData = this.nftData) {\n      if (!this.processing) {\n        this.processing = true;\n        const supportedNftTokens = Object.keys(nftData);\n\n        const result = await this.getOwnedTokens(\n          supportedNftTokens,\n          address,\n          nftData\n        );\n        this.ready = true;\n        this.processing = false;\n        return result;\n      }\n    },\n    async getOwnedNonStandard(\n      contract,\n      address,\n      offset = 0,\n      limit = this.countPerPage\n    ) {\n      fetch(\n        `${URL_BASE}?nonStandardContract=${contract}&address=${address}&offset=${offset}&limit=${limit}`,\n        {\n          mode: 'cors',\n          cache: 'no-cache',\n          method: 'GET'\n        }\n      )\n        .then(data => {\n          return data.json();\n        })\n        .then(rawJson => {\n          this.nftData[contract].count = rawJson.total;\n          this.countsRetrieved = true;\n          const getNestedObject = (nestedObj, pathArr, token) => {\n            return pathArr.reduce((obj, key) => {\n              if (key === '@tokenvalue@') {\n                key = token.toString();\n              }\n              return obj && obj[key] !== 'undefined' ? obj[key] : undefined;\n            }, nestedObj);\n          };\n\n          const metadataKeys = this.nftData[contract].metadataKeys || [\n            'kitties'\n          ];\n          const imageKey = this.nftData[contract].imageKey || 'image_url_png';\n\n          const list = getNestedObject(rawJson, metadataKeys).map(val => {\n            return {\n              contract: contract,\n              token: val.id,\n              image: val[imageKey]\n                ? `${URL_BASE}/image?path=${val[imageKey]}`\n                : ''\n            };\n          });\n\n          this.nftData[contract].details = list.slice(0, 9);\n          this.$set(this.nftData[contract], 'details', list.slice(0, 9));\n          return this.nftData[contract].details;\n        })\n        .then(list => {\n          if (!list) return;\n          if (list.length > 0) {\n            const retrieveCount =\n              list.length > this.countPerPage ? this.countPerPage : list.length;\n            for (let j = 0; j < retrieveCount; j++) {\n              if (!Number.isNaN(list[j].token) && list[j].image === '') {\n                this.getNftImagePath(contract, list[j].token)\n                  .then(image => {\n                    this.nftData[contract].details[\n                      j\n                    ].image = `${URL_BASE}/image?path=${image.image}`;\n                  })\n                  .catch(() => {\n                    if (this.nftData[contract].details[j]) {\n                      this.nftData[contract].details[j].image = '';\n                    }\n                  });\n              }\n            }\n          }\n          setTimeout(() => {\n            this.reLoading = false;\n          }, 3000);\n        });\n    },\n    async getOwnedStandard(\n      contract,\n      offset,\n      count = this.countPerPage,\n      address = this.activeAddress,\n      tokenContract = undefined,\n      custom = false\n    ) {\n      if (!tokenContract) {\n        tokenContract = new this.web3.eth.Contract(nftABI);\n        tokenContract.options.address = this.tokenContractAddress;\n      }\n\n      tokenContract.methods\n        .getOwnedTokens(contract, address.toLowerCase(), offset, count)\n        .call()\n        .then(res => {\n          return hexDecoder(res).map(val => {\n            const content = {\n              contract: contract,\n              token: val.toNumber(),\n              image: ''\n            };\n            if (custom) {\n              content.customNft = true;\n              content.token = val.toFixed(0).toString();\n            }\n            return content;\n          });\n        })\n        .then(list => {\n          if (!list) return;\n          this.nftData[contract].details = list;\n          this.$set(this.nftData[contract], 'details', list);\n          if (list.length > 0) {\n            const retrieveCount =\n              list.length > this.countPerPage ? this.countPerPage : list.length;\n            for (let j = 0; j < retrieveCount; j++) {\n              if (!Number.isNaN(list[j].token) && !list[j].customNft) {\n                this.getNftImagePath(contract, list[j].token)\n                  .then(image => {\n                    this.nftData[contract].details[\n                      j\n                    ].image = `${URL_BASE}/image?path=${image.image}`;\n                  })\n                  .catch(() => {\n                    if (this.nftData[contract].details[j]) {\n                      this.nftData[contract].details[j].image = '';\n                    }\n                  });\n              } else if (list[j].customNft) {\n                this.nftData[contract].details[j].image = '';\n              }\n            }\n          }\n          this.collectionLoading = false;\n        });\n    },\n    async getOwnedTokens(contracts, address, nftData) {\n      const tokenContract = new this.web3.eth.Contract(nftABI);\n      tokenContract.options.address = this.tokenContractAddress;\n      for (let i = 0; i < contracts.length; i++) {\n        nftData = await this.loadForContract(\n          contracts[i],\n          nftData,\n          address,\n          tokenContract\n        );\n      }\n    },\n    getNext(address = this.account.address) {\n      this.collectionLoading = true;\n      const content = this.nftData[this.selectedContract];\n      const offset = content.currentIndex + this.countPerPage;\n      if (offset <= content.count) {\n        // update offsets if not at the end\n        content.priorIndex = content.currentIndex;\n        content.currentIndex = offset;\n      } else {\n        // update offsets if not at the end\n        content.priorIndex = content.currentIndex;\n        content.currentIndex = content.count;\n      }\n\n      if (content.nonStandard) {\n        this.getOwnedNonStandard(\n          content.contract,\n          address,\n          offset,\n          this.countPerPage\n        );\n      } else {\n        if (content.customNft) {\n          this.getOwnedStandard(\n            content.contract,\n            offset,\n            this.countPerPage,\n            undefined,\n            undefined,\n            true\n          );\n        } else {\n          this.getOwnedStandard(content.contract, offset, this.countPerPage);\n        }\n      }\n    },\n    getPrevious(address = this.activeAddress) {\n      this.collectionLoading = true;\n      const content = this.nftData[this.selectedContract];\n\n      let offset = content.currentIndex - content.priorIndex;\n\n      if (content.currentIndex - offset >= 0) {\n        content.currentIndex = content.currentIndex - offset;\n      } else {\n        content.currentIndex = 0;\n      }\n\n      if (content.priorIndex - offset >= 0) {\n        content.priorIndex = content.priorIndex - offset;\n      } else {\n        content.priorIndex = 0;\n      }\n\n      if (content.currentIndex === 0 && content.priorIndex === 0) {\n        offset = 0;\n      } else {\n        offset = content.currentIndex;\n      }\n\n      if (offset >= 0) {\n        if (content.nonStandard) {\n          this.getOwnedNonStandard(\n            content.contract,\n            address,\n            offset,\n            this.countPerPage\n          );\n        } else {\n          if (content.customNft) {\n            this.getOwnedStandard(\n              content.contract,\n              offset,\n              this.countPerPage,\n              undefined,\n              undefined,\n              true\n            );\n          } else {\n            this.getOwnedStandard(content.contract, offset, this.countPerPage);\n          }\n        }\n      }\n    },\n    async getTokenConfig() {\n      const data = await fetch(`${URL_BASE}?supported=true`, {\n        mode: 'cors',\n        cache: 'no-cache',\n        method: 'GET',\n        'Cache-Control': 'no-cache'\n      });\n      return await data.json();\n    },\n    async loadForContract(\n      contract,\n      nftData,\n      address = this.activeAddress,\n      tokenContract = null\n    ) {\n      if (nftData[contract].ERC721Extension) {\n        this.getOwnedStandard(\n          contract,\n          0,\n          this.countPerPage,\n          address,\n          tokenContract,\n          nftData[contract].customNft\n        ).then(result => {\n          this.nftData[contract].details = result;\n        });\n\n        return nftData;\n      } else if (nftData[contract].nonStandard) {\n        this.getOwnedNonStandard(contract, address);\n      }\n      return nftData;\n    },\n    showNftDetails(nft) {\n      this.detailsFor = nft;\n      this.showDetails = true;\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import 'NFTManagerContainer.scss';\n</style>\n"]}]}