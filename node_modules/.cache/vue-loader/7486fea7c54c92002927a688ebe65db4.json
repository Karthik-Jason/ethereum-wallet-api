{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/containers/NotificationsContainer/components/NotificationTypes/SwapNotification/SwapNotification.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/containers/NotificationsContainer/components/NotificationTypes/SwapNotification/SwapNotification.vue","mtime":1573477611640},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { mapState } from 'vuex';\n\nimport '@/assets/images/currency/coins/asFont/cryptocoins.css';\nimport '@/assets/images/currency/coins/asFont/cryptocoins-colors.css';\nimport Arrow from '@/assets/images/etc/single-arrow.svg';\nimport * as moment from 'moment';\nimport NotificationHeader from '../../NotificationHeader';\nimport { providerMap, providerNames } from '@/partners';\n\nimport {\n  swapOnlyStatuses,\n  notificationStatuses\n} from '@/helpers/notificationFormatters';\n\nexport default {\n  components: {\n    'notification-header': NotificationHeader\n  },\n  filters: {\n    concatAddress(value) {\n      if (!value) return '';\n      return `${value.substr(0, 7)}...${value.substr(value.length - 7)}`;\n    }\n  },\n  props: {\n    shown: {\n      type: Boolean,\n      default: false\n    },\n    expand: {\n      type: Function,\n      default: function() {}\n    },\n    index: {\n      type: Number,\n      default: 0\n    },\n    notice: {\n      type: Object,\n      default: function() {\n        return {};\n      }\n    },\n    convertToGwei: {\n      type: Function,\n      default: function() {}\n    },\n    convertToEth: {\n      type: Function,\n      default: function() {}\n    },\n    getFiatValue: {\n      type: Function,\n      default: function() {}\n    },\n    dateString: {\n      type: Function,\n      default: function() {}\n    },\n    timeString: {\n      type: Function,\n      default: function() {}\n    },\n    errorMessageString: {\n      type: Function,\n      default: function() {}\n    },\n    hashLink: {\n      type: Function,\n      default: function() {}\n    },\n    addressLink: {\n      type: Function,\n      default: function() {}\n    },\n    processStatus: {\n      type: Function,\n      default: function() {}\n    },\n    childUpdateNotification: {\n      type: Function,\n      default: function() {}\n    }\n  },\n  data() {\n    return {\n      arrowImage: Arrow,\n      unreadCount: 0,\n      currentStatus: '',\n      swapStatus: '',\n      timeRemaining: this.notice.body.timeRemaining,\n      providers: providerMap,\n      provider: {},\n      timerInterval: null,\n      statusInterval: null\n    };\n  },\n  computed: {\n    ...mapState(['web3', 'network', 'notifications', 'wallet']),\n    errorMessage() {\n      return this.errorMessageString(this.notice);\n    },\n    isError() {\n      return this.notice.body.error;\n    },\n    txStatus() {\n      return this.processStatus(this.notice.swapStatus);\n    },\n    parseTimeRemaining() {\n      const seconds = Math.floor(this.timeRemaining % 60);\n      const minutes = Math.floor((this.timeRemaining / 60) % 60);\n      return seconds >= 10 ? `${minutes}:${seconds}` : `${minutes}:0${seconds}`;\n    },\n    timeRemains() {\n      return this.timeRemaining > 0;\n    }\n  },\n  watch: {\n    shown(val) {\n      if (val) {\n        this.startPolling();\n      } else {\n        this.stopPolling();\n      }\n    }\n  },\n  activated() {\n    if (this.shown) {\n      this.startPolling();\n    }\n  },\n  beforeDestroy() {\n    this.stopPolling();\n  },\n  methods: {\n    emitShowDetails() {\n      this.$emit('showDetails', ['swap', this.notice, this.index]);\n    },\n    startPolling() {\n      if (this.notice.body.provider === providerNames.kyber) return;\n\n      this.provider = providerMap.get(this.notice.body.provider);\n      this.currentStatus = this.notice.swapStatus;\n\n      if (this.timerInterval === null) {\n        this.timeUpdater();\n      }\n\n      if (this.statusInterval === null) {\n        this.statusUpdater();\n      }\n    },\n    stopPolling() {\n      if (this.timerInterval !== null) {\n        clearInterval(this.timerInterval);\n        this.timerInterval = null;\n      }\n\n      if (this.statusInterval !== null) {\n        clearInterval(this.statusInterval);\n        this.statusInterval = null;\n      }\n    },\n    shouldCheckStatus() {\n      return [\n        swapOnlyStatuses.NEW,\n        swapOnlyStatuses.SENT,\n        notificationStatuses.PENDING\n      ].includes(this.notice.swapStatus);\n    },\n    statusUpdater() {\n      let updating = false;\n      const getStatus = async () => {\n        const updateStatus = newStatus => {\n          if (this.currentStatus !== newStatus) {\n            this.currentStatus = newStatus;\n            if (swapOnlyStatuses[newStatus]) {\n              this.notice.swapStatus = newStatus;\n            } else {\n              this.notice.swapStatus = newStatus;\n              this.notice.status = newStatus;\n            }\n            this.childUpdateNotification(this.notice);\n          }\n        };\n\n        if (!updating) {\n          updating = true;\n\n          const createdAt = moment(\n            this.notice.body.createdAt.replace(/T.*/, '')\n          );\n          const currentTime = moment();\n          const timeSince = currentTime.diff(createdAt, 'days');\n          if (timeSince >= 5) {\n            updateStatus(swapOnlyStatuses.CANCELLED);\n            return;\n          }\n          const newStatus = await this.provider.getOrderStatus(\n            this.notice.body,\n            this.network.type.name\n          );\n\n          if (typeof newStatus === 'undefined') return;\n          updateStatus(newStatus);\n\n          if (!this.shouldCheckStatus()) {\n            clearInterval(this.statusInterval);\n          }\n          updating = false;\n        }\n      };\n\n      if (this.shouldCheckStatus()) {\n        getStatus();\n        this.statusInterval = setInterval(() => {\n          getStatus();\n          if (!this.shouldCheckStatus()) {\n            clearInterval(this.statusInterval);\n          }\n        }, 10000);\n      }\n    },\n    timeUpdater() {\n      const updateTime = () => {\n        this.timeRemaining =\n          this.notice.body.validFor -\n          parseInt(\n            (new Date().getTime() -\n              new Date(this.notice.body.createdAt).getTime()) /\n              1000\n          );\n        if (\n          (this.notice.swapStatus === swapOnlyStatuses.NEW ||\n            this.currentStatus === swapOnlyStatuses.NEW) &&\n          this.timeRemaining <= 0\n        ) {\n          this.notice.swapStatus = swapOnlyStatuses.CANCELLED;\n          this.notice.status = notificationStatuses.FAILED;\n          this.notice.body.errorMessage =\n            'Swap window timeout. Swap Cancelled.';\n          this.timeRemaining = -1;\n        }\n        this.notice.body.timeRemaining = +this.timeRemaining;\n        this.childUpdateNotification(this.notice);\n        if (+this.timeRemaining <= 0) {\n          clearInterval(this.timerInterval);\n        }\n      };\n\n      if (this.shouldCheckStatus() && this.notice.body.timeRemaining > 0) {\n        if (this.timeRemaining > 0) {\n          updateTime();\n          this.timerInterval = setInterval(() => {\n            updateTime();\n            if (this.timeRemaining <= 0) {\n              clearInterval(this.timerInterval);\n            }\n          }, 1000);\n        }\n      }\n    }\n  }\n};\n",{"version":3,"sources":["SwapNotification.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0EA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"SwapNotification.vue","sourceRoot":"src/containers/NotificationsContainer/components/NotificationTypes/SwapNotification","sourcesContent":["<template lang=\"html\">\n  <div>\n    <notification-header\n      :expand=\"expand\"\n      :notice=\"notice\"\n      :process-status=\"processStatus\"\n      :time-string=\"timeString\"\n      :date-string=\"dateString\"\n    >\n    </notification-header>\n    <div\n      :class=\"[\n        notice.expanded ? '' : 'unexpanded',\n        'notification-body',\n        'notification-content'\n      ]\"\n    >\n      <ul>\n        <li class=\"swap-details\">\n          <ul>\n            <li>\n              <p class=\"icon from-swap-icon\">\n                <i :class=\"['cc', notice.body.fromCurrency, 'cc-icon']\"></i>\n              </p>\n            </li>\n            <li>\n              <p class=\"from-swap-text\">\n                {{ notice.body.fromValue }} {{ notice.body.fromCurrency }}\n              </p>\n              <p class=\"address\">{{ notice.body.from | concatAddress }}</p>\n            </li>\n            <li>\n              <p class=\"swap-right-arrow\"><img :src=\"arrowImage\" alt /></p>\n            </li>\n            <li>\n              <p class=\"icon to-swap-icon\">\n                <i :class=\"['cc', notice.body.toCurrency, 'cc-icon']\"></i>\n              </p>\n            </li>\n            <li>\n              <p class=\"to-swap-text\">\n                {{ notice.body.toValue }} {{ notice.body.toCurrency }}\n              </p>\n              <p class=\"address\">{{ notice.body.to | concatAddress }}</p>\n            </li>\n          </ul>\n        </li>\n        <li v-if=\"notice.hash\" class=\"tx-hash\">\n          <p>{{ $t('header.transactionHash') }}:</p>\n        </li>\n        <li v-if=\"notice.hash\" class=\"tx-hash\">\n          <a\n            :href=\"hashLink(notice.hash)\"\n            rel=\"noopener noreferrer\"\n            target=\"_blank\"\n          >\n            {{ notice.hash }}\n          </a>\n        </li>\n        <li v-if=\"isError\" class=\"tx-info\">\n          <p>{{ $t('header.errorMessage') }}:</p>\n          <p>{{ errorMessage }}</p>\n        </li>\n        <li>\n          <p class=\"show-pointer\" @click=\"emitShowDetails\">\n            {{ $t('header.more') }}\n          </p>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { mapState } from 'vuex';\n\nimport '@/assets/images/currency/coins/asFont/cryptocoins.css';\nimport '@/assets/images/currency/coins/asFont/cryptocoins-colors.css';\nimport Arrow from '@/assets/images/etc/single-arrow.svg';\nimport * as moment from 'moment';\nimport NotificationHeader from '../../NotificationHeader';\nimport { providerMap, providerNames } from '@/partners';\n\nimport {\n  swapOnlyStatuses,\n  notificationStatuses\n} from '@/helpers/notificationFormatters';\n\nexport default {\n  components: {\n    'notification-header': NotificationHeader\n  },\n  filters: {\n    concatAddress(value) {\n      if (!value) return '';\n      return `${value.substr(0, 7)}...${value.substr(value.length - 7)}`;\n    }\n  },\n  props: {\n    shown: {\n      type: Boolean,\n      default: false\n    },\n    expand: {\n      type: Function,\n      default: function() {}\n    },\n    index: {\n      type: Number,\n      default: 0\n    },\n    notice: {\n      type: Object,\n      default: function() {\n        return {};\n      }\n    },\n    convertToGwei: {\n      type: Function,\n      default: function() {}\n    },\n    convertToEth: {\n      type: Function,\n      default: function() {}\n    },\n    getFiatValue: {\n      type: Function,\n      default: function() {}\n    },\n    dateString: {\n      type: Function,\n      default: function() {}\n    },\n    timeString: {\n      type: Function,\n      default: function() {}\n    },\n    errorMessageString: {\n      type: Function,\n      default: function() {}\n    },\n    hashLink: {\n      type: Function,\n      default: function() {}\n    },\n    addressLink: {\n      type: Function,\n      default: function() {}\n    },\n    processStatus: {\n      type: Function,\n      default: function() {}\n    },\n    childUpdateNotification: {\n      type: Function,\n      default: function() {}\n    }\n  },\n  data() {\n    return {\n      arrowImage: Arrow,\n      unreadCount: 0,\n      currentStatus: '',\n      swapStatus: '',\n      timeRemaining: this.notice.body.timeRemaining,\n      providers: providerMap,\n      provider: {},\n      timerInterval: null,\n      statusInterval: null\n    };\n  },\n  computed: {\n    ...mapState(['web3', 'network', 'notifications', 'wallet']),\n    errorMessage() {\n      return this.errorMessageString(this.notice);\n    },\n    isError() {\n      return this.notice.body.error;\n    },\n    txStatus() {\n      return this.processStatus(this.notice.swapStatus);\n    },\n    parseTimeRemaining() {\n      const seconds = Math.floor(this.timeRemaining % 60);\n      const minutes = Math.floor((this.timeRemaining / 60) % 60);\n      return seconds >= 10 ? `${minutes}:${seconds}` : `${minutes}:0${seconds}`;\n    },\n    timeRemains() {\n      return this.timeRemaining > 0;\n    }\n  },\n  watch: {\n    shown(val) {\n      if (val) {\n        this.startPolling();\n      } else {\n        this.stopPolling();\n      }\n    }\n  },\n  activated() {\n    if (this.shown) {\n      this.startPolling();\n    }\n  },\n  beforeDestroy() {\n    this.stopPolling();\n  },\n  methods: {\n    emitShowDetails() {\n      this.$emit('showDetails', ['swap', this.notice, this.index]);\n    },\n    startPolling() {\n      if (this.notice.body.provider === providerNames.kyber) return;\n\n      this.provider = providerMap.get(this.notice.body.provider);\n      this.currentStatus = this.notice.swapStatus;\n\n      if (this.timerInterval === null) {\n        this.timeUpdater();\n      }\n\n      if (this.statusInterval === null) {\n        this.statusUpdater();\n      }\n    },\n    stopPolling() {\n      if (this.timerInterval !== null) {\n        clearInterval(this.timerInterval);\n        this.timerInterval = null;\n      }\n\n      if (this.statusInterval !== null) {\n        clearInterval(this.statusInterval);\n        this.statusInterval = null;\n      }\n    },\n    shouldCheckStatus() {\n      return [\n        swapOnlyStatuses.NEW,\n        swapOnlyStatuses.SENT,\n        notificationStatuses.PENDING\n      ].includes(this.notice.swapStatus);\n    },\n    statusUpdater() {\n      let updating = false;\n      const getStatus = async () => {\n        const updateStatus = newStatus => {\n          if (this.currentStatus !== newStatus) {\n            this.currentStatus = newStatus;\n            if (swapOnlyStatuses[newStatus]) {\n              this.notice.swapStatus = newStatus;\n            } else {\n              this.notice.swapStatus = newStatus;\n              this.notice.status = newStatus;\n            }\n            this.childUpdateNotification(this.notice);\n          }\n        };\n\n        if (!updating) {\n          updating = true;\n\n          const createdAt = moment(\n            this.notice.body.createdAt.replace(/T.*/, '')\n          );\n          const currentTime = moment();\n          const timeSince = currentTime.diff(createdAt, 'days');\n          if (timeSince >= 5) {\n            updateStatus(swapOnlyStatuses.CANCELLED);\n            return;\n          }\n          const newStatus = await this.provider.getOrderStatus(\n            this.notice.body,\n            this.network.type.name\n          );\n\n          if (typeof newStatus === 'undefined') return;\n          updateStatus(newStatus);\n\n          if (!this.shouldCheckStatus()) {\n            clearInterval(this.statusInterval);\n          }\n          updating = false;\n        }\n      };\n\n      if (this.shouldCheckStatus()) {\n        getStatus();\n        this.statusInterval = setInterval(() => {\n          getStatus();\n          if (!this.shouldCheckStatus()) {\n            clearInterval(this.statusInterval);\n          }\n        }, 10000);\n      }\n    },\n    timeUpdater() {\n      const updateTime = () => {\n        this.timeRemaining =\n          this.notice.body.validFor -\n          parseInt(\n            (new Date().getTime() -\n              new Date(this.notice.body.createdAt).getTime()) /\n              1000\n          );\n        if (\n          (this.notice.swapStatus === swapOnlyStatuses.NEW ||\n            this.currentStatus === swapOnlyStatuses.NEW) &&\n          this.timeRemaining <= 0\n        ) {\n          this.notice.swapStatus = swapOnlyStatuses.CANCELLED;\n          this.notice.status = notificationStatuses.FAILED;\n          this.notice.body.errorMessage =\n            'Swap window timeout. Swap Cancelled.';\n          this.timeRemaining = -1;\n        }\n        this.notice.body.timeRemaining = +this.timeRemaining;\n        this.childUpdateNotification(this.notice);\n        if (+this.timeRemaining <= 0) {\n          clearInterval(this.timerInterval);\n        }\n      };\n\n      if (this.shouldCheckStatus() && this.notice.body.timeRemaining > 0) {\n        if (this.timeRemaining > 0) {\n          updateTime();\n          this.timerInterval = setInterval(() => {\n            updateTime();\n            if (this.timeRemaining <= 0) {\n              clearInterval(this.timerInterval);\n            }\n          }, 1000);\n        }\n      }\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import 'SwapNotification';\n</style>\n"]}]}