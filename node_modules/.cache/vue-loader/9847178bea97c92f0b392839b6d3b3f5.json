{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/dapps/ManageENS/ManageENS.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/src/dapps/ManageENS/ManageENS.vue","mtime":1574664278282},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/babel-loader/lib/index.js","mtime":1574664275010},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/cache-loader/dist/cjs.js","mtime":1574664275186},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-api/node_modules/vue-loader/lib/index.js","mtime":1574664277774}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport BackButton from '@/layouts/InterfaceLayout/components/BackButton';\nimport RegistrarAbi from './ABI/registrarAbi';\nimport PermanentRegistrarControllerAbi from './ABI/permanentRegistrarController';\nimport baseRegistrarAbi from './ABI/baseRegistrarAbi';\nimport DeedContractAbi from './ABI/deedContractAbi';\nimport RegistryAbi from './ABI/registryAbi.js';\nimport FifsRegistrarAbi from './ABI/fifsRegistrarAbi.js';\nimport ResolverAbi from './ABI/resolverAbi.js';\nimport * as unit from 'ethjs-unit';\nimport * as nameHashPckg from 'eth-ens-namehash';\nimport normalise from '@/helpers/normalise';\nimport { mapState } from 'vuex';\nimport { Toast } from '@/helpers';\nimport DNSRegistrar from '@ensdomains/dnsregistrar';\nimport BigNumber from 'bignumber.js';\nimport supportedCoins from './supportedCoins';\nimport supportedTxt from './supportedTxt';\n\nconst bip39 = require('bip39');\n\nconst permanentRegistrar = {\n  INTERFACE_CONTROLLER: '0x018fac06',\n  INTERFACE_LEGACY_REGISTRAR: '0x7ba18ba1'\n};\nconst MULTICOIN_SUPPORT_INTERFACE = '0xf1cb7e06';\nconst TEXT_RECORD_SUPPORT_INTERFACE = '0x59d1d43c';\nconst REGISTRAR_TYPES = {\n  FIFS: 'fifs',\n  PERMANENT: 'permanent'\n};\nexport default {\n  components: {\n    'back-button': BackButton\n  },\n  data() {\n    return {\n      domainName: '',\n      loading: false,\n      nameHash: '',\n      labelHash: '',\n      owner: '',\n      deedOwner: '',\n      secretPhrase: '',\n      registrarAddress: '',\n      raw: {},\n      contractInitiated: false,\n      step: 1,\n      domainNameErr: false,\n      ensRegistryContract: {},\n      dnsRegistrar: {},\n      dnsClaim: {},\n      dnsOwner: '',\n      legacyRegistrar: {},\n      minimumAge: 0,\n      duration: 1,\n      commitmentCreated: false,\n      publicResolverAddress: '',\n      resolverMultiCoinSupport: false,\n      supportedCoins,\n      txtRecords: {},\n      supportedTxt,\n      recordContract: {},\n      resolverTxtSupport: false\n    };\n  },\n  computed: {\n    ...mapState(['web3', 'network', 'account', 'gasPrice', 'ens']),\n    registrarTLD() {\n      return this.network.type.ens.registrarTLD;\n    },\n    registrarType() {\n      return this.network.type.ens.registrarType;\n    },\n    multiTld() {\n      return (\n        this.network.type.ens.hasOwnProperty('supportedTld') &&\n        this.network.type.ens.supportedTld.length > 1\n      );\n    },\n    parsedTld() {\n      if (this.parsedHostName.length) {\n        const hasTld = this.domainName.lastIndexOf('.');\n        return hasTld > -1\n          ? this.domainName.substr(hasTld + 1, this.domainName.length)\n          : this.registrarTLD;\n      }\n      return '';\n    },\n    parsedHostName() {\n      return this.domainName.substr(\n        0,\n        this.domainName.lastIndexOf('.') > -1\n          ? this.domainName.lastIndexOf('.')\n          : this.domainName.length\n      );\n    },\n    parsedDomainName() {\n      return this.parsedHostName + '.' + this.parsedTld;\n    },\n    isSubDomain() {\n      return this.domainName.split('.').length - 1 > 1;\n    }\n  },\n  watch: {\n    ens(newVal) {\n      if (newVal) {\n        this.setRegistrar();\n      }\n    }\n  },\n  mounted() {\n    this.$nextTick(() => {\n      this.setup();\n    });\n  },\n  methods: {\n    async setup() {\n      this.isPermanentLive = true;\n      this.domainName = '';\n      this.loading = false;\n      this.nameHash = '';\n      this.labelHash = '';\n      this.owner = '';\n      this.deedOwner = '';\n      this.secretPhrase = '';\n      this.registrarAddress = '';\n      this.raw = {};\n      this.contractInitiated = false;\n      this.step = 1;\n      this.contractInitiated = false;\n      this.contractInitiated = true;\n      this.domainNameErr = false;\n      this.dnsRegistrar = {};\n      this.dnsClaim = {};\n      this.legacyRegistrar = {};\n      this.minimumAge = 0;\n      this.duration = 1;\n      this.commitmentCreated = false;\n      this.publicResolverAddress = '';\n      this.resolverMultiCoinSupport = false;\n      this.resolverTxtSupport = false;\n      this.supportedCoins = supportedCoins;\n      this.txtRecords = {};\n      this.recordContract = {};\n\n      if (this.ens) {\n        this.setRegistrar();\n      }\n      for (const type in this.supportedCoins)\n        this.supportedCoins[type].value = '';\n    },\n    async setRegistrar() {\n      const web3 = this.web3;\n      const tld = this.registrarTLD;\n      this.registrarAddress = await this.getRegistrarAddress(tld);\n      this.ensRegistryContract = new web3.eth.Contract(\n        RegistryAbi,\n        this.network.type.ens.registry\n      );\n      if (this.registrarType === REGISTRAR_TYPES.FIFS) {\n        this.registrarContract = new web3.eth.Contract(\n          FifsRegistrarAbi,\n          this.registrarAddress\n        );\n      } else if (this.registrarType === REGISTRAR_TYPES.PERMANENT) {\n        try {\n          const controllerAddress = await this.ens\n            .resolver(this.registrarTLD, ResolverAbi)\n            .interfaceImplementer(permanentRegistrar.INTERFACE_CONTROLLER);\n          this.registrarControllerContract = new this.web3.eth.Contract(\n            PermanentRegistrarControllerAbi,\n            controllerAddress\n          );\n          this.registrarContract = new this.web3.eth.Contract(\n            baseRegistrarAbi,\n            this.registrarAddress\n          );\n        } catch (e) {\n          this.isPermanentLive = false;\n          Toast.responseHandler(\n            'ENS Permanent registrar is not available yet, please try again later',\n            Toast.ERROR\n          );\n        }\n      }\n    },\n    async transferDomain(toAddress) {\n      let to, data;\n      if (this.registrarType === REGISTRAR_TYPES.FIFS) {\n        data = this.ensRegistryContract.methods\n          .setOwner(this.nameHash, toAddress)\n          .encodeABI();\n        to = this.network.type.ens.registry;\n      } else if (this.registrarType === REGISTRAR_TYPES.PERMANENT) {\n        data = this.registrarContract.methods\n          .safeTransferFrom(this.account.address, toAddress, this.labelHash)\n          .encodeABI();\n        to = this.registrarAddress;\n      }\n      const transferTx = {\n        from: this.account.address,\n        to,\n        data,\n        value: 0\n      };\n      this.web3.eth.sendTransaction(transferTx).catch(err => {\n        Toast.responseHandler(err, false);\n      });\n    },\n    async setMultiCoin(coin) {\n      const web3 = this.web3;\n      const address = this.account.address;\n      const publicResolverAddress = this.publicResolverAddress;\n      const currentResolverAddress = await this.ensRegistryContract.methods\n        .resolver(this.nameHash)\n        .call();\n      const publicResolverContract = new web3.eth.Contract(\n        ResolverAbi,\n        publicResolverAddress\n      );\n      const getDecodedAddress = _coinItem => {\n        let decodedAddress = '0x';\n        if (_coinItem.value !== '' && _coinItem.value) {\n          decodedAddress = _coinItem.decode(_coinItem.value);\n        }\n        return decodedAddress;\n      };\n      const setAddrTx = coin.map(item => {\n        return {\n          from: address,\n          to: publicResolverAddress,\n          data: publicResolverContract.methods\n            .setAddr(this.nameHash, item.id, getDecodedAddress(item))\n            .encodeABI(),\n          value: 0,\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n        };\n      });\n\n      if (!this.resolverMultiCoinSupport) {\n        setAddrTx.data = publicResolverContract.methods\n          .setAddr(this.nameHash, getDecodedAddress(coin[0]))\n          .encodeABI();\n      }\n      if (\n        currentResolverAddress.toLowerCase() ===\n        publicResolverAddress.toLowerCase()\n      ) {\n        if (coin.length === 1) {\n          web3.eth.sendTransaction(setAddrTx[0]).catch(err => {\n            Toast.responseHandler(err, false);\n          });\n        } else {\n          web3.mew.sendBatchTransactions([...setAddrTx].filter(Boolean));\n        }\n      } else {\n        const setResolverTx = {\n          from: address,\n          to: this.network.type.ens.registry,\n          data: this.ensRegistryContract.methods\n            .setResolver(this.nameHash, publicResolverAddress)\n            .encodeABI(),\n          value: 0,\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n        };\n        let migrateEthAddress = null;\n        if (\n          coin.id !== this.supportedCoins.ETH.id &&\n          this.supportedCoins.ETH.value\n        ) {\n          migrateEthAddress = {\n            from: address,\n            to: publicResolverAddress,\n            data: publicResolverContract.methods\n              .setAddr(\n                this.nameHash,\n                this.supportedCoins.ETH.id,\n                getDecodedAddress(this.supportedCoins.ETH)\n              )\n              .encodeABI(),\n            value: 0,\n            gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n          };\n        }\n        web3.mew.sendBatchTransactions(\n          [setResolverTx, ...setAddrTx, migrateEthAddress].filter(Boolean)\n        );\n      }\n    },\n    async registerFifsName() {\n      const address = this.account.address;\n      const web3 = this.web3;\n      const data = await this.registrarContract.methods\n        .register(this.labelHash, address)\n        .encodeABI();\n      const raw = {\n        from: address,\n        value: 0,\n        to: this.registrarAddress,\n        data: data\n      };\n      web3.eth.sendTransaction(raw).catch(err => {\n        Toast.responseHandler(err, false);\n      });\n    },\n    async getRegistrarAddress(tld) {\n      const registrarAddress = await this.ens.owner(tld);\n      return registrarAddress;\n    },\n    async checkDomain() {\n      const supportedTlds = this.network.type.ens.supportedTld;\n      const isSupported = supportedTlds.find(item => {\n        return item === this.parsedTld;\n      });\n\n      this.loading = true;\n      const web3 = this.web3;\n\n      this.labelHash = web3.utils.sha3(this.parsedHostName);\n      if (this.parsedTld !== '' && isSupported === undefined) {\n        Toast.responseHandler(\n          `Domain TLD ${this.parsedTld} is not supported in this node!`,\n          Toast.ERROR\n        );\n        this.loading = false;\n      } else if (this.parsedTld === this.registrarTLD) {\n        try {\n          if (\n            this.registrarType === REGISTRAR_TYPES.FIFS &&\n            !this.isSubDomain\n          ) {\n            const expiryTime = await this.registrarContract.methods\n              .expiryTimes(this.labelHash)\n              .call();\n            const isAvailable = expiryTime * 1000 < new Date().getTime();\n            if (isAvailable) {\n              this.$router.push({ path: 'manage-ens/fifs' });\n              this.loading = false;\n            } else {\n              this.getMoreInfo();\n              this.loading = false;\n            }\n          } else if (\n            this.registrarType === REGISTRAR_TYPES.PERMANENT &&\n            !this.isSubDomain\n          ) {\n            if (!this.isPermanentLive) {\n              Toast.responseHandler(\n                'ENS Permanent registrar is not available yet, please try again later',\n                Toast.ERROR\n              );\n              return;\n            }\n            const oldRegistrarAddress = await this.ens\n              .resolver(this.registrarTLD, ResolverAbi)\n              .interfaceImplementer(\n                permanentRegistrar.INTERFACE_LEGACY_REGISTRAR\n              );\n            this.legacyRegistrar = new this.web3.eth.Contract(\n              RegistrarAbi,\n              oldRegistrarAddress\n            );\n            const domainStatus = await this.legacyRegistrar.methods\n              .entries(this.labelHash)\n              .call();\n            if (domainStatus[0] === '2') {\n              const deedContract = new this.web3.eth.Contract(\n                DeedContractAbi,\n                domainStatus[1]\n              );\n              this.deedOwner = await deedContract.methods.owner().call();\n              this.loading = false;\n              this.$router.push({ path: 'manage-ens/transfer-registrar' });\n            } else {\n              const isAvailable = await this.registrarControllerContract.methods\n                .available(this.parsedHostName)\n                .call();\n              if (!isAvailable) this.getMoreInfo();\n              else {\n                this.generateKeyPhrase();\n                this.$router.push({ path: 'manage-ens/create-commitment' });\n                this.loading = false;\n              }\n            }\n          } else if (this.isSubDomain) {\n            const owner = await this.ens.owner(this.parsedDomainName);\n            if (owner === '0x0000000000000000000000000000000000000000') {\n              Toast.responseHandler('This subdomain is not owned', Toast.WARN);\n            } else {\n              this.getMoreInfo();\n            }\n          }\n        } catch (e) {\n          Toast.responseHandler(e, false);\n          this.loading = false;\n        }\n      } else {\n        try {\n          const registrarAddr = await this.ens.owner(this.parsedTld);\n          this.dnsRegistrar = new DNSRegistrar(\n            this.web3.currentProvider,\n            registrarAddr\n          );\n          this.dnsClaim = await this.dnsRegistrar.claim(this.parsedDomainName);\n          const _owner = await this.ens.owner(this.parsedDomainName);\n          if (\n            this.dnsClaim.result.found &&\n            this.dnsClaim.getOwner().toLowerCase() === _owner.toLowerCase()\n          ) {\n            this.getMoreInfo();\n          } else if (this.dnsClaim.result.found) {\n            this.dnsOwner = this.dnsClaim.getOwner();\n            this.processDNSresult('dnsClaimable'); // Claimable\n          } else if (this.dnsClaim.result.nsec) {\n            this.owner = _owner;\n            this.processDNSresult('dnsMissingTXT'); // TXT missing/unclaim\n          } else {\n            this.processDNSresult('dnsNotSetup'); // DNSEC not setup properly\n          }\n        } catch (e) {\n          this.loading = false;\n          Toast.responseHandler(\n            'Something went wrong! Please try again.',\n            Toast.ERROR\n          );\n        }\n      }\n    },\n    async createCommitment() {\n      const utils = this.web3.utils;\n      try {\n        const commitment = await this.registrarControllerContract.methods\n          .makeCommitment(\n            this.parsedHostName,\n            this.account.address,\n            utils.sha3(this.secretPhrase)\n          )\n          .call();\n        this.minimumAge = await this.registrarControllerContract.methods\n          .minCommitmentAge()\n          .call();\n        this.minimumAge = `${parseInt(this.minimumAge) + 30}`;\n        await this.registrarControllerContract.methods\n          .commit(commitment)\n          .send({ from: this.account.address })\n          .once('transactionHash', () => {\n            this.$router.push({ path: 'permanent-registration' });\n          })\n          .on('receipt', () => {\n            this.loading = false;\n            this.commitmentCreated = true;\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(e, Toast.ERROR);\n      }\n    },\n    async registerWithDuration() {\n      const utils = this.web3.utils;\n      this.loading = true;\n      const SECONDS_YEAR = 60 * 60 * 24 * 365.25;\n      const duration = Math.ceil(SECONDS_YEAR * this.duration);\n      try {\n        const rentPrice = await this.registrarControllerContract.methods\n          .rentPrice(this.parsedHostName, duration)\n          .call();\n        this.registrarControllerContract.methods\n          .register(\n            this.parsedHostName,\n            this.account.address,\n            duration,\n            utils.sha3(this.secretPhrase)\n          )\n          .send({ from: this.account.address, value: rentPrice })\n          .once('transactionHash', () => {\n            this.$router.push({ path: 'registration-in-progress' });\n          })\n          .once('receipt', () => {\n            this.getMoreInfo();\n            Toast.responseHandler('Successfully Registered!', Toast.SUCCESS);\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    transferFunc() {\n      this.loading = true;\n      try {\n        this.legacyRegistrar.methods\n          .transferRegistrars(this.labelHash)\n          .send({ from: this.account.address })\n          .once('receipt', () => {\n            this.getMoreInfo();\n            Toast.responseHandler('Successfully Transferred!', Toast.SUCCESS);\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    async claimFunc() {\n      this.loading = true;\n      try {\n        await this.dnsClaim.submit({\n          from: this.account.address\n        });\n        this.loading = false;\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    updateStep(val) {\n      this.step = val;\n    },\n    processDNSresult(type) {\n      this.loading = false;\n      switch (type) {\n        case 'dnsOwned':\n          this.$router.push({ path: 'manage-ens/dns-owned' });\n          break;\n        case 'dnsClaimable':\n          this.$router.push({ path: 'manage-ens/claim' });\n          break;\n        case 'dnsNotSetup':\n          this.$router.push({ path: 'manage-ens/dns-error' });\n          break;\n        case 'dnsMissingTXT':\n          this.$router.push({ path: 'manage-ens/no-txt-setup' });\n          break;\n      }\n    },\n    updateDomainName(value) {\n      try {\n        this.domainName = normalise(value);\n      } catch (e) {\n        Toast.responseHandler(e, Toast.WARN);\n        this.domainNameErr = true;\n        return;\n      }\n      if (this.parsedTld === this.registrarTLD) {\n        this.domainNameErr =\n          value.substr(0, 2) === '0x' || this.parsedHostName.length < 7;\n      } else {\n        this.domainNameErr = false;\n      }\n    },\n    async getMoreInfo() {\n      let owner;\n      const resolver = await this.ens.resolver('resolver.eth');\n      this.publicResolverAddress = await resolver.addr();\n      this.nameHash = nameHashPckg.hash(this.parsedDomainName);\n      try {\n        if (\n          this.registrarType === REGISTRAR_TYPES.PERMANENT &&\n          this.parsedTld === this.registrarTLD &&\n          !this.isSubDomain\n        ) {\n          owner = await this.registrarContract.methods\n            .ownerOf(this.labelHash)\n            .call();\n        } else {\n          owner = await this.ens.owner(this.parsedDomainName);\n        }\n      } catch (e) {\n        owner = '0x';\n        Toast.responseHandler(e, false);\n      }\n      try {\n        const publicResolverContract = new this.web3.eth.Contract(\n          ResolverAbi,\n          this.publicResolverAddress\n        );\n        this.resolverMultiCoinSupport = await publicResolverContract.methods\n          .supportsInterface(MULTICOIN_SUPPORT_INTERFACE)\n          .call();\n      } catch (e) {\n        this.resolverMultiCoinSupport = false;\n      }\n      try {\n        const currentResolverAddress = await this.ensRegistryContract.methods\n          .resolver(this.nameHash)\n          .call();\n        const resolverContract = new this.web3.eth.Contract(\n          ResolverAbi,\n          currentResolverAddress\n        );\n        this.fetchTxtRecords(resolverContract);\n        const supportMultiCoin = await resolverContract.methods\n          .supportsInterface(MULTICOIN_SUPPORT_INTERFACE)\n          .call();\n        for (const type in this.supportedCoins)\n          this.supportedCoins[type].value = '';\n        if (supportMultiCoin) {\n          for (const type in this.supportedCoins) {\n            await this.ens\n              .resolver(this.parsedDomainName, ResolverAbi)\n              .addr(this.supportedCoins[type].id)\n              .then(address => {\n                if (address) {\n                  this.supportedCoins[type].value = this.supportedCoins[\n                    type\n                  ].encode(new Buffer(address.replace('0x', ''), 'hex'));\n                }\n              });\n          }\n        } else {\n          this.supportedCoins['ETH'].value = await this.ens\n            .resolver(this.parsedDomainName)\n            .addr();\n        }\n      } catch (e) {\n        this.supportedCoins['ETH'].value = '0x';\n      }\n      this.owner = owner;\n      if (this.$route.fullPath === '/interface/dapps/manage-ens') {\n        this.$router.push({ path: 'manage-ens/owned' });\n      } else {\n        this.$router.push({ path: 'owned' });\n      }\n      this.loading = false;\n    },\n    async fetchTxtRecords(resolver) {\n      try {\n        const supportsTxt = await resolver.methods\n          .supportsInterface(TEXT_RECORD_SUPPORT_INTERFACE)\n          .call();\n        this.resolverTxtSupport = supportsTxt;\n        if (supportsTxt) {\n          this.recordContract = resolver;\n          const newObj = {};\n          for (const el of this.supportedTxt) {\n            newObj[el.name] = await resolver.methods\n              .text(this.nameHash, el.name)\n              .call();\n          }\n          this.txtRecords = Object.assign({}, newObj);\n        } else {\n          this.recordContract = {};\n          this.txtRecords = {};\n          this.resolverTxtSupport = false;\n        }\n      } catch (e) {\n        this.recordContract = {};\n        this.txtRecords = {};\n        this.resolverTxtSupport = false;\n      }\n    },\n    async setRecord(obj) {\n      const address = this.account.address;\n      const resolverAddr = this.publicResolverAddress;\n      const contract = this.recordContract;\n      const txs = [];\n      for (const i in obj) {\n        txs.push({\n          from: address,\n          to: resolverAddr,\n          data: contract.methods.setText(this.nameHash, i, obj[i]).encodeABI(),\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed(),\n          value: 0\n        });\n      }\n      if (txs.length > 1) {\n        this.web3.mew.sendBatchTransactions([...txs].filter(Boolean));\n      } else {\n        this.web3.eth.sendTransaction(txs[0]);\n      }\n    },\n    updateSecretPhrase(e) {\n      this.secretPhrase = e;\n    },\n    updateDuration(e) {\n      this.duration = e;\n    },\n    generateKeyPhrase() {\n      const wordsArray = [];\n      const min = 0;\n      const max = bip39.wordlists.EN.length;\n\n      for (let i = 0; i < 3; i++) {\n        wordsArray.push(\n          bip39.wordlists.EN[Math.floor(Math.random() * (max - min + 1)) + min]\n        );\n      }\n\n      this.secretPhrase = wordsArray.join(' ');\n    }\n  }\n};\n",{"version":3,"sources":["ManageENS.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"ManageENS.vue","sourceRoot":"src/dapps/ManageENS","sourcesContent":["<template>\n  <div class=\"manage-ens-container\">\n    <back-button />\n    <router-view\n      :contract-initiated=\"contractInitiated\"\n      :check-domain=\"checkDomain\"\n      :secret-phrase=\"secretPhrase\"\n      :host-name=\"parsedHostName\"\n      :domain-name=\"parsedDomainName\"\n      :loading=\"loading\"\n      :name-hash=\"nameHash\"\n      :label-hash=\"labelHash\"\n      :owner=\"owner\"\n      :deed-owner=\"deedOwner\"\n      :raw=\"raw\"\n      :step=\"step\"\n      :domain-name-err=\"domainNameErr\"\n      :generate-key-phrase=\"generateKeyPhrase\"\n      :set-multi-coin=\"setMultiCoin\"\n      :transfer-domain=\"transferDomain\"\n      :tld=\"parsedTld === '' ? network.type.ens.registrarTLD : parsedTld\"\n      :network-name=\"network.type.name\"\n      :register-fifs-name=\"registerFifsName\"\n      :multi-tld=\"multiTld\"\n      :claim-func=\"claimFunc\"\n      :dns-owner=\"dnsOwner\"\n      :dns-claim=\"dnsClaim\"\n      :transfer-func=\"transferFunc\"\n      :create-commitment=\"createCommitment\"\n      :register-with-duration=\"registerWithDuration\"\n      :minimum-age=\"minimumAge\"\n      :commitment-created=\"commitmentCreated\"\n      :resolver-multi-coin-support=\"resolverMultiCoinSupport\"\n      :resolver-txt-support=\"resolverTxtSupport\"\n      :supported-coins=\"supportedCoins\"\n      :txt-records=\"txtRecords\"\n      :set-record=\"setRecord\"\n      @updateSecretPhrase=\"updateSecretPhrase\"\n      @domainNameChange=\"updateDomainName\"\n      @updateStep=\"updateStep\"\n      @updateDuration=\"updateDuration\"\n    />\n  </div>\n</template>\n\n<script>\nimport BackButton from '@/layouts/InterfaceLayout/components/BackButton';\nimport RegistrarAbi from './ABI/registrarAbi';\nimport PermanentRegistrarControllerAbi from './ABI/permanentRegistrarController';\nimport baseRegistrarAbi from './ABI/baseRegistrarAbi';\nimport DeedContractAbi from './ABI/deedContractAbi';\nimport RegistryAbi from './ABI/registryAbi.js';\nimport FifsRegistrarAbi from './ABI/fifsRegistrarAbi.js';\nimport ResolverAbi from './ABI/resolverAbi.js';\nimport * as unit from 'ethjs-unit';\nimport * as nameHashPckg from 'eth-ens-namehash';\nimport normalise from '@/helpers/normalise';\nimport { mapState } from 'vuex';\nimport { Toast } from '@/helpers';\nimport DNSRegistrar from '@ensdomains/dnsregistrar';\nimport BigNumber from 'bignumber.js';\nimport supportedCoins from './supportedCoins';\nimport supportedTxt from './supportedTxt';\n\nconst bip39 = require('bip39');\n\nconst permanentRegistrar = {\n  INTERFACE_CONTROLLER: '0x018fac06',\n  INTERFACE_LEGACY_REGISTRAR: '0x7ba18ba1'\n};\nconst MULTICOIN_SUPPORT_INTERFACE = '0xf1cb7e06';\nconst TEXT_RECORD_SUPPORT_INTERFACE = '0x59d1d43c';\nconst REGISTRAR_TYPES = {\n  FIFS: 'fifs',\n  PERMANENT: 'permanent'\n};\nexport default {\n  components: {\n    'back-button': BackButton\n  },\n  data() {\n    return {\n      domainName: '',\n      loading: false,\n      nameHash: '',\n      labelHash: '',\n      owner: '',\n      deedOwner: '',\n      secretPhrase: '',\n      registrarAddress: '',\n      raw: {},\n      contractInitiated: false,\n      step: 1,\n      domainNameErr: false,\n      ensRegistryContract: {},\n      dnsRegistrar: {},\n      dnsClaim: {},\n      dnsOwner: '',\n      legacyRegistrar: {},\n      minimumAge: 0,\n      duration: 1,\n      commitmentCreated: false,\n      publicResolverAddress: '',\n      resolverMultiCoinSupport: false,\n      supportedCoins,\n      txtRecords: {},\n      supportedTxt,\n      recordContract: {},\n      resolverTxtSupport: false\n    };\n  },\n  computed: {\n    ...mapState(['web3', 'network', 'account', 'gasPrice', 'ens']),\n    registrarTLD() {\n      return this.network.type.ens.registrarTLD;\n    },\n    registrarType() {\n      return this.network.type.ens.registrarType;\n    },\n    multiTld() {\n      return (\n        this.network.type.ens.hasOwnProperty('supportedTld') &&\n        this.network.type.ens.supportedTld.length > 1\n      );\n    },\n    parsedTld() {\n      if (this.parsedHostName.length) {\n        const hasTld = this.domainName.lastIndexOf('.');\n        return hasTld > -1\n          ? this.domainName.substr(hasTld + 1, this.domainName.length)\n          : this.registrarTLD;\n      }\n      return '';\n    },\n    parsedHostName() {\n      return this.domainName.substr(\n        0,\n        this.domainName.lastIndexOf('.') > -1\n          ? this.domainName.lastIndexOf('.')\n          : this.domainName.length\n      );\n    },\n    parsedDomainName() {\n      return this.parsedHostName + '.' + this.parsedTld;\n    },\n    isSubDomain() {\n      return this.domainName.split('.').length - 1 > 1;\n    }\n  },\n  watch: {\n    ens(newVal) {\n      if (newVal) {\n        this.setRegistrar();\n      }\n    }\n  },\n  mounted() {\n    this.$nextTick(() => {\n      this.setup();\n    });\n  },\n  methods: {\n    async setup() {\n      this.isPermanentLive = true;\n      this.domainName = '';\n      this.loading = false;\n      this.nameHash = '';\n      this.labelHash = '';\n      this.owner = '';\n      this.deedOwner = '';\n      this.secretPhrase = '';\n      this.registrarAddress = '';\n      this.raw = {};\n      this.contractInitiated = false;\n      this.step = 1;\n      this.contractInitiated = false;\n      this.contractInitiated = true;\n      this.domainNameErr = false;\n      this.dnsRegistrar = {};\n      this.dnsClaim = {};\n      this.legacyRegistrar = {};\n      this.minimumAge = 0;\n      this.duration = 1;\n      this.commitmentCreated = false;\n      this.publicResolverAddress = '';\n      this.resolverMultiCoinSupport = false;\n      this.resolverTxtSupport = false;\n      this.supportedCoins = supportedCoins;\n      this.txtRecords = {};\n      this.recordContract = {};\n\n      if (this.ens) {\n        this.setRegistrar();\n      }\n      for (const type in this.supportedCoins)\n        this.supportedCoins[type].value = '';\n    },\n    async setRegistrar() {\n      const web3 = this.web3;\n      const tld = this.registrarTLD;\n      this.registrarAddress = await this.getRegistrarAddress(tld);\n      this.ensRegistryContract = new web3.eth.Contract(\n        RegistryAbi,\n        this.network.type.ens.registry\n      );\n      if (this.registrarType === REGISTRAR_TYPES.FIFS) {\n        this.registrarContract = new web3.eth.Contract(\n          FifsRegistrarAbi,\n          this.registrarAddress\n        );\n      } else if (this.registrarType === REGISTRAR_TYPES.PERMANENT) {\n        try {\n          const controllerAddress = await this.ens\n            .resolver(this.registrarTLD, ResolverAbi)\n            .interfaceImplementer(permanentRegistrar.INTERFACE_CONTROLLER);\n          this.registrarControllerContract = new this.web3.eth.Contract(\n            PermanentRegistrarControllerAbi,\n            controllerAddress\n          );\n          this.registrarContract = new this.web3.eth.Contract(\n            baseRegistrarAbi,\n            this.registrarAddress\n          );\n        } catch (e) {\n          this.isPermanentLive = false;\n          Toast.responseHandler(\n            'ENS Permanent registrar is not available yet, please try again later',\n            Toast.ERROR\n          );\n        }\n      }\n    },\n    async transferDomain(toAddress) {\n      let to, data;\n      if (this.registrarType === REGISTRAR_TYPES.FIFS) {\n        data = this.ensRegistryContract.methods\n          .setOwner(this.nameHash, toAddress)\n          .encodeABI();\n        to = this.network.type.ens.registry;\n      } else if (this.registrarType === REGISTRAR_TYPES.PERMANENT) {\n        data = this.registrarContract.methods\n          .safeTransferFrom(this.account.address, toAddress, this.labelHash)\n          .encodeABI();\n        to = this.registrarAddress;\n      }\n      const transferTx = {\n        from: this.account.address,\n        to,\n        data,\n        value: 0\n      };\n      this.web3.eth.sendTransaction(transferTx).catch(err => {\n        Toast.responseHandler(err, false);\n      });\n    },\n    async setMultiCoin(coin) {\n      const web3 = this.web3;\n      const address = this.account.address;\n      const publicResolverAddress = this.publicResolverAddress;\n      const currentResolverAddress = await this.ensRegistryContract.methods\n        .resolver(this.nameHash)\n        .call();\n      const publicResolverContract = new web3.eth.Contract(\n        ResolverAbi,\n        publicResolverAddress\n      );\n      const getDecodedAddress = _coinItem => {\n        let decodedAddress = '0x';\n        if (_coinItem.value !== '' && _coinItem.value) {\n          decodedAddress = _coinItem.decode(_coinItem.value);\n        }\n        return decodedAddress;\n      };\n      const setAddrTx = coin.map(item => {\n        return {\n          from: address,\n          to: publicResolverAddress,\n          data: publicResolverContract.methods\n            .setAddr(this.nameHash, item.id, getDecodedAddress(item))\n            .encodeABI(),\n          value: 0,\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n        };\n      });\n\n      if (!this.resolverMultiCoinSupport) {\n        setAddrTx.data = publicResolverContract.methods\n          .setAddr(this.nameHash, getDecodedAddress(coin[0]))\n          .encodeABI();\n      }\n      if (\n        currentResolverAddress.toLowerCase() ===\n        publicResolverAddress.toLowerCase()\n      ) {\n        if (coin.length === 1) {\n          web3.eth.sendTransaction(setAddrTx[0]).catch(err => {\n            Toast.responseHandler(err, false);\n          });\n        } else {\n          web3.mew.sendBatchTransactions([...setAddrTx].filter(Boolean));\n        }\n      } else {\n        const setResolverTx = {\n          from: address,\n          to: this.network.type.ens.registry,\n          data: this.ensRegistryContract.methods\n            .setResolver(this.nameHash, publicResolverAddress)\n            .encodeABI(),\n          value: 0,\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n        };\n        let migrateEthAddress = null;\n        if (\n          coin.id !== this.supportedCoins.ETH.id &&\n          this.supportedCoins.ETH.value\n        ) {\n          migrateEthAddress = {\n            from: address,\n            to: publicResolverAddress,\n            data: publicResolverContract.methods\n              .setAddr(\n                this.nameHash,\n                this.supportedCoins.ETH.id,\n                getDecodedAddress(this.supportedCoins.ETH)\n              )\n              .encodeABI(),\n            value: 0,\n            gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed()\n          };\n        }\n        web3.mew.sendBatchTransactions(\n          [setResolverTx, ...setAddrTx, migrateEthAddress].filter(Boolean)\n        );\n      }\n    },\n    async registerFifsName() {\n      const address = this.account.address;\n      const web3 = this.web3;\n      const data = await this.registrarContract.methods\n        .register(this.labelHash, address)\n        .encodeABI();\n      const raw = {\n        from: address,\n        value: 0,\n        to: this.registrarAddress,\n        data: data\n      };\n      web3.eth.sendTransaction(raw).catch(err => {\n        Toast.responseHandler(err, false);\n      });\n    },\n    async getRegistrarAddress(tld) {\n      const registrarAddress = await this.ens.owner(tld);\n      return registrarAddress;\n    },\n    async checkDomain() {\n      const supportedTlds = this.network.type.ens.supportedTld;\n      const isSupported = supportedTlds.find(item => {\n        return item === this.parsedTld;\n      });\n\n      this.loading = true;\n      const web3 = this.web3;\n\n      this.labelHash = web3.utils.sha3(this.parsedHostName);\n      if (this.parsedTld !== '' && isSupported === undefined) {\n        Toast.responseHandler(\n          `Domain TLD ${this.parsedTld} is not supported in this node!`,\n          Toast.ERROR\n        );\n        this.loading = false;\n      } else if (this.parsedTld === this.registrarTLD) {\n        try {\n          if (\n            this.registrarType === REGISTRAR_TYPES.FIFS &&\n            !this.isSubDomain\n          ) {\n            const expiryTime = await this.registrarContract.methods\n              .expiryTimes(this.labelHash)\n              .call();\n            const isAvailable = expiryTime * 1000 < new Date().getTime();\n            if (isAvailable) {\n              this.$router.push({ path: 'manage-ens/fifs' });\n              this.loading = false;\n            } else {\n              this.getMoreInfo();\n              this.loading = false;\n            }\n          } else if (\n            this.registrarType === REGISTRAR_TYPES.PERMANENT &&\n            !this.isSubDomain\n          ) {\n            if (!this.isPermanentLive) {\n              Toast.responseHandler(\n                'ENS Permanent registrar is not available yet, please try again later',\n                Toast.ERROR\n              );\n              return;\n            }\n            const oldRegistrarAddress = await this.ens\n              .resolver(this.registrarTLD, ResolverAbi)\n              .interfaceImplementer(\n                permanentRegistrar.INTERFACE_LEGACY_REGISTRAR\n              );\n            this.legacyRegistrar = new this.web3.eth.Contract(\n              RegistrarAbi,\n              oldRegistrarAddress\n            );\n            const domainStatus = await this.legacyRegistrar.methods\n              .entries(this.labelHash)\n              .call();\n            if (domainStatus[0] === '2') {\n              const deedContract = new this.web3.eth.Contract(\n                DeedContractAbi,\n                domainStatus[1]\n              );\n              this.deedOwner = await deedContract.methods.owner().call();\n              this.loading = false;\n              this.$router.push({ path: 'manage-ens/transfer-registrar' });\n            } else {\n              const isAvailable = await this.registrarControllerContract.methods\n                .available(this.parsedHostName)\n                .call();\n              if (!isAvailable) this.getMoreInfo();\n              else {\n                this.generateKeyPhrase();\n                this.$router.push({ path: 'manage-ens/create-commitment' });\n                this.loading = false;\n              }\n            }\n          } else if (this.isSubDomain) {\n            const owner = await this.ens.owner(this.parsedDomainName);\n            if (owner === '0x0000000000000000000000000000000000000000') {\n              Toast.responseHandler('This subdomain is not owned', Toast.WARN);\n            } else {\n              this.getMoreInfo();\n            }\n          }\n        } catch (e) {\n          Toast.responseHandler(e, false);\n          this.loading = false;\n        }\n      } else {\n        try {\n          const registrarAddr = await this.ens.owner(this.parsedTld);\n          this.dnsRegistrar = new DNSRegistrar(\n            this.web3.currentProvider,\n            registrarAddr\n          );\n          this.dnsClaim = await this.dnsRegistrar.claim(this.parsedDomainName);\n          const _owner = await this.ens.owner(this.parsedDomainName);\n          if (\n            this.dnsClaim.result.found &&\n            this.dnsClaim.getOwner().toLowerCase() === _owner.toLowerCase()\n          ) {\n            this.getMoreInfo();\n          } else if (this.dnsClaim.result.found) {\n            this.dnsOwner = this.dnsClaim.getOwner();\n            this.processDNSresult('dnsClaimable'); // Claimable\n          } else if (this.dnsClaim.result.nsec) {\n            this.owner = _owner;\n            this.processDNSresult('dnsMissingTXT'); // TXT missing/unclaim\n          } else {\n            this.processDNSresult('dnsNotSetup'); // DNSEC not setup properly\n          }\n        } catch (e) {\n          this.loading = false;\n          Toast.responseHandler(\n            'Something went wrong! Please try again.',\n            Toast.ERROR\n          );\n        }\n      }\n    },\n    async createCommitment() {\n      const utils = this.web3.utils;\n      try {\n        const commitment = await this.registrarControllerContract.methods\n          .makeCommitment(\n            this.parsedHostName,\n            this.account.address,\n            utils.sha3(this.secretPhrase)\n          )\n          .call();\n        this.minimumAge = await this.registrarControllerContract.methods\n          .minCommitmentAge()\n          .call();\n        this.minimumAge = `${parseInt(this.minimumAge) + 30}`;\n        await this.registrarControllerContract.methods\n          .commit(commitment)\n          .send({ from: this.account.address })\n          .once('transactionHash', () => {\n            this.$router.push({ path: 'permanent-registration' });\n          })\n          .on('receipt', () => {\n            this.loading = false;\n            this.commitmentCreated = true;\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(e, Toast.ERROR);\n      }\n    },\n    async registerWithDuration() {\n      const utils = this.web3.utils;\n      this.loading = true;\n      const SECONDS_YEAR = 60 * 60 * 24 * 365.25;\n      const duration = Math.ceil(SECONDS_YEAR * this.duration);\n      try {\n        const rentPrice = await this.registrarControllerContract.methods\n          .rentPrice(this.parsedHostName, duration)\n          .call();\n        this.registrarControllerContract.methods\n          .register(\n            this.parsedHostName,\n            this.account.address,\n            duration,\n            utils.sha3(this.secretPhrase)\n          )\n          .send({ from: this.account.address, value: rentPrice })\n          .once('transactionHash', () => {\n            this.$router.push({ path: 'registration-in-progress' });\n          })\n          .once('receipt', () => {\n            this.getMoreInfo();\n            Toast.responseHandler('Successfully Registered!', Toast.SUCCESS);\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    transferFunc() {\n      this.loading = true;\n      try {\n        this.legacyRegistrar.methods\n          .transferRegistrars(this.labelHash)\n          .send({ from: this.account.address })\n          .once('receipt', () => {\n            this.getMoreInfo();\n            Toast.responseHandler('Successfully Transferred!', Toast.SUCCESS);\n          });\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    async claimFunc() {\n      this.loading = true;\n      try {\n        await this.dnsClaim.submit({\n          from: this.account.address\n        });\n        this.loading = false;\n      } catch (e) {\n        this.loading = false;\n        Toast.responseHandler(\n          'Something went wrong! Please try again.',\n          Toast.ERROR\n        );\n      }\n    },\n    updateStep(val) {\n      this.step = val;\n    },\n    processDNSresult(type) {\n      this.loading = false;\n      switch (type) {\n        case 'dnsOwned':\n          this.$router.push({ path: 'manage-ens/dns-owned' });\n          break;\n        case 'dnsClaimable':\n          this.$router.push({ path: 'manage-ens/claim' });\n          break;\n        case 'dnsNotSetup':\n          this.$router.push({ path: 'manage-ens/dns-error' });\n          break;\n        case 'dnsMissingTXT':\n          this.$router.push({ path: 'manage-ens/no-txt-setup' });\n          break;\n      }\n    },\n    updateDomainName(value) {\n      try {\n        this.domainName = normalise(value);\n      } catch (e) {\n        Toast.responseHandler(e, Toast.WARN);\n        this.domainNameErr = true;\n        return;\n      }\n      if (this.parsedTld === this.registrarTLD) {\n        this.domainNameErr =\n          value.substr(0, 2) === '0x' || this.parsedHostName.length < 7;\n      } else {\n        this.domainNameErr = false;\n      }\n    },\n    async getMoreInfo() {\n      let owner;\n      const resolver = await this.ens.resolver('resolver.eth');\n      this.publicResolverAddress = await resolver.addr();\n      this.nameHash = nameHashPckg.hash(this.parsedDomainName);\n      try {\n        if (\n          this.registrarType === REGISTRAR_TYPES.PERMANENT &&\n          this.parsedTld === this.registrarTLD &&\n          !this.isSubDomain\n        ) {\n          owner = await this.registrarContract.methods\n            .ownerOf(this.labelHash)\n            .call();\n        } else {\n          owner = await this.ens.owner(this.parsedDomainName);\n        }\n      } catch (e) {\n        owner = '0x';\n        Toast.responseHandler(e, false);\n      }\n      try {\n        const publicResolverContract = new this.web3.eth.Contract(\n          ResolverAbi,\n          this.publicResolverAddress\n        );\n        this.resolverMultiCoinSupport = await publicResolverContract.methods\n          .supportsInterface(MULTICOIN_SUPPORT_INTERFACE)\n          .call();\n      } catch (e) {\n        this.resolverMultiCoinSupport = false;\n      }\n      try {\n        const currentResolverAddress = await this.ensRegistryContract.methods\n          .resolver(this.nameHash)\n          .call();\n        const resolverContract = new this.web3.eth.Contract(\n          ResolverAbi,\n          currentResolverAddress\n        );\n        this.fetchTxtRecords(resolverContract);\n        const supportMultiCoin = await resolverContract.methods\n          .supportsInterface(MULTICOIN_SUPPORT_INTERFACE)\n          .call();\n        for (const type in this.supportedCoins)\n          this.supportedCoins[type].value = '';\n        if (supportMultiCoin) {\n          for (const type in this.supportedCoins) {\n            await this.ens\n              .resolver(this.parsedDomainName, ResolverAbi)\n              .addr(this.supportedCoins[type].id)\n              .then(address => {\n                if (address) {\n                  this.supportedCoins[type].value = this.supportedCoins[\n                    type\n                  ].encode(new Buffer(address.replace('0x', ''), 'hex'));\n                }\n              });\n          }\n        } else {\n          this.supportedCoins['ETH'].value = await this.ens\n            .resolver(this.parsedDomainName)\n            .addr();\n        }\n      } catch (e) {\n        this.supportedCoins['ETH'].value = '0x';\n      }\n      this.owner = owner;\n      if (this.$route.fullPath === '/interface/dapps/manage-ens') {\n        this.$router.push({ path: 'manage-ens/owned' });\n      } else {\n        this.$router.push({ path: 'owned' });\n      }\n      this.loading = false;\n    },\n    async fetchTxtRecords(resolver) {\n      try {\n        const supportsTxt = await resolver.methods\n          .supportsInterface(TEXT_RECORD_SUPPORT_INTERFACE)\n          .call();\n        this.resolverTxtSupport = supportsTxt;\n        if (supportsTxt) {\n          this.recordContract = resolver;\n          const newObj = {};\n          for (const el of this.supportedTxt) {\n            newObj[el.name] = await resolver.methods\n              .text(this.nameHash, el.name)\n              .call();\n          }\n          this.txtRecords = Object.assign({}, newObj);\n        } else {\n          this.recordContract = {};\n          this.txtRecords = {};\n          this.resolverTxtSupport = false;\n        }\n      } catch (e) {\n        this.recordContract = {};\n        this.txtRecords = {};\n        this.resolverTxtSupport = false;\n      }\n    },\n    async setRecord(obj) {\n      const address = this.account.address;\n      const resolverAddr = this.publicResolverAddress;\n      const contract = this.recordContract;\n      const txs = [];\n      for (const i in obj) {\n        txs.push({\n          from: address,\n          to: resolverAddr,\n          data: contract.methods.setText(this.nameHash, i, obj[i]).encodeABI(),\n          gasPrice: new BigNumber(unit.toWei(this.gasPrice, 'gwei')).toFixed(),\n          value: 0\n        });\n      }\n      if (txs.length > 1) {\n        this.web3.mew.sendBatchTransactions([...txs].filter(Boolean));\n      } else {\n        this.web3.eth.sendTransaction(txs[0]);\n      }\n    },\n    updateSecretPhrase(e) {\n      this.secretPhrase = e;\n    },\n    updateDuration(e) {\n      this.duration = e;\n    },\n    generateKeyPhrase() {\n      const wordsArray = [];\n      const min = 0;\n      const max = bip39.wordlists.EN.length;\n\n      for (let i = 0; i < 3; i++) {\n        wordsArray.push(\n          bip39.wordlists.EN[Math.floor(Math.random() * (max - min + 1)) + min]\n        );\n      }\n\n      this.secretPhrase = wordsArray.join(' ');\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import 'ManageENS.scss';\n</style>\n"]}]}