{"remainingRequest":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/layouts/InterfaceLayout/containers/NFTManagerContainer/components/NftCustomAddModal/NftCustomAddModal.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/src/layouts/InterfaceLayout/containers/NFTManagerContainer/components/NftCustomAddModal/NftCustomAddModal.vue","mtime":1573477612020},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/karthik/Desktop/myetherwallet/ethereum-wallet-app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport InterfaceBottomText from '@/components/InterfaceBottomText';\nimport { mapState } from 'vuex';\nimport { isAddress } from '@/helpers/addressUtils';\n\nexport default {\n  components: {\n    'interface-bottom-text': InterfaceBottomText\n  },\n  props: {\n    addToken: {\n      type: Function,\n      default: function() {}\n    },\n    activeAddress: {\n      type: String,\n      default: ''\n    }\n  },\n  data() {\n    return {\n      contractAddress: '',\n      tokenSymbol: '',\n      tokenDecimal: '',\n      validAddress: false,\n      nonStandardMessage: false\n    };\n  },\n  computed: {\n    ...mapState(['web3']),\n    allFieldsValid() {\n      if (!this.validAddress) return false;\n      if (this.tokenSymbol === '') return false;\n      if (this.errors.has('address') || this.errors.has('symbol')) return false;\n      return true;\n    }\n  },\n  watch: {\n    contractAddress(newVal) {\n      const strippedWhitespace = newVal.toLowerCase().trim();\n      const regTest = new RegExp(/[a-zA-Z0-9]/g);\n      this.validAddress =\n        regTest.test(strippedWhitespace) && isAddress(strippedWhitespace);\n      this.toAddress = strippedWhitespace;\n      this.contractAddress = strippedWhitespace;\n    },\n    tokenSymbol(newVal) {\n      this.tokenSymbol = newVal;\n    }\n  },\n  methods: {\n    resetCompState() {\n      this.contractAddress = '';\n      this.tokenSymbol = '';\n      this.tokenDecimal = '';\n      this.validAddress = false;\n      this.nonStandardMessage = false;\n    },\n    async addCustom(address, symbol) {\n      const result = await this.checkIfStandard(address);\n      if (result) this.addToken(address, symbol);\n      else {\n        this.nonStandardMessage = true;\n      }\n    },\n    openCustomModal() {\n      this.$refs.customModal.$refs.modal.show();\n    },\n    checkIfStandard(address) {\n      return new Promise(resolve => {\n        // 0x780e9d63\n        const tokenContract = new this.web3.eth.Contract([\n          {\n            constant: true,\n            inputs: [\n              { name: '_owner', type: 'address' },\n              { name: '_index', type: 'uint256' }\n            ],\n            name: 'tokenOfOwnerByIndex',\n            outputs: [{ name: '', type: 'uint256' }],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function'\n          },\n          {\n            constant: true,\n            inputs: [{ name: '_interfaceId', type: 'bytes4' }],\n            name: 'supportsInterface',\n            outputs: [{ name: '', type: 'bool' }],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function'\n          }\n        ]);\n        tokenContract.options.address = address;\n        tokenContract.methods\n          .supportsInterface('0x780e9d63')\n          .call()\n          .then(res => {\n            if (res) resolve(true);\n            else {\n              tokenContract.methods\n                .tokenOfOwnerByIndex(this.activeAddress, 0)\n                .call()\n                .then(() => {\n                  resolve(true);\n                })\n                .catch(() => {\n                  resolve(false);\n                });\n            }\n          })\n          .catch(() => {\n            resolve(false);\n          });\n      });\n    }\n  }\n};\n",{"version":3,"sources":["NftCustomAddModal.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"NftCustomAddModal.vue","sourceRoot":"src/layouts/InterfaceLayout/containers/NFTManagerContainer/components/NftCustomAddModal","sourcesContent":["<template lang=\"html\">\n  <div>\n    <b-modal\n      ref=\"modal\"\n      :title=\"$t('dapps.addCustomNFT')\"\n      hide-footer\n      class=\"bootstrap-modal nopadding max-height-1\"\n      centered\n      @hidden=\"resetCompState\"\n    >\n      <form class=\"tokens-modal-body\" @keydown.enter.prevent>\n        <div>\n          <input\n            v-validate=\"'required'\"\n            v-model=\"contractAddress\"\n            :class=\"[\n              'custom-input-text-1',\n              contractAddress !== '' && !validAddress ? 'invalid-address' : ''\n            ]\"\n            name=\"Address\"\n            type=\"text\"\n            placeholder=\"Token Contract Address\"\n          />\n          <span\n            v-show=\"contractAddress !== '' && !validAddress\"\n            class=\"error-message\"\n          >\n            Invalid address given.\n          </span>\n          <span v-show=\"nonStandardMessage\">\n            NFT token contract doesn't include a required method to add as a\n            custom NFT or you do not have\n          </span>\n          <input\n            v-validate=\"'required'\"\n            v-model=\"tokenSymbol\"\n            name=\"Symbol\"\n            type=\"text\"\n            placeholder=\"NFT name\"\n            class=\"custom-input-text-1\"\n          />\n        </div>\n        <div class=\"button-block\">\n          <button\n            :class=\"[\n              allFieldsValid ? '' : 'disabled',\n              'save-button large-round-button-green-filled clickable'\n            ]\"\n            @click.prevent=\"addCustom(contractAddress, tokenSymbol)\"\n          >\n            {{ $t('interface.save') }}\n          </button>\n          <interface-bottom-text\n            :link-text=\"$t('interface.helpCenter')\"\n            :question=\"$t('interface.dontKnow')\"\n            link=\"https://kb.myetherwallet.com\"\n          />\n        </div>\n      </form>\n    </b-modal>\n  </div>\n</template>\n\n<script>\nimport InterfaceBottomText from '@/components/InterfaceBottomText';\nimport { mapState } from 'vuex';\nimport { isAddress } from '@/helpers/addressUtils';\n\nexport default {\n  components: {\n    'interface-bottom-text': InterfaceBottomText\n  },\n  props: {\n    addToken: {\n      type: Function,\n      default: function() {}\n    },\n    activeAddress: {\n      type: String,\n      default: ''\n    }\n  },\n  data() {\n    return {\n      contractAddress: '',\n      tokenSymbol: '',\n      tokenDecimal: '',\n      validAddress: false,\n      nonStandardMessage: false\n    };\n  },\n  computed: {\n    ...mapState(['web3']),\n    allFieldsValid() {\n      if (!this.validAddress) return false;\n      if (this.tokenSymbol === '') return false;\n      if (this.errors.has('address') || this.errors.has('symbol')) return false;\n      return true;\n    }\n  },\n  watch: {\n    contractAddress(newVal) {\n      const strippedWhitespace = newVal.toLowerCase().trim();\n      const regTest = new RegExp(/[a-zA-Z0-9]/g);\n      this.validAddress =\n        regTest.test(strippedWhitespace) && isAddress(strippedWhitespace);\n      this.toAddress = strippedWhitespace;\n      this.contractAddress = strippedWhitespace;\n    },\n    tokenSymbol(newVal) {\n      this.tokenSymbol = newVal;\n    }\n  },\n  methods: {\n    resetCompState() {\n      this.contractAddress = '';\n      this.tokenSymbol = '';\n      this.tokenDecimal = '';\n      this.validAddress = false;\n      this.nonStandardMessage = false;\n    },\n    async addCustom(address, symbol) {\n      const result = await this.checkIfStandard(address);\n      if (result) this.addToken(address, symbol);\n      else {\n        this.nonStandardMessage = true;\n      }\n    },\n    openCustomModal() {\n      this.$refs.customModal.$refs.modal.show();\n    },\n    checkIfStandard(address) {\n      return new Promise(resolve => {\n        // 0x780e9d63\n        const tokenContract = new this.web3.eth.Contract([\n          {\n            constant: true,\n            inputs: [\n              { name: '_owner', type: 'address' },\n              { name: '_index', type: 'uint256' }\n            ],\n            name: 'tokenOfOwnerByIndex',\n            outputs: [{ name: '', type: 'uint256' }],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function'\n          },\n          {\n            constant: true,\n            inputs: [{ name: '_interfaceId', type: 'bytes4' }],\n            name: 'supportsInterface',\n            outputs: [{ name: '', type: 'bool' }],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function'\n          }\n        ]);\n        tokenContract.options.address = address;\n        tokenContract.methods\n          .supportsInterface('0x780e9d63')\n          .call()\n          .then(res => {\n            if (res) resolve(true);\n            else {\n              tokenContract.methods\n                .tokenOfOwnerByIndex(this.activeAddress, 0)\n                .call()\n                .then(() => {\n                  resolve(true);\n                })\n                .catch(() => {\n                  resolve(false);\n                });\n            }\n          })\n          .catch(() => {\n            resolve(false);\n          });\n      });\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import 'NftCustomAddModal.scss';\n</style>\n"]}]}