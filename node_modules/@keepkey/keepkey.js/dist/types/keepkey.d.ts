import Device from './device';
import Types from './kkProto/types_pb';
import Messages from './kkProto/messages_pb';
import { WebUSBDeviceConfig } from './webUSBDevice';
import { Event } from './event';
interface KeepKeyConfig {
    autoButton?: boolean;
    device?: Device;
}
export default class KeepKey {
    features: Messages.Features.AsObject;
    autoButton: boolean;
    device: Device;
    constructor(config: KeepKeyConfig);
    static withWebUSB(webUSBDeviceConfig: WebUSBDeviceConfig): KeepKey;
    acknowledgeWithCharacter(character: string): Promise<[number, any]>;
    acknowledgeWithCharacterDelete(): Promise<[number, any]>;
    acknowledgeWithCharacterDone(): Promise<[number, any]>;
    acknowledgeWithCharacterProto(character: string, _delete: boolean, _done: boolean): Promise<[number, any]>;
    acknowledgeWithPassphrase(passphrase: string): Promise<[number, any]>;
    acknowledgeWithPin(pin: string): Promise<[number, any]>;
    applyPolicy(p: Types.PolicyType.AsObject): Promise<void>;
    applySettings(s: Messages.ApplySettings.AsObject): Promise<void>;
    cancel(): Promise<void>;
    changePin(): Promise<void>;
    cipherKeyValue(v: Messages.CipherKeyValue.AsObject): Promise<string | Uint8Array>;
    clearSession(): Promise<void>;
    decryptKeyValue(v: Messages.CipherKeyValue.AsObject): Promise<string | Uint8Array>;
    ethereumGetAddress(a: Messages.EthereumGetAddress.AsObject): Promise<string>;
    ethereumSignTx(tx: Messages.EthereumSignTx.AsObject, addressType?: Types.OutputAddressType, exchangeType?: Types.ExchangeType, data?: Uint8Array | string, chainId?: number): Promise<any>;
    ethereumSignMessage(m: Messages.EthereumSignMessage.AsObject): Promise<any>;
    ethereumVerifyMessage(m: Messages.EthereumVerifyMessage.AsObject): Promise<any>;
    firmwareErase(): Promise<void>;
    initialize(): Promise<Messages.Features.AsObject | void>;
    getAddress(g: Messages.GetAddress.AsObject): Promise<string>;
    getFeatures(): Promise<Messages.Features.AsObject>;
    getEntropy(size: number): Promise<string | Uint8Array>;
    getPublicKey(g: Messages.GetPublicKey.AsObject): Promise<[Types.HDNodeType.AsObject, string]>;
    getNumCoins(): Promise<number>;
    getAllCoinsAsMap(): Promise<{}>;
    getCoinTable(start?: number, end?: number): Promise<Types.CoinType.AsObject[]>;
    getCoinShortcutXPubPairs(coinTable: Types.CoinType.AsObject[]): Promise<[string, string][]>;
    loadDevice(l: Messages.LoadDevice.AsObject): Promise<void>;
    recoveryDevice(r: Messages.RecoveryDevice.AsObject): Promise<void>;
    ping(p: Messages.Ping.AsObject): Promise<string | undefined>;
    private prepareSignTx;
    removePin(): Promise<void>;
    resetDevice(r: Messages.ResetDevice.AsObject): Promise<void>;
    send(events: Event[]): Promise<void>;
    signTransaction(coinName: string, inputs: any[], outputs: any[], exchangeOutputs?: any[], version?: number, lockTime?: number): Promise<[string[], string]>;
    signMessage(s: Messages.SignMessage.AsObject): Promise<Array<string | Uint8Array>>;
    softReset(): Promise<void>;
    verifyMessage(addr: string, coinName: string, msg: string | Uint8Array, sig: string | Uint8Array): Promise<void>;
    wipeDevice(): Promise<void>;
}
export {};
