"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var keepkey_1 = require("./keepkey");
var mockCall = keepkey_1.default.prototype.acknowledgeWithCharacterProto = jest.fn();
jest.mock('./messageNameRegistry', function () { return ({}); });
jest.mock('./messageTypeRegistry', function () { return ({}); });
jest.mock('./kkProto/messages_pb', function () { return ({
    default: {
        MessageType: {}
    }
}); });
describe('KeepKey', function () {
    test('should instantiate a new KeepKey with default values', function () {
        var keepkey = new keepkey_1.default({});
        expect(keepkey).toEqual(expect.objectContaining({
            autoButton: false,
            device: null
        }));
    });
    test('should call acknowledgeWithCharacterProto when acknowledging with character', function () {
        var keepkey = new keepkey_1.default({});
        // tslint:disable-next-line:no-floating-promises
        expect(keepkey.acknowledgeWithCharacter('a')).toEqual(expect.any(Promise));
        expect(mockCall).toHaveBeenCalledTimes(1);
        expect(mockCall.mock.calls[0]).toEqual(expect.arrayContaining([
            'a',
            false,
            false
        ]));
    });
    test('should call acknowledgeWithCharacterProto when acknowledging with character delete', function () {
        var keepkey = new keepkey_1.default({});
        // tslint:disable-next-line:no-floating-promises
        expect(keepkey.acknowledgeWithCharacterDelete()).toEqual(expect.any(Promise));
        expect(mockCall).toHaveBeenCalledTimes(2);
        expect(mockCall.mock.calls[1]).toEqual(expect.arrayContaining([
            '',
            true,
            false
        ]));
    });
    test('should call acknowledgeWithCharacterProto when acknowledging with character done', function () {
        var keepkey = new keepkey_1.default({});
        // tslint:disable-next-line:no-floating-promises
        expect(keepkey.acknowledgeWithCharacterDone()).toEqual(expect.any(Promise));
        expect(mockCall).toHaveBeenCalledTimes(3);
        expect(mockCall.mock.calls[2]).toEqual(expect.arrayContaining([
            '',
            false,
            true
        ]));
    });
});
//# sourceMappingURL=keepkey.test.js.map