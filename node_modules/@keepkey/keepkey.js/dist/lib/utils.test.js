"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Messages = require("./kkProto/messages_pb");
var utils = require("./utils");
describe('utils', function () {
    test('isArray', function () {
        expect(utils.isArray([])).toBe(true);
        expect(utils.isArray([1, 2, 3])).toBe(true);
        expect(utils.isArray([{ a: 'a' }])).toBe(true);
        expect(utils.isArray({})).toBe(false);
    });
    test('toHexString', function () {
        expect(utils.toHexString(new Uint8Array([1, 2]))).toEqual('0102');
        expect(utils.toHexString(new Uint8Array(1))).toEqual('00');
    });
    describe('arrayify', function () {
        test('should error with null', function () {
            expect(function () { return utils.arrayify(null); }).toThrow('cannot convert null value to array');
        });
        test('should error with invalid hex string', function () {
            expect(function () { return utils.arrayify('0x!'); }).toThrow('invalid hexidecimal string');
        });
        test('should error when not beginning with "0x"', function () {
            expect(function () { return utils.arrayify('123123'); }).toThrow('hex string must have 0x prefix');
        });
        test('should append 0 to beginning when string is not divisible by 2', function () {
            expect(utils.arrayify('0x123')).toEqual(utils.arrayify('0x0123'));
        });
        test('should convert result into Uint8Array', function () {
            expect(utils.arrayify('0x00')).toEqual(expect.any(Uint8Array));
        });
    });
    test('protoFieldToSetMethod', function () {
        expect(utils.protoFieldToSetMethod('test')).toEqual('setTest');
    });
    test('leByteArrayToLong', function () {
        expect(utils.leByteArrayToLong([1, 0])).toEqual(256);
        expect(utils.leByteArrayToLong([0, 0])).toEqual(0);
        expect(utils.leByteArrayToLong([0, 1])).toEqual(1);
    });
    describe('fromHexString', function () {
        test('hex string match', function () {
            expect(utils.fromHexString('0x000000')).toEqual(new Uint8Array([0, 0, 0, 0]));
        });
        test('hex string no match', function () {
            expect(utils.fromHexString('!')).toEqual(new Uint8Array([0]));
        });
    });
    describe('bip32ToAddressNList', function () {
        test('formats return value correctly', function () {
            expect(utils.bip32ToAddressNList("m/44'/60'/0'/0/0")).toEqual([2147483692, 2147483708, 2147483648, 0, 0]);
        });
        test('will always return an array if the path looks valid', function () {
            expect(utils.bip32ToAddressNList("m/")).toEqual([]);
        });
        test('throws when given an incorrect bip32 path', function () {
            expect(function () { return utils.bip32ToAddressNList("/44'/60'/0'/0/0"); }).toThrow();
        });
        test('doesnt throw when being used to build proto messages', function () {
            expect(function () {
                var nodePath = utils.bip32ToAddressNList("m/44'/60'/0'/0/0");
                var est = new Messages.EthereumSignTx();
                est.setAddressNList(nodePath);
            }).not.toThrow();
        });
    });
    describe('bip32Like', function () {
        test('returns true if path is valid', function () {
            expect(utils.bip32Like("m/")).toEqual(true);
        });
        test('returns false otherwise', function () {
            expect(utils.bip32Like("/44'/60'/0'/0/0")).toEqual(false);
        });
    });
});
//# sourceMappingURL=utils.test.js.map